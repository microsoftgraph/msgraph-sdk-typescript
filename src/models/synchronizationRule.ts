import { createContainerFilterFromDiscriminatorValue, serializeContainerFilter, type ContainerFilter } from './containerFilter';
import { createGroupFilterFromDiscriminatorValue, serializeGroupFilter, type GroupFilter } from './groupFilter';
import { createObjectMappingFromDiscriminatorValue, serializeObjectMapping, type ObjectMapping } from './objectMapping';
import { createStringKeyStringValuePairFromDiscriminatorValue, serializeStringKeyStringValuePair, type StringKeyStringValuePair } from './stringKeyStringValuePair';
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function createSynchronizationRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoSynchronizationRule;
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function deserializeIntoSynchronizationRule(synchronizationRule: SynchronizationRule | undefined = {} as SynchronizationRule) : Record<string, (node: ParseNode) => void> {
    return {
        "containerFilter": n => { synchronizationRule.containerFilter = n.getObjectValue<ContainerFilter>(createContainerFilterFromDiscriminatorValue); },
        "editable": n => { synchronizationRule.editable = n.getBooleanValue(); },
        "groupFilter": n => { synchronizationRule.groupFilter = n.getObjectValue<GroupFilter>(createGroupFilterFromDiscriminatorValue); },
        "id": n => { synchronizationRule.id = n.getStringValue(); },
        "metadata": n => { synchronizationRule.metadata = n.getCollectionOfObjectValues<StringKeyStringValuePair>(createStringKeyStringValuePairFromDiscriminatorValue); },
        "name": n => { synchronizationRule.name = n.getStringValue(); },
        "objectMappings": n => { synchronizationRule.objectMappings = n.getCollectionOfObjectValues<ObjectMapping>(createObjectMappingFromDiscriminatorValue); },
        "@odata.type": n => { synchronizationRule.odataType = n.getStringValue(); },
        "priority": n => { synchronizationRule.priority = n.getNumberValue(); },
        "sourceDirectoryName": n => { synchronizationRule.sourceDirectoryName = n.getStringValue(); },
        "targetDirectoryName": n => { synchronizationRule.targetDirectoryName = n.getStringValue(); },
    }
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function serializeSynchronizationRule(writer: SerializationWriter, synchronizationRule: SynchronizationRule | undefined = {} as SynchronizationRule) : void {
        writer.writeObjectValue<ContainerFilter>("containerFilter", synchronizationRule.containerFilter, );
        writer.writeBooleanValue("editable", synchronizationRule.editable);
        writer.writeObjectValue<GroupFilter>("groupFilter", synchronizationRule.groupFilter, );
        writer.writeStringValue("id", synchronizationRule.id);
        writer.writeCollectionOfObjectValues<StringKeyStringValuePair>("metadata", synchronizationRule.metadata, );
        writer.writeStringValue("name", synchronizationRule.name);
        writer.writeCollectionOfObjectValues<ObjectMapping>("objectMappings", synchronizationRule.objectMappings, );
        writer.writeStringValue("@odata.type", synchronizationRule.odataType);
        writer.writeNumberValue("priority", synchronizationRule.priority);
        writer.writeStringValue("sourceDirectoryName", synchronizationRule.sourceDirectoryName);
        writer.writeStringValue("targetDirectoryName", synchronizationRule.targetDirectoryName);
        writer.writeAdditionalData(synchronizationRule.additionalData);
}
export interface SynchronizationRule extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The containerFilter property
     */
    containerFilter?: ContainerFilter;
    /**
     * true if the synchronization rule can be customized; false if this rule is read-only and should not be changed.
     */
    editable?: boolean;
    /**
     * The groupFilter property
     */
    groupFilter?: GroupFilter;
    /**
     * Synchronization rule identifier. Must be one of the identifiers recognized by the synchronization engine. Supported rule identifiers can be found in the synchronization template returned by the API.
     */
    id?: string;
    /**
     * Additional extension properties. Unless instructed explicitly by the support team, metadata values should not be changed.
     */
    metadata?: StringKeyStringValuePair[];
    /**
     * Human-readable name of the synchronization rule. Not nullable.
     */
    name?: string;
    /**
     * Collection of object mappings supported by the rule. Tells the synchronization engine which objects should be synchronized.
     */
    objectMappings?: ObjectMapping[];
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Priority relative to other rules in the synchronizationSchema. Rules with the lowest priority number will be processed first.
     */
    priority?: number;
    /**
     * Name of the source directory. Must match one of the directory definitions in synchronizationSchema.
     */
    sourceDirectoryName?: string;
    /**
     * Name of the target directory. Must match one of the directory definitions in synchronizationSchema.
     */
    targetDirectoryName?: string;
}
