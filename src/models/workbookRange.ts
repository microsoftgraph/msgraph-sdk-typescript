// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { deserializeIntoEntity, serializeEntity, type Entity } from './entity';
import { createJsonFromDiscriminatorValue, serializeJson, type Json } from './json';
import { createWorkbookRangeFormatFromDiscriminatorValue, serializeWorkbookRangeFormat, type WorkbookRangeFormat } from './workbookRangeFormat';
import { createWorkbookRangeSortFromDiscriminatorValue, serializeWorkbookRangeSort, type WorkbookRangeSort } from './workbookRangeSort';
import { createWorkbookWorksheetFromDiscriminatorValue, serializeWorkbookWorksheet, type WorkbookWorksheet } from './workbookWorksheet';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createWorkbookRangeFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoWorkbookRange;
}
export function deserializeIntoWorkbookRange(workbookRange: WorkbookRange | undefined = {} as WorkbookRange) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(workbookRange),
        "address": n => { workbookRange.address = n.getStringValue(); },
        "addressLocal": n => { workbookRange.addressLocal = n.getStringValue(); },
        "cellCount": n => { workbookRange.cellCount = n.getNumberValue(); },
        "columnCount": n => { workbookRange.columnCount = n.getNumberValue(); },
        "columnHidden": n => { workbookRange.columnHidden = n.getBooleanValue(); },
        "columnIndex": n => { workbookRange.columnIndex = n.getNumberValue(); },
        "format": n => { workbookRange.format = n.getObjectValue<WorkbookRangeFormat>(createWorkbookRangeFormatFromDiscriminatorValue); },
        "formulas": n => { workbookRange.formulas = n.getObjectValue<Json>(createJsonFromDiscriminatorValue); },
        "formulasLocal": n => { workbookRange.formulasLocal = n.getObjectValue<Json>(createJsonFromDiscriminatorValue); },
        "formulasR1C1": n => { workbookRange.formulasR1C1 = n.getObjectValue<Json>(createJsonFromDiscriminatorValue); },
        "hidden": n => { workbookRange.hidden = n.getBooleanValue(); },
        "numberFormat": n => { workbookRange.numberFormat = n.getObjectValue<Json>(createJsonFromDiscriminatorValue); },
        "rowCount": n => { workbookRange.rowCount = n.getNumberValue(); },
        "rowHidden": n => { workbookRange.rowHidden = n.getBooleanValue(); },
        "rowIndex": n => { workbookRange.rowIndex = n.getNumberValue(); },
        "sort": n => { workbookRange.sort = n.getObjectValue<WorkbookRangeSort>(createWorkbookRangeSortFromDiscriminatorValue); },
        "text": n => { workbookRange.text = n.getObjectValue<Json>(createJsonFromDiscriminatorValue); },
        "values": n => { workbookRange.values = n.getObjectValue<Json>(createJsonFromDiscriminatorValue); },
        "valueTypes": n => { workbookRange.valueTypes = n.getObjectValue<Json>(createJsonFromDiscriminatorValue); },
        "worksheet": n => { workbookRange.worksheet = n.getObjectValue<WorkbookWorksheet>(createWorkbookWorksheetFromDiscriminatorValue); },
    }
}
export function serializeWorkbookRange(writer: SerializationWriter, workbookRange: WorkbookRange | undefined = {} as WorkbookRange) : void {
    serializeEntity(writer, workbookRange)
    writer.writeStringValue("address", workbookRange.address);
    writer.writeStringValue("addressLocal", workbookRange.addressLocal);
    writer.writeNumberValue("cellCount", workbookRange.cellCount);
    writer.writeNumberValue("columnCount", workbookRange.columnCount);
    writer.writeBooleanValue("columnHidden", workbookRange.columnHidden);
    writer.writeNumberValue("columnIndex", workbookRange.columnIndex);
    writer.writeObjectValue<WorkbookRangeFormat>("format", workbookRange.format, serializeWorkbookRangeFormat);
    writer.writeObjectValue<Json>("formulas", workbookRange.formulas, serializeJson);
    writer.writeObjectValue<Json>("formulasLocal", workbookRange.formulasLocal, serializeJson);
    writer.writeObjectValue<Json>("formulasR1C1", workbookRange.formulasR1C1, serializeJson);
    writer.writeBooleanValue("hidden", workbookRange.hidden);
    writer.writeObjectValue<Json>("numberFormat", workbookRange.numberFormat, serializeJson);
    writer.writeNumberValue("rowCount", workbookRange.rowCount);
    writer.writeBooleanValue("rowHidden", workbookRange.rowHidden);
    writer.writeNumberValue("rowIndex", workbookRange.rowIndex);
    writer.writeObjectValue<WorkbookRangeSort>("sort", workbookRange.sort, serializeWorkbookRangeSort);
    writer.writeObjectValue<Json>("text", workbookRange.text, serializeJson);
    writer.writeObjectValue<Json>("values", workbookRange.values, serializeJson);
    writer.writeObjectValue<Json>("valueTypes", workbookRange.valueTypes, serializeJson);
    writer.writeObjectValue<WorkbookWorksheet>("worksheet", workbookRange.worksheet, serializeWorkbookWorksheet);
}
export interface WorkbookRange extends Entity, Parsable {
    /**
     * Represents the range reference in A1-style. Address value contains the Sheet reference (for example, Sheet1!A1:B4). Read-only.
     */
    address?: string;
    /**
     * Represents range reference for the specified range in the language of the user. Read-only.
     */
    addressLocal?: string;
    /**
     * Number of cells in the range. Read-only.
     */
    cellCount?: number;
    /**
     * Represents the total number of columns in the range. Read-only.
     */
    columnCount?: number;
    /**
     * Represents if all columns of the current range are hidden.
     */
    columnHidden?: boolean;
    /**
     * Represents the column number of the first cell in the range. Zero-indexed. Read-only.
     */
    columnIndex?: number;
    /**
     * Returns a format object, encapsulating the range's font, fill, borders, alignment, and other properties. Read-only.
     */
    format?: WorkbookRangeFormat;
    /**
     * Represents the formula in A1-style notation.
     */
    formulas?: Json;
    /**
     * Represents the formula in A1-style notation, in the user's language and number-formatting locale.  For example, the English '=SUM(A1, 1.5)' formula would become '=SUMME(A1; 1,5)' in German.
     */
    formulasLocal?: Json;
    /**
     * Represents the formula in R1C1-style notation.
     */
    formulasR1C1?: Json;
    /**
     * Represents if all cells of the current range are hidden. Read-only.
     */
    hidden?: boolean;
    /**
     * Represents Excel's number format code for the given cell.
     */
    numberFormat?: Json;
    /**
     * Returns the total number of rows in the range. Read-only.
     */
    rowCount?: number;
    /**
     * Represents if all rows of the current range are hidden.
     */
    rowHidden?: boolean;
    /**
     * Returns the row number of the first cell in the range. Zero-indexed. Read-only.
     */
    rowIndex?: number;
    /**
     * The worksheet containing the current range. Read-only.
     */
    sort?: WorkbookRangeSort;
    /**
     * Text values of the specified range. The Text value doesn't depend on the cell width. The # sign substitution that happens in Excel UI doesn't affect the text value returned by the API. Read-only.
     */
    text?: Json;
    /**
     * Represents the raw values of the specified range. The data returned could be of type string, number, or a boolean. Cell that contains an error returns the error string.
     */
    values?: Json;
    /**
     * Represents the type of data of each cell. The possible values are: Unknown, Empty, String, Integer, Double, Boolean, Error. Read-only.
     */
    valueTypes?: Json;
    /**
     * The worksheet containing the current range. Read-only.
     */
    worksheet?: WorkbookWorksheet;
}
// tslint:enable
// eslint-enable
