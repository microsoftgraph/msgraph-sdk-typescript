// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { createDateTimeTimeZoneFromDiscriminatorValue, serializeDateTimeTimeZone, type DateTimeTimeZone } from './dateTimeTimeZone';
import { deserializeIntoEventMessage, serializeEventMessage, type EventMessage } from './eventMessage';
import { createLocationFromDiscriminatorValue, serializeLocation, type Location } from './location';
import { MeetingRequestType } from './meetingRequestType';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createEventMessageRequestFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoEventMessageRequest;
}
export function deserializeIntoEventMessageRequest(eventMessageRequest: EventMessageRequest | undefined = {} as EventMessageRequest) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessage(eventMessageRequest),
        "allowNewTimeProposals": n => { eventMessageRequest.allowNewTimeProposals = n.getBooleanValue(); },
        "meetingRequestType": n => { eventMessageRequest.meetingRequestType = n.getEnumValue<MeetingRequestType>(MeetingRequestType); },
        "previousEndDateTime": n => { eventMessageRequest.previousEndDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "previousLocation": n => { eventMessageRequest.previousLocation = n.getObjectValue<Location>(createLocationFromDiscriminatorValue); },
        "previousStartDateTime": n => { eventMessageRequest.previousStartDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "responseRequested": n => { eventMessageRequest.responseRequested = n.getBooleanValue(); },
    }
}
export interface EventMessageRequest extends EventMessage, Parsable {
    /**
     * True if the meeting organizer allows invitees to propose a new time when responding, false otherwise. Optional. Default is true.
     */
    allowNewTimeProposals?: boolean;
    /**
     * The meetingRequestType property
     */
    meetingRequestType?: MeetingRequestType;
    /**
     * If the meeting update changes the meeting end time, this property specifies the previous meeting end time.
     */
    previousEndDateTime?: DateTimeTimeZone;
    /**
     * If the meeting update changes the meeting location, this property specifies the previous meeting location.
     */
    previousLocation?: Location;
    /**
     * If the meeting update changes the meeting start time, this property specifies the previous meeting start time.
     */
    previousStartDateTime?: DateTimeTimeZone;
    /**
     * Set to true if the sender would like the invitee to send a response to the requested meeting.
     */
    responseRequested?: boolean;
}
export function serializeEventMessageRequest(writer: SerializationWriter, eventMessageRequest: EventMessageRequest | undefined = {} as EventMessageRequest) : void {
    serializeEventMessage(writer, eventMessageRequest)
    writer.writeBooleanValue("allowNewTimeProposals", eventMessageRequest.allowNewTimeProposals);
    writer.writeEnumValue<MeetingRequestType>("meetingRequestType", eventMessageRequest.meetingRequestType);
    writer.writeObjectValue<DateTimeTimeZone>("previousEndDateTime", eventMessageRequest.previousEndDateTime, serializeDateTimeTimeZone);
    writer.writeObjectValue<Location>("previousLocation", eventMessageRequest.previousLocation, serializeLocation);
    writer.writeObjectValue<DateTimeTimeZone>("previousStartDateTime", eventMessageRequest.previousStartDateTime, serializeDateTimeTimeZone);
    writer.writeBooleanValue("responseRequested", eventMessageRequest.responseRequested);
}
// tslint:enable
// eslint-enable
