import { deserializeIntoEntity, serializeEntity, type Entity } from './entity';
import { WindowsMalwareCategory } from './windowsMalwareCategory';
import { WindowsMalwareExecutionState } from './windowsMalwareExecutionState';
import { WindowsMalwareSeverity } from './windowsMalwareSeverity';
import { WindowsMalwareState } from './windowsMalwareState';
import { WindowsMalwareThreatState } from './windowsMalwareThreatState';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function createWindowsDeviceMalwareStateFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoWindowsDeviceMalwareState;
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function deserializeIntoWindowsDeviceMalwareState(windowsDeviceMalwareState: WindowsDeviceMalwareState | undefined = {} as WindowsDeviceMalwareState) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(windowsDeviceMalwareState),
        "additionalInformationUrl": n => { windowsDeviceMalwareState.additionalInformationUrl = n.getStringValue(); },
        "category": n => { windowsDeviceMalwareState.category = n.getEnumValue<WindowsMalwareCategory>(WindowsMalwareCategory); },
        "detectionCount": n => { windowsDeviceMalwareState.detectionCount = n.getNumberValue(); },
        "displayName": n => { windowsDeviceMalwareState.displayName = n.getStringValue(); },
        "executionState": n => { windowsDeviceMalwareState.executionState = n.getEnumValue<WindowsMalwareExecutionState>(WindowsMalwareExecutionState); },
        "initialDetectionDateTime": n => { windowsDeviceMalwareState.initialDetectionDateTime = n.getDateValue(); },
        "lastStateChangeDateTime": n => { windowsDeviceMalwareState.lastStateChangeDateTime = n.getDateValue(); },
        "severity": n => { windowsDeviceMalwareState.severity = n.getEnumValue<WindowsMalwareSeverity>(WindowsMalwareSeverity); },
        "state": n => { windowsDeviceMalwareState.state = n.getEnumValue<WindowsMalwareState>(WindowsMalwareState); },
        "threatState": n => { windowsDeviceMalwareState.threatState = n.getEnumValue<WindowsMalwareThreatState>(WindowsMalwareThreatState); },
    }
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function serializeWindowsDeviceMalwareState(writer: SerializationWriter, windowsDeviceMalwareState: WindowsDeviceMalwareState | undefined = {} as WindowsDeviceMalwareState) : void {
        serializeEntity(writer, windowsDeviceMalwareState)
        writer.writeStringValue("additionalInformationUrl", windowsDeviceMalwareState.additionalInformationUrl);
        writer.writeEnumValue<WindowsMalwareCategory>("category", windowsDeviceMalwareState.category);
        writer.writeNumberValue("detectionCount", windowsDeviceMalwareState.detectionCount);
        writer.writeStringValue("displayName", windowsDeviceMalwareState.displayName);
        writer.writeEnumValue<WindowsMalwareExecutionState>("executionState", windowsDeviceMalwareState.executionState);
        writer.writeDateValue("initialDetectionDateTime", windowsDeviceMalwareState.initialDetectionDateTime);
        writer.writeDateValue("lastStateChangeDateTime", windowsDeviceMalwareState.lastStateChangeDateTime);
        writer.writeEnumValue<WindowsMalwareSeverity>("severity", windowsDeviceMalwareState.severity);
        writer.writeEnumValue<WindowsMalwareState>("state", windowsDeviceMalwareState.state);
        writer.writeEnumValue<WindowsMalwareThreatState>("threatState", windowsDeviceMalwareState.threatState);
}
export interface WindowsDeviceMalwareState extends Entity, Parsable {
    /**
     * Information URL to learn more about the malware
     */
    additionalInformationUrl?: string;
    /**
     * Category of the malware. Possible values are: invalid, adware, spyware, passwordStealer, trojanDownloader, worm, backdoor, remoteAccessTrojan, trojan, emailFlooder, keylogger, dialer, monitoringSoftware, browserModifier, cookie, browserPlugin, aolExploit, nuker, securityDisabler, jokeProgram, hostileActiveXControl, softwareBundler, stealthNotifier, settingsModifier, toolBar, remoteControlSoftware, trojanFtp, potentialUnwantedSoftware, icqExploit, trojanTelnet, exploit, filesharingProgram, malwareCreationTool, remoteControlSoftware, tool, trojanDenialOfService, trojanDropper, trojanMassMailer, trojanMonitoringSoftware, trojanProxyServer, virus, known, unknown, spp, behavior, vulnerability, policy, enterpriseUnwantedSoftware, ransom, hipsRule.
     */
    category?: WindowsMalwareCategory;
    /**
     * Number of times the malware is detected
     */
    detectionCount?: number;
    /**
     * Malware name
     */
    displayName?: string;
    /**
     * Execution status of the malware like blocked/executing etc. Possible values are: unknown, blocked, allowed, running, notRunning.
     */
    executionState?: WindowsMalwareExecutionState;
    /**
     * Initial detection datetime of the malware
     */
    initialDetectionDateTime?: Date;
    /**
     * The last time this particular threat was changed
     */
    lastStateChangeDateTime?: Date;
    /**
     * Severity of the malware. Possible values are: unknown, low, moderate, high, severe.
     */
    severity?: WindowsMalwareSeverity;
    /**
     * Current status of the malware like cleaned/quarantined/allowed etc. Possible values are: unknown, detected, cleaned, quarantined, removed, allowed, blocked, cleanFailed, quarantineFailed, removeFailed, allowFailed, abandoned, blockFailed.
     */
    state?: WindowsMalwareState;
    /**
     * Current status of the malware like cleaned/quarantined/allowed etc. Possible values are: active, actionFailed, manualStepsRequired, fullScanRequired, rebootRequired, remediatedWithNonCriticalFailures, quarantined, removed, cleaned, allowed, noStatusCleared.
     */
    threatState?: WindowsMalwareThreatState;
}
