import { deserializeIntoEntity, serializeEntity, type Entity } from './entity';
import { createWorkbookApplicationFromDiscriminatorValue, serializeWorkbookApplication, type WorkbookApplication } from './workbookApplication';
import { createWorkbookCommentFromDiscriminatorValue, serializeWorkbookComment, type WorkbookComment } from './workbookComment';
import { createWorkbookFunctionsFromDiscriminatorValue, serializeWorkbookFunctions, type WorkbookFunctions } from './workbookFunctions';
import { createWorkbookNamedItemFromDiscriminatorValue, serializeWorkbookNamedItem, type WorkbookNamedItem } from './workbookNamedItem';
import { createWorkbookOperationFromDiscriminatorValue, serializeWorkbookOperation, type WorkbookOperation } from './workbookOperation';
import { createWorkbookTableFromDiscriminatorValue, serializeWorkbookTable, type WorkbookTable } from './workbookTable';
import { createWorkbookWorksheetFromDiscriminatorValue, serializeWorkbookWorksheet, type WorkbookWorksheet } from './workbookWorksheet';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function createWorkbookFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoWorkbook;
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function deserializeIntoWorkbook(workbook: Workbook | undefined = {} as Workbook) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(workbook),
        "application": n => { workbook.application = n.getObjectValue<WorkbookApplication>(createWorkbookApplicationFromDiscriminatorValue); },
        "comments": n => { workbook.comments = n.getCollectionOfObjectValues<WorkbookComment>(createWorkbookCommentFromDiscriminatorValue); },
        "functions": n => { workbook.functions = n.getObjectValue<WorkbookFunctions>(createWorkbookFunctionsFromDiscriminatorValue); },
        "names": n => { workbook.names = n.getCollectionOfObjectValues<WorkbookNamedItem>(createWorkbookNamedItemFromDiscriminatorValue); },
        "operations": n => { workbook.operations = n.getCollectionOfObjectValues<WorkbookOperation>(createWorkbookOperationFromDiscriminatorValue); },
        "tables": n => { workbook.tables = n.getCollectionOfObjectValues<WorkbookTable>(createWorkbookTableFromDiscriminatorValue); },
        "worksheets": n => { workbook.worksheets = n.getCollectionOfObjectValues<WorkbookWorksheet>(createWorkbookWorksheetFromDiscriminatorValue); },
    }
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function serializeWorkbook(writer: SerializationWriter, workbook: Workbook | undefined = {} as Workbook) : void {
        serializeEntity(writer, workbook)
        writer.writeObjectValue<WorkbookApplication>("application", workbook.application, );
        writer.writeCollectionOfObjectValues<WorkbookComment>("comments", workbook.comments, );
        writer.writeObjectValue<WorkbookFunctions>("functions", workbook.functions, );
        writer.writeCollectionOfObjectValues<WorkbookNamedItem>("names", workbook.names, );
        writer.writeCollectionOfObjectValues<WorkbookOperation>("operations", workbook.operations, );
        writer.writeCollectionOfObjectValues<WorkbookTable>("tables", workbook.tables, );
        writer.writeCollectionOfObjectValues<WorkbookWorksheet>("worksheets", workbook.worksheets, );
}
export interface Workbook extends Entity, Parsable {
    /**
     * The application property
     */
    application?: WorkbookApplication;
    /**
     * Represents a collection of comments in a workbook.
     */
    comments?: WorkbookComment[];
    /**
     * The functions property
     */
    functions?: WorkbookFunctions;
    /**
     * Represents a collection of workbooks scoped named items (named ranges and constants). Read-only.
     */
    names?: WorkbookNamedItem[];
    /**
     * The status of workbook operations. Getting an operation collection is not supported, but you can get the status of a long-running operation if the Location header is returned in the response. Read-only.
     */
    operations?: WorkbookOperation[];
    /**
     * Represents a collection of tables associated with the workbook. Read-only.
     */
    tables?: WorkbookTable[];
    /**
     * Represents a collection of worksheets associated with the workbook. Read-only.
     */
    worksheets?: WorkbookWorksheet[];
}
