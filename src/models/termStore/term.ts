// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { deserializeIntoEntity, serializeEntity, type Entity } from '../entity';
import { createKeyValueFromDiscriminatorValue, serializeKeyValue, type KeyValue } from '../keyValue';
import { createLocalizedDescriptionFromDiscriminatorValue, serializeLocalizedDescription, type LocalizedDescription } from './localizedDescription';
import { createLocalizedLabelFromDiscriminatorValue, serializeLocalizedLabel, type LocalizedLabel } from './localizedLabel';
import { createRelationFromDiscriminatorValue, serializeRelation, type Relation } from './relation';
import { createSetFromDiscriminatorValue, serializeSet, type Set } from './set';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createTermFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoTerm;
}
export function deserializeIntoTerm(term: Term | undefined = {} as Term) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(term),
        "children": n => { term.children = n.getCollectionOfObjectValues<Term>(createTermFromDiscriminatorValue); },
        "createdDateTime": n => { term.createdDateTime = n.getDateValue(); },
        "descriptions": n => { term.descriptions = n.getCollectionOfObjectValues<LocalizedDescription>(createLocalizedDescriptionFromDiscriminatorValue); },
        "labels": n => { term.labels = n.getCollectionOfObjectValues<LocalizedLabel>(createLocalizedLabelFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { term.lastModifiedDateTime = n.getDateValue(); },
        "properties": n => { term.properties = n.getCollectionOfObjectValues<KeyValue>(createKeyValueFromDiscriminatorValue); },
        "relations": n => { term.relations = n.getCollectionOfObjectValues<Relation>(createRelationFromDiscriminatorValue); },
        "set": n => { term.set = n.getObjectValue<Set>(createSetFromDiscriminatorValue); },
    }
}
export function serializeTerm(writer: SerializationWriter, term: Term | undefined = {} as Term) : void {
        serializeEntity(writer, term)
        writer.writeCollectionOfObjectValues<Term>("children", term.children, );
        writer.writeDateValue("createdDateTime", term.createdDateTime);
        writer.writeCollectionOfObjectValues<LocalizedDescription>("descriptions", term.descriptions, );
        writer.writeCollectionOfObjectValues<LocalizedLabel>("labels", term.labels, );
        writer.writeDateValue("lastModifiedDateTime", term.lastModifiedDateTime);
        writer.writeCollectionOfObjectValues<KeyValue>("properties", term.properties, );
        writer.writeCollectionOfObjectValues<Relation>("relations", term.relations, );
        writer.writeObjectValue<Set>("set", term.set, );
}
export interface Term extends Entity, Parsable {
    /**
     * Children of current term.
     */
    children?: Term[];
    /**
     * Date and time of term creation. Read-only.
     */
    createdDateTime?: Date;
    /**
     * Description about term that is dependent on the languageTag.
     */
    descriptions?: LocalizedDescription[];
    /**
     * Label metadata for a term.
     */
    labels?: LocalizedLabel[];
    /**
     * Last date and time of term modification. Read-only.
     */
    lastModifiedDateTime?: Date;
    /**
     * Collection of properties on the term.
     */
    properties?: KeyValue[];
    /**
     * To indicate which terms are related to the current term as either pinned or reused.
     */
    relations?: Relation[];
    /**
     * The [set] in which the term is created.
     */
    set?: Set;
}
// tslint:enable
// eslint-enable
