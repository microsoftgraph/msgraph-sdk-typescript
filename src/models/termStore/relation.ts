// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { deserializeIntoEntity, serializeEntity, type Entity } from '../entity';
import { RelationType } from './relationType';
import { createSetFromDiscriminatorValue, serializeSet, type Set } from './set';
import { createTermFromDiscriminatorValue, serializeTerm, type Term } from './term';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createRelationFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoRelation;
}
export function deserializeIntoRelation(relation: Relation | undefined = {} as Relation) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(relation),
        "fromTerm": n => { relation.fromTerm = n.getObjectValue<Term>(createTermFromDiscriminatorValue); },
        "relationship": n => { relation.relationship = n.getEnumValue<RelationType>(RelationType); },
        "set": n => { relation.set = n.getObjectValue<Set>(createSetFromDiscriminatorValue); },
        "toTerm": n => { relation.toTerm = n.getObjectValue<Term>(createTermFromDiscriminatorValue); },
    }
}
export interface Relation extends Entity, Parsable {
    /**
     * The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].
     */
    fromTerm?: Term;
    /**
     * The type of relation. Possible values are: pin, reuse.
     */
    relationship?: RelationType;
    /**
     * The [set] in which the relation is relevant.
     */
    set?: Set;
    /**
     * The to [term] of the relation. The term to which the relationship is defined.
     */
    toTerm?: Term;
}
export function serializeRelation(writer: SerializationWriter, relation: Relation | undefined = {} as Relation) : void {
    serializeEntity(writer, relation)
    writer.writeObjectValue<Term>("fromTerm", relation.fromTerm, serializeTerm);
    writer.writeEnumValue<RelationType>("relationship", relation.relationship);
    writer.writeObjectValue<Set>("set", relation.set, serializeSet);
    writer.writeObjectValue<Term>("toTerm", relation.toTerm, serializeTerm);
}
// tslint:enable
// eslint-enable
