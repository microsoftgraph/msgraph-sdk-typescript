// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { AttributeFlowBehavior } from './attributeFlowBehavior';
import { AttributeFlowType } from './attributeFlowType';
import { createAttributeMappingSourceFromDiscriminatorValue, serializeAttributeMappingSource, type AttributeMappingSource } from './attributeMappingSource';
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface AttributeMapping extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Default value to be used in case the source property was evaluated to null. Optional.
     */
    defaultValue?: string;
    /**
     * For internal use only.
     */
    exportMissingReferences?: boolean;
    /**
     * The flowBehavior property
     */
    flowBehavior?: AttributeFlowBehavior;
    /**
     * The flowType property
     */
    flowType?: AttributeFlowType;
    /**
     * If higher than 0, this attribute will be used to perform an initial match of the objects between source and target directories. The synchronization engine will try to find the matching object using attribute with lowest value of matching priority first. If not found, the attribute with the next matching priority will be used, and so on a until match is found or no more matching attributes are left. Only attributes that are expected to have unique values, such as email, should be used as matching attributes.
     */
    matchingPriority?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Defines how a value should be extracted (or transformed) from the source object.
     */
    source?: AttributeMappingSource;
    /**
     * Name of the attribute on the target object.
     */
    targetAttributeName?: string;
}
export function createAttributeMappingFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoAttributeMapping;
}
export function deserializeIntoAttributeMapping(attributeMapping: AttributeMapping | undefined = {} as AttributeMapping) : Record<string, (node: ParseNode) => void> {
    return {
        "defaultValue": n => { attributeMapping.defaultValue = n.getStringValue(); },
        "exportMissingReferences": n => { attributeMapping.exportMissingReferences = n.getBooleanValue(); },
        "flowBehavior": n => { attributeMapping.flowBehavior = n.getEnumValue<AttributeFlowBehavior>(AttributeFlowBehavior); },
        "flowType": n => { attributeMapping.flowType = n.getEnumValue<AttributeFlowType>(AttributeFlowType); },
        "matchingPriority": n => { attributeMapping.matchingPriority = n.getNumberValue(); },
        "@odata.type": n => { attributeMapping.odataType = n.getStringValue(); },
        "source": n => { attributeMapping.source = n.getObjectValue<AttributeMappingSource>(createAttributeMappingSourceFromDiscriminatorValue); },
        "targetAttributeName": n => { attributeMapping.targetAttributeName = n.getStringValue(); },
    }
}
export function serializeAttributeMapping(writer: SerializationWriter, attributeMapping: AttributeMapping | undefined = {} as AttributeMapping) : void {
        writer.writeStringValue("defaultValue", attributeMapping.defaultValue);
        writer.writeBooleanValue("exportMissingReferences", attributeMapping.exportMissingReferences);
        writer.writeEnumValue<AttributeFlowBehavior>("flowBehavior", attributeMapping.flowBehavior);
        writer.writeEnumValue<AttributeFlowType>("flowType", attributeMapping.flowType);
        writer.writeNumberValue("matchingPriority", attributeMapping.matchingPriority);
        writer.writeStringValue("@odata.type", attributeMapping.odataType);
        writer.writeObjectValue<AttributeMappingSource>("source", attributeMapping.source, serializeAttributeMappingSource);
        writer.writeStringValue("targetAttributeName", attributeMapping.targetAttributeName);
        writer.writeAdditionalData(attributeMapping.additionalData);
}
// tslint:enable
// eslint-enable
