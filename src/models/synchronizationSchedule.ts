import { SynchronizationScheduleState } from './synchronizationScheduleState';
import { Duration, type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function createSynchronizationScheduleFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoSynchronizationSchedule;
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function deserializeIntoSynchronizationSchedule(synchronizationSchedule: SynchronizationSchedule | undefined = {} as SynchronizationSchedule) : Record<string, (node: ParseNode) => void> {
    return {
        "expiration": n => { synchronizationSchedule.expiration = n.getDateValue(); },
        "interval": n => { synchronizationSchedule.interval = n.getDurationValue(); },
        "@odata.type": n => { synchronizationSchedule.odataType = n.getStringValue(); },
        "state": n => { synchronizationSchedule.state = n.getEnumValue<SynchronizationScheduleState>(SynchronizationScheduleState); },
    }
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function serializeSynchronizationSchedule(writer: SerializationWriter, synchronizationSchedule: SynchronizationSchedule | undefined = {} as SynchronizationSchedule) : void {
        writer.writeDateValue("expiration", synchronizationSchedule.expiration);
        writer.writeDurationValue("interval", synchronizationSchedule.interval);
        writer.writeStringValue("@odata.type", synchronizationSchedule.odataType);
        writer.writeEnumValue<SynchronizationScheduleState>("state", synchronizationSchedule.state);
        writer.writeAdditionalData(synchronizationSchedule.additionalData);
}
export interface SynchronizationSchedule extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Date and time when this job expires. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    expiration?: Date;
    /**
     * The interval between synchronization iterations. The value is represented in ISO 8601 format for durations. For example, PT1M represents a period of one month.
     */
    interval?: Duration;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The state property
     */
    state?: SynchronizationScheduleState;
}
