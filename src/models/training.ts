// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { createEmailIdentityFromDiscriminatorValue, serializeEmailIdentity, type EmailIdentity } from './emailIdentity';
import { deserializeIntoEntity, serializeEntity, type Entity } from './entity';
import { SimulationContentSource } from './simulationContentSource';
import { TrainingAvailabilityStatus } from './trainingAvailabilityStatus';
import { createTrainingLanguageDetailFromDiscriminatorValue, serializeTrainingLanguageDetail, type TrainingLanguageDetail } from './trainingLanguageDetail';
import { TrainingType } from './trainingType';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createTrainingFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoTraining;
}
export function deserializeIntoTraining(training: Training | undefined = {} as Training) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(training),
        "availabilityStatus": n => { training.availabilityStatus = n.getEnumValue<TrainingAvailabilityStatus>(TrainingAvailabilityStatus); },
        "createdBy": n => { training.createdBy = n.getObjectValue<EmailIdentity>(createEmailIdentityFromDiscriminatorValue); },
        "createdDateTime": n => { training.createdDateTime = n.getDateValue(); },
        "description": n => { training.description = n.getStringValue(); },
        "displayName": n => { training.displayName = n.getStringValue(); },
        "durationInMinutes": n => { training.durationInMinutes = n.getNumberValue(); },
        "hasEvaluation": n => { training.hasEvaluation = n.getBooleanValue(); },
        "languageDetails": n => { training.languageDetails = n.getCollectionOfObjectValues<TrainingLanguageDetail>(createTrainingLanguageDetailFromDiscriminatorValue); },
        "lastModifiedBy": n => { training.lastModifiedBy = n.getObjectValue<EmailIdentity>(createEmailIdentityFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { training.lastModifiedDateTime = n.getDateValue(); },
        "source": n => { training.source = n.getEnumValue<SimulationContentSource>(SimulationContentSource); },
        "supportedLocales": n => { training.supportedLocales = n.getCollectionOfPrimitiveValues<string>(); },
        "tags": n => { training.tags = n.getCollectionOfPrimitiveValues<string>(); },
        "type": n => { training.type = n.getEnumValue<TrainingType>(TrainingType); },
    }
}
export function serializeTraining(writer: SerializationWriter, training: Training | undefined = {} as Training) : void {
        serializeEntity(writer, training)
        writer.writeEnumValue<TrainingAvailabilityStatus>("availabilityStatus", training.availabilityStatus);
        writer.writeObjectValue<EmailIdentity>("createdBy", training.createdBy, serializeEmailIdentity);
        writer.writeDateValue("createdDateTime", training.createdDateTime);
        writer.writeStringValue("description", training.description);
        writer.writeStringValue("displayName", training.displayName);
        writer.writeNumberValue("durationInMinutes", training.durationInMinutes);
        writer.writeBooleanValue("hasEvaluation", training.hasEvaluation);
        writer.writeCollectionOfObjectValues<TrainingLanguageDetail>("languageDetails", training.languageDetails, serializeTrainingLanguageDetail);
        writer.writeObjectValue<EmailIdentity>("lastModifiedBy", training.lastModifiedBy, serializeEmailIdentity);
        writer.writeDateValue("lastModifiedDateTime", training.lastModifiedDateTime);
        writer.writeEnumValue<SimulationContentSource>("source", training.source);
        writer.writeCollectionOfPrimitiveValues<string>("supportedLocales", training.supportedLocales);
        writer.writeCollectionOfPrimitiveValues<string>("tags", training.tags);
        writer.writeEnumValue<TrainingType>("type", training.type);
}
export interface Training extends Entity, Parsable {
    /**
     * Training availability status. Possible values are: unknown, notAvailable, available, archive, delete, unknownFutureValue.
     */
    availabilityStatus?: TrainingAvailabilityStatus;
    /**
     * Identity of the user who created the training.
     */
    createdBy?: EmailIdentity;
    /**
     * Date and time when the training was created. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    createdDateTime?: Date;
    /**
     * The description for the training.
     */
    description?: string;
    /**
     * The display name for the training.
     */
    displayName?: string;
    /**
     * Training duration.
     */
    durationInMinutes?: number;
    /**
     * Indicates whether the training has any evaluation.
     */
    hasEvaluation?: boolean;
    /**
     * Language specific details on a training.
     */
    languageDetails?: TrainingLanguageDetail[];
    /**
     * Identity of the user who last modified the training.
     */
    lastModifiedBy?: EmailIdentity;
    /**
     * Date and time when the training was last modified. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastModifiedDateTime?: Date;
    /**
     * Training content source. Possible values are: unknown, global, tenant, unknownFutureValue.
     */
    source?: SimulationContentSource;
    /**
     * Supported locales for content for the associated training.
     */
    supportedLocales?: string[];
    /**
     * Training tags.
     */
    tags?: string[];
    /**
     * The type of training. Possible values are: unknown, phishing, unknownFutureValue.
     */
    type?: TrainingType;
}
// tslint:enable
// eslint-enable
