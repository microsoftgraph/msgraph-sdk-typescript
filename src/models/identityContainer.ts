import { createB2xIdentityUserFlowFromDiscriminatorValue, serializeB2xIdentityUserFlow, type B2xIdentityUserFlow } from './b2xIdentityUserFlow';
import { createConditionalAccessRootFromDiscriminatorValue, serializeConditionalAccessRoot, type ConditionalAccessRoot } from './conditionalAccessRoot';
import { deserializeIntoEntity, serializeEntity, type Entity } from './entity';
import { createIdentityApiConnectorFromDiscriminatorValue, serializeIdentityApiConnector, type IdentityApiConnector } from './identityApiConnector';
import { createIdentityProviderBaseFromDiscriminatorValue, serializeIdentityProviderBase, type IdentityProviderBase } from './identityProviderBase';
import { createIdentityUserFlowAttributeFromDiscriminatorValue, serializeIdentityUserFlowAttribute, type IdentityUserFlowAttribute } from './identityUserFlowAttribute';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function createIdentityContainerFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoIdentityContainer;
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function deserializeIntoIdentityContainer(identityContainer: IdentityContainer | undefined = {} as IdentityContainer) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(identityContainer),
        "apiConnectors": n => { identityContainer.apiConnectors = n.getCollectionOfObjectValues<IdentityApiConnector>(createIdentityApiConnectorFromDiscriminatorValue); },
        "b2xUserFlows": n => { identityContainer.b2xUserFlows = n.getCollectionOfObjectValues<B2xIdentityUserFlow>(createB2xIdentityUserFlowFromDiscriminatorValue); },
        "conditionalAccess": n => { identityContainer.conditionalAccess = n.getObjectValue<ConditionalAccessRoot>(createConditionalAccessRootFromDiscriminatorValue); },
        "identityProviders": n => { identityContainer.identityProviders = n.getCollectionOfObjectValues<IdentityProviderBase>(createIdentityProviderBaseFromDiscriminatorValue); },
        "userFlowAttributes": n => { identityContainer.userFlowAttributes = n.getCollectionOfObjectValues<IdentityUserFlowAttribute>(createIdentityUserFlowAttributeFromDiscriminatorValue); },
    }
}
export interface IdentityContainer extends Entity, Parsable {
    /**
     * Represents entry point for API connectors.
     */
    apiConnectors?: IdentityApiConnector[];
    /**
     * Represents entry point for B2X/self-service sign-up identity userflows.
     */
    b2xUserFlows?: B2xIdentityUserFlow[];
    /**
     * the entry point for the Conditional Access (CA) object model.
     */
    conditionalAccess?: ConditionalAccessRoot;
    /**
     * The identityProviders property
     */
    identityProviders?: IdentityProviderBase[];
    /**
     * Represents entry point for identity userflow attributes.
     */
    userFlowAttributes?: IdentityUserFlowAttribute[];
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function serializeIdentityContainer(writer: SerializationWriter, identityContainer: IdentityContainer | undefined = {} as IdentityContainer) : void {
        serializeEntity(writer, identityContainer)
        writer.writeCollectionOfObjectValues<IdentityApiConnector>("apiConnectors", identityContainer.apiConnectors, );
        writer.writeCollectionOfObjectValues<B2xIdentityUserFlow>("b2xUserFlows", identityContainer.b2xUserFlows, );
        writer.writeObjectValue<ConditionalAccessRoot>("conditionalAccess", identityContainer.conditionalAccess, );
        writer.writeCollectionOfObjectValues<IdentityProviderBase>("identityProviders", identityContainer.identityProviders, );
        writer.writeCollectionOfObjectValues<IdentityUserFlowAttribute>("userFlowAttributes", identityContainer.userFlowAttributes, );
}
