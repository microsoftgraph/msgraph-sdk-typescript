// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { createAccessPackageAssignmentPolicyFromDiscriminatorValue, serializeAccessPackageAssignmentPolicy, type AccessPackageAssignmentPolicy } from './accessPackageAssignmentPolicy';
import { createAccessPackageCatalogFromDiscriminatorValue, serializeAccessPackageCatalog, type AccessPackageCatalog } from './accessPackageCatalog';
import { createAccessPackageResourceRoleScopeFromDiscriminatorValue, serializeAccessPackageResourceRoleScope, type AccessPackageResourceRoleScope } from './accessPackageResourceRoleScope';
import { deserializeIntoEntity, serializeEntity, type Entity } from './entity';
import { createGroupFromDiscriminatorValue, serializeGroup, type Group } from './group';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface AccessPackage extends Entity, Parsable {
    /**
     * The access packages that are incompatible with this package. Read-only.
     */
    accessPackagesIncompatibleWith?: AccessPackage[];
    /**
     * Read-only. Nullable. Supports $expand.
     */
    assignmentPolicies?: AccessPackageAssignmentPolicy[];
    /**
     * Required when creating the access package. Read-only. Nullable.
     */
    catalog?: AccessPackageCatalog;
    /**
     * The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    createdDateTime?: Date;
    /**
     * The description of the access package.
     */
    description?: string;
    /**
     * Required. The display name of the access package. Supports $filter (eq, contains).
     */
    displayName?: string;
    /**
     * The access packages whose assigned users are ineligible to be assigned this access package.
     */
    incompatibleAccessPackages?: AccessPackage[];
    /**
     * The groups whose members are ineligible to be assigned this access package.
     */
    incompatibleGroups?: Group[];
    /**
     * Whether the access package is hidden from the requestor.
     */
    isHidden?: boolean;
    /**
     * The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. Read-only.
     */
    modifiedDateTime?: Date;
    /**
     * The resource roles and scopes in this access package.
     */
    resourceRoleScopes?: AccessPackageResourceRoleScope[];
}
export function createAccessPackageFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoAccessPackage;
}
export function deserializeIntoAccessPackage(accessPackage: AccessPackage | undefined = {} as AccessPackage) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(accessPackage),
        "accessPackagesIncompatibleWith": n => { accessPackage.accessPackagesIncompatibleWith = n.getCollectionOfObjectValues<AccessPackage>(createAccessPackageFromDiscriminatorValue); },
        "assignmentPolicies": n => { accessPackage.assignmentPolicies = n.getCollectionOfObjectValues<AccessPackageAssignmentPolicy>(createAccessPackageAssignmentPolicyFromDiscriminatorValue); },
        "catalog": n => { accessPackage.catalog = n.getObjectValue<AccessPackageCatalog>(createAccessPackageCatalogFromDiscriminatorValue); },
        "createdDateTime": n => { accessPackage.createdDateTime = n.getDateValue(); },
        "description": n => { accessPackage.description = n.getStringValue(); },
        "displayName": n => { accessPackage.displayName = n.getStringValue(); },
        "incompatibleAccessPackages": n => { accessPackage.incompatibleAccessPackages = n.getCollectionOfObjectValues<AccessPackage>(createAccessPackageFromDiscriminatorValue); },
        "incompatibleGroups": n => { accessPackage.incompatibleGroups = n.getCollectionOfObjectValues<Group>(createGroupFromDiscriminatorValue); },
        "isHidden": n => { accessPackage.isHidden = n.getBooleanValue(); },
        "modifiedDateTime": n => { accessPackage.modifiedDateTime = n.getDateValue(); },
        "resourceRoleScopes": n => { accessPackage.resourceRoleScopes = n.getCollectionOfObjectValues<AccessPackageResourceRoleScope>(createAccessPackageResourceRoleScopeFromDiscriminatorValue); },
    }
}
export function serializeAccessPackage(writer: SerializationWriter, accessPackage: AccessPackage | undefined = {} as AccessPackage) : void {
        serializeEntity(writer, accessPackage)
        writer.writeCollectionOfObjectValues<AccessPackage>("accessPackagesIncompatibleWith", accessPackage.accessPackagesIncompatibleWith, serializeAccessPackage);
        writer.writeCollectionOfObjectValues<AccessPackageAssignmentPolicy>("assignmentPolicies", accessPackage.assignmentPolicies, serializeAccessPackageAssignmentPolicy);
        writer.writeObjectValue<AccessPackageCatalog>("catalog", accessPackage.catalog, serializeAccessPackageCatalog);
        writer.writeDateValue("createdDateTime", accessPackage.createdDateTime);
        writer.writeStringValue("description", accessPackage.description);
        writer.writeStringValue("displayName", accessPackage.displayName);
        writer.writeCollectionOfObjectValues<AccessPackage>("incompatibleAccessPackages", accessPackage.incompatibleAccessPackages, serializeAccessPackage);
        writer.writeCollectionOfObjectValues<Group>("incompatibleGroups", accessPackage.incompatibleGroups, serializeGroup);
        writer.writeBooleanValue("isHidden", accessPackage.isHidden);
        writer.writeDateValue("modifiedDateTime", accessPackage.modifiedDateTime);
        writer.writeCollectionOfObjectValues<AccessPackageResourceRoleScope>("resourceRoleScopes", accessPackage.resourceRoleScopes, serializeAccessPackageResourceRoleScope);
}
// tslint:enable
// eslint-enable
