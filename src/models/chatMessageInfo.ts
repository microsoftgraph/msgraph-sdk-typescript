import { createChatMessageFromIdentitySetFromDiscriminatorValue, serializeChatMessageFromIdentitySet, type ChatMessageFromIdentitySet } from './chatMessageFromIdentitySet';
import { ChatMessageType } from './chatMessageType';
import { deserializeIntoEntity, serializeEntity, type Entity } from './entity';
import { createEventMessageDetailFromDiscriminatorValue, serializeEventMessageDetail, type EventMessageDetail } from './eventMessageDetail';
import { createItemBodyFromDiscriminatorValue, serializeItemBody, type ItemBody } from './itemBody';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface ChatMessageInfo extends Entity, Parsable {
    /**
     * Body of the chatMessage. This will still contain markers for @mentions and attachments even though the object doesn't return @mentions and attachments.
     */
    body?: ItemBody;
    /**
     * Date time object representing the time at which message was created.
     */
    createdDateTime?: Date;
    /**
     * Read-only.  If present, represents details of an event that happened in a chat, a channel, or a team, for example, members were added, and so on. For event messages, the messageType property is set to systemEventMessage.
     */
    eventDetail?: EventMessageDetail;
    /**
     * Information about the sender of the message.
     */
    from?: ChatMessageFromIdentitySet;
    /**
     * If set to true, the original message has been deleted.
     */
    isDeleted?: boolean;
    /**
     * The messageType property
     */
    messageType?: ChatMessageType;
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function createChatMessageInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoChatMessageInfo;
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function deserializeIntoChatMessageInfo(chatMessageInfo: ChatMessageInfo | undefined = {} as ChatMessageInfo) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(chatMessageInfo),
        "body": n => { chatMessageInfo.body = n.getObjectValue<ItemBody>(createItemBodyFromDiscriminatorValue); },
        "createdDateTime": n => { chatMessageInfo.createdDateTime = n.getDateValue(); },
        "eventDetail": n => { chatMessageInfo.eventDetail = n.getObjectValue<EventMessageDetail>(createEventMessageDetailFromDiscriminatorValue); },
        "from": n => { chatMessageInfo.from = n.getObjectValue<ChatMessageFromIdentitySet>(createChatMessageFromIdentitySetFromDiscriminatorValue); },
        "isDeleted": n => { chatMessageInfo.isDeleted = n.getBooleanValue(); },
        "messageType": n => { chatMessageInfo.messageType = n.getEnumValue<ChatMessageType>(ChatMessageType); },
    }
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function serializeChatMessageInfo(writer: SerializationWriter, chatMessageInfo: ChatMessageInfo | undefined = {} as ChatMessageInfo) : void {
        serializeEntity(writer, chatMessageInfo)
        writer.writeObjectValue<ItemBody>("body", chatMessageInfo.body, );
        writer.writeDateValue("createdDateTime", chatMessageInfo.createdDateTime);
        writer.writeObjectValue<EventMessageDetail>("eventDetail", chatMessageInfo.eventDetail, );
        writer.writeObjectValue<ChatMessageFromIdentitySet>("from", chatMessageInfo.from, );
        writer.writeBooleanValue("isDeleted", chatMessageInfo.isDeleted);
        writer.writeEnumValue<ChatMessageType>("messageType", chatMessageInfo.messageType);
}
