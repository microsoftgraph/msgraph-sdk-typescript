// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { createAccountTargetContentFromDiscriminatorValue, serializeAccountTargetContent, type AccountTargetContent } from './accountTargetContent';
import { createEmailIdentityFromDiscriminatorValue, serializeEmailIdentity, type EmailIdentity } from './emailIdentity';
import { createEndUserNotificationSettingFromDiscriminatorValue, serializeEndUserNotificationSetting, type EndUserNotificationSetting } from './endUserNotificationSetting';
import { deserializeIntoEntity, serializeEntity, type Entity } from './entity';
import { createLandingPageFromDiscriminatorValue, serializeLandingPage, type LandingPage } from './landingPage';
import { createLoginPageFromDiscriminatorValue, serializeLoginPage, type LoginPage } from './loginPage';
import { createOAuthConsentAppDetailFromDiscriminatorValue, serializeOAuthConsentAppDetail, type OAuthConsentAppDetail } from './oAuthConsentAppDetail';
import { createPayloadFromDiscriminatorValue, serializePayload, type Payload } from './payload';
import { PayloadDeliveryPlatform } from './payloadDeliveryPlatform';
import { SimulationAttackTechnique } from './simulationAttackTechnique';
import { SimulationAttackType } from './simulationAttackType';
import { createSimulationReportFromDiscriminatorValue, serializeSimulationReport, type SimulationReport } from './simulationReport';
import { SimulationStatus } from './simulationStatus';
import { createTrainingSettingFromDiscriminatorValue, serializeTrainingSetting, type TrainingSetting } from './trainingSetting';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createSimulationFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoSimulation;
}
export function deserializeIntoSimulation(simulation: Simulation | undefined = {} as Simulation) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(simulation),
        "attackTechnique": n => { simulation.attackTechnique = n.getEnumValue<SimulationAttackTechnique>(SimulationAttackTechnique); },
        "attackType": n => { simulation.attackType = n.getEnumValue<SimulationAttackType>(SimulationAttackType); },
        "automationId": n => { simulation.automationId = n.getStringValue(); },
        "completionDateTime": n => { simulation.completionDateTime = n.getDateValue(); },
        "createdBy": n => { simulation.createdBy = n.getObjectValue<EmailIdentity>(createEmailIdentityFromDiscriminatorValue); },
        "createdDateTime": n => { simulation.createdDateTime = n.getDateValue(); },
        "description": n => { simulation.description = n.getStringValue(); },
        "displayName": n => { simulation.displayName = n.getStringValue(); },
        "durationInDays": n => { simulation.durationInDays = n.getNumberValue(); },
        "endUserNotificationSetting": n => { simulation.endUserNotificationSetting = n.getObjectValue<EndUserNotificationSetting>(createEndUserNotificationSettingFromDiscriminatorValue); },
        "excludedAccountTarget": n => { simulation.excludedAccountTarget = n.getObjectValue<AccountTargetContent>(createAccountTargetContentFromDiscriminatorValue); },
        "includedAccountTarget": n => { simulation.includedAccountTarget = n.getObjectValue<AccountTargetContent>(createAccountTargetContentFromDiscriminatorValue); },
        "isAutomated": n => { simulation.isAutomated = n.getBooleanValue(); },
        "landingPage": n => { simulation.landingPage = n.getObjectValue<LandingPage>(createLandingPageFromDiscriminatorValue); },
        "lastModifiedBy": n => { simulation.lastModifiedBy = n.getObjectValue<EmailIdentity>(createEmailIdentityFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { simulation.lastModifiedDateTime = n.getDateValue(); },
        "launchDateTime": n => { simulation.launchDateTime = n.getDateValue(); },
        "loginPage": n => { simulation.loginPage = n.getObjectValue<LoginPage>(createLoginPageFromDiscriminatorValue); },
        "oAuthConsentAppDetail": n => { simulation.oAuthConsentAppDetail = n.getObjectValue<OAuthConsentAppDetail>(createOAuthConsentAppDetailFromDiscriminatorValue); },
        "payload": n => { simulation.payload = n.getObjectValue<Payload>(createPayloadFromDiscriminatorValue); },
        "payloadDeliveryPlatform": n => { simulation.payloadDeliveryPlatform = n.getEnumValue<PayloadDeliveryPlatform>(PayloadDeliveryPlatform); },
        "report": n => { simulation.report = n.getObjectValue<SimulationReport>(createSimulationReportFromDiscriminatorValue); },
        "status": n => { simulation.status = n.getEnumValue<SimulationStatus>(SimulationStatus); },
        "trainingSetting": n => { simulation.trainingSetting = n.getObjectValue<TrainingSetting>(createTrainingSettingFromDiscriminatorValue); },
    }
}
export function serializeSimulation(writer: SerializationWriter, simulation: Simulation | undefined = {} as Simulation) : void {
        serializeEntity(writer, simulation)
        writer.writeEnumValue<SimulationAttackTechnique>("attackTechnique", simulation.attackTechnique);
        writer.writeEnumValue<SimulationAttackType>("attackType", simulation.attackType);
        writer.writeStringValue("automationId", simulation.automationId);
        writer.writeDateValue("completionDateTime", simulation.completionDateTime);
        writer.writeObjectValue<EmailIdentity>("createdBy", simulation.createdBy, serializeEmailIdentity);
        writer.writeDateValue("createdDateTime", simulation.createdDateTime);
        writer.writeStringValue("description", simulation.description);
        writer.writeStringValue("displayName", simulation.displayName);
        writer.writeNumberValue("durationInDays", simulation.durationInDays);
        writer.writeObjectValue<EndUserNotificationSetting>("endUserNotificationSetting", simulation.endUserNotificationSetting, serializeEndUserNotificationSetting);
        writer.writeObjectValue<AccountTargetContent>("excludedAccountTarget", simulation.excludedAccountTarget, serializeAccountTargetContent);
        writer.writeObjectValue<AccountTargetContent>("includedAccountTarget", simulation.includedAccountTarget, serializeAccountTargetContent);
        writer.writeBooleanValue("isAutomated", simulation.isAutomated);
        writer.writeObjectValue<LandingPage>("landingPage", simulation.landingPage, serializeLandingPage);
        writer.writeObjectValue<EmailIdentity>("lastModifiedBy", simulation.lastModifiedBy, serializeEmailIdentity);
        writer.writeDateValue("lastModifiedDateTime", simulation.lastModifiedDateTime);
        writer.writeDateValue("launchDateTime", simulation.launchDateTime);
        writer.writeObjectValue<LoginPage>("loginPage", simulation.loginPage, serializeLoginPage);
        writer.writeObjectValue<OAuthConsentAppDetail>("oAuthConsentAppDetail", simulation.oAuthConsentAppDetail, serializeOAuthConsentAppDetail);
        writer.writeObjectValue<Payload>("payload", simulation.payload, serializePayload);
        writer.writeEnumValue<PayloadDeliveryPlatform>("payloadDeliveryPlatform", simulation.payloadDeliveryPlatform);
        writer.writeObjectValue<SimulationReport>("report", simulation.report, serializeSimulationReport);
        writer.writeEnumValue<SimulationStatus>("status", simulation.status);
        writer.writeObjectValue<TrainingSetting>("trainingSetting", simulation.trainingSetting, serializeTrainingSetting);
}
export interface Simulation extends Entity, Parsable {
    /**
     * The social engineering technique used in the attack simulation and training campaign. Supports $filter and $orderby. Possible values are: unknown, credentialHarvesting, attachmentMalware, driveByUrl, linkInAttachment, linkToMalwareFile, unknownFutureValue, oAuthConsentGrant. Note that you must use the Prefer: include-unknown-enum-members request header to get the following values from this evolvable enum: oAuthConsentGrant. For more information on the types of social engineering attack techniques, see simulations.
     */
    attackTechnique?: SimulationAttackTechnique;
    /**
     * Attack type of the attack simulation and training campaign. Supports $filter and $orderby. Possible values are: unknown, social, cloud, endpoint, unknownFutureValue.
     */
    attackType?: SimulationAttackType;
    /**
     * Unique identifier for the attack simulation automation.
     */
    automationId?: string;
    /**
     * Date and time of completion of the attack simulation and training campaign. Supports $filter and $orderby.
     */
    completionDateTime?: Date;
    /**
     * Identity of the user who created the attack simulation and training campaign.
     */
    createdBy?: EmailIdentity;
    /**
     * Date and time of creation of the attack simulation and training campaign.
     */
    createdDateTime?: Date;
    /**
     * Description of the attack simulation and training campaign.
     */
    description?: string;
    /**
     * Display name of the attack simulation and training campaign. Supports $filter and $orderby.
     */
    displayName?: string;
    /**
     * Simulation duration in days.
     */
    durationInDays?: number;
    /**
     * Details about the end user notification setting.
     */
    endUserNotificationSetting?: EndUserNotificationSetting;
    /**
     * Users excluded from the simulation.
     */
    excludedAccountTarget?: AccountTargetContent;
    /**
     * Users targeted in the simulation.
     */
    includedAccountTarget?: AccountTargetContent;
    /**
     * Flag that represents if the attack simulation and training campaign was created from a simulation automation flow. Supports $filter and $orderby.
     */
    isAutomated?: boolean;
    /**
     * The landing page associated with a simulation during its creation.
     */
    landingPage?: LandingPage;
    /**
     * Identity of the user who most recently modified the attack simulation and training campaign.
     */
    lastModifiedBy?: EmailIdentity;
    /**
     * Date and time of the most recent modification of the attack simulation and training campaign.
     */
    lastModifiedDateTime?: Date;
    /**
     * Date and time of the launch/start of the attack simulation and training campaign. Supports $filter and $orderby.
     */
    launchDateTime?: Date;
    /**
     * The login page associated with a simulation during its creation.
     */
    loginPage?: LoginPage;
    /**
     * OAuth app details for the OAuth technique.
     */
    oAuthConsentAppDetail?: OAuthConsentAppDetail;
    /**
     * The payload associated with a simulation during its creation.
     */
    payload?: Payload;
    /**
     * Method of delivery of the phishing payload used in the attack simulation and training campaign. Possible values are: unknown, sms, email, teams, unknownFutureValue.
     */
    payloadDeliveryPlatform?: PayloadDeliveryPlatform;
    /**
     * Report of the attack simulation and training campaign.
     */
    report?: SimulationReport;
    /**
     * Status of the attack simulation and training campaign. Supports $filter and $orderby. Possible values are: unknown, draft, running, scheduled, succeeded, failed, cancelled, excluded, unknownFutureValue.
     */
    status?: SimulationStatus;
    /**
     * Details about the training settings for a simulation.
     */
    trainingSetting?: TrainingSetting;
}
// tslint:enable
// eslint-enable
