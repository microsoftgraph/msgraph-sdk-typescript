// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { createDateTimeTimeZoneFromDiscriminatorValue, serializeDateTimeTimeZone, type DateTimeTimeZone } from './dateTimeTimeZone';
import { createEventFromDiscriminatorValue, serializeEvent, type Event } from './event';
import { deserializeIntoEventMessageRequest } from './eventMessageRequest';
import { deserializeIntoEventMessageResponse } from './eventMessageResponse';
import { EventType } from './eventType';
import { type EventMessageRequest, type EventMessageResponse } from './index';
import { createLocationFromDiscriminatorValue, serializeLocation, type Location } from './location';
import { MeetingMessageType } from './meetingMessageType';
import { deserializeIntoMessage, serializeMessage, type Message } from './message';
import { createPatternedRecurrenceFromDiscriminatorValue, serializePatternedRecurrence, type PatternedRecurrence } from './patternedRecurrence';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createEventMessageFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.eventMessageRequest":
                    return deserializeIntoEventMessageRequest;
                case "#microsoft.graph.eventMessageResponse":
                    return deserializeIntoEventMessageResponse;
            }
        }
    }
    return deserializeIntoEventMessage;
}
export function deserializeIntoEventMessage(eventMessage: EventMessage | undefined = {} as EventMessage) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoMessage(eventMessage),
        "endDateTime": n => { eventMessage.endDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "event": n => { eventMessage.event = n.getObjectValue<Event>(createEventFromDiscriminatorValue); },
        "isAllDay": n => { eventMessage.isAllDay = n.getBooleanValue(); },
        "isDelegated": n => { eventMessage.isDelegated = n.getBooleanValue(); },
        "isOutOfDate": n => { eventMessage.isOutOfDate = n.getBooleanValue(); },
        "location": n => { eventMessage.location = n.getObjectValue<Location>(createLocationFromDiscriminatorValue); },
        "meetingMessageType": n => { eventMessage.meetingMessageType = n.getEnumValue<MeetingMessageType>(MeetingMessageType); },
        "recurrence": n => { eventMessage.recurrence = n.getObjectValue<PatternedRecurrence>(createPatternedRecurrenceFromDiscriminatorValue); },
        "startDateTime": n => { eventMessage.startDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "type": n => { eventMessage.type = n.getEnumValue<EventType>(EventType); },
    }
}
export interface EventMessage extends Message, Parsable {
    /**
     * The endDateTime property
     */
    endDateTime?: DateTimeTimeZone;
    /**
     * The event associated with the event message. The assumption for attendees or room resources is that the Calendar Attendant is set to automatically update the calendar with an event when meeting request event messages arrive. Navigation property.  Read-only.
     */
    event?: Event;
    /**
     * The isAllDay property
     */
    isAllDay?: boolean;
    /**
     * The isDelegated property
     */
    isDelegated?: boolean;
    /**
     * The isOutOfDate property
     */
    isOutOfDate?: boolean;
    /**
     * The location property
     */
    location?: Location;
    /**
     * The meetingMessageType property
     */
    meetingMessageType?: MeetingMessageType;
    /**
     * The recurrence property
     */
    recurrence?: PatternedRecurrence;
    /**
     * The startDateTime property
     */
    startDateTime?: DateTimeTimeZone;
    /**
     * The type property
     */
    type?: EventType;
}
export function serializeEventMessage(writer: SerializationWriter, eventMessage: EventMessage | undefined = {} as EventMessage) : void {
        serializeMessage(writer, eventMessage)
        writer.writeObjectValue<DateTimeTimeZone>("endDateTime", eventMessage.endDateTime, );
        writer.writeObjectValue<Event>("event", eventMessage.event, );
        writer.writeBooleanValue("isAllDay", eventMessage.isAllDay);
        writer.writeBooleanValue("isDelegated", eventMessage.isDelegated);
        writer.writeBooleanValue("isOutOfDate", eventMessage.isOutOfDate);
        writer.writeObjectValue<Location>("location", eventMessage.location, );
        writer.writeEnumValue<MeetingMessageType>("meetingMessageType", eventMessage.meetingMessageType);
        writer.writeObjectValue<PatternedRecurrence>("recurrence", eventMessage.recurrence, );
        writer.writeObjectValue<DateTimeTimeZone>("startDateTime", eventMessage.startDateTime, );
        writer.writeEnumValue<EventType>("type", eventMessage.type);
}
// tslint:enable
// eslint-enable
