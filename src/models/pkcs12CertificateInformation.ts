// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createPkcs12CertificateInformationFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoPkcs12CertificateInformation;
}
export function deserializeIntoPkcs12CertificateInformation(pkcs12CertificateInformation: Pkcs12CertificateInformation | undefined = {} as Pkcs12CertificateInformation) : Record<string, (node: ParseNode) => void> {
    return {
        "isActive": n => { pkcs12CertificateInformation.isActive = n.getBooleanValue(); },
        "notAfter": n => { pkcs12CertificateInformation.notAfter = n.getNumberValue(); },
        "notBefore": n => { pkcs12CertificateInformation.notBefore = n.getNumberValue(); },
        "@odata.type": n => { pkcs12CertificateInformation.odataType = n.getStringValue(); },
        "thumbprint": n => { pkcs12CertificateInformation.thumbprint = n.getStringValue(); },
    }
}
export interface Pkcs12CertificateInformation extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Represents whether the certificate is the active certificate to be used for calling the API connector. The active certificate is the most recently uploaded certificate that isn't yet expired but whose notBefore time is in the past.
     */
    isActive?: boolean;
    /**
     * The certificate's expiry. This value is a NumericDate as defined in RFC 7519 (A JSON numeric value representing the number of seconds from 1970-01-01T00:00:00Z UTC until the specified UTC date/time, ignoring leap seconds.)
     */
    notAfter?: number;
    /**
     * The certificate's issue time (not before). This value is a NumericDate as defined in RFC 7519 (A JSON numeric value representing the number of seconds from 1970-01-01T00:00:00Z UTC until the specified UTC date/time, ignoring leap seconds.)
     */
    notBefore?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The certificate thumbprint.
     */
    thumbprint?: string;
}
export function serializePkcs12CertificateInformation(writer: SerializationWriter, pkcs12CertificateInformation: Pkcs12CertificateInformation | undefined = {} as Pkcs12CertificateInformation) : void {
    writer.writeBooleanValue("isActive", pkcs12CertificateInformation.isActive);
    writer.writeNumberValue("notAfter", pkcs12CertificateInformation.notAfter);
    writer.writeNumberValue("notBefore", pkcs12CertificateInformation.notBefore);
    writer.writeStringValue("@odata.type", pkcs12CertificateInformation.odataType);
    writer.writeStringValue("thumbprint", pkcs12CertificateInformation.thumbprint);
    writer.writeAdditionalData(pkcs12CertificateInformation.additionalData);
}
// tslint:enable
// eslint-enable
