// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { createAttributeMappingFromDiscriminatorValue, serializeAttributeMapping, type AttributeMapping } from './attributeMapping';
import { createFilterFromDiscriminatorValue, serializeFilter, type Filter } from './filter';
import { ObjectFlowTypes } from './objectFlowTypes';
import { createObjectMappingMetadataEntryFromDiscriminatorValue, serializeObjectMappingMetadataEntry, type ObjectMappingMetadataEntry } from './objectMappingMetadataEntry';
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createObjectMappingFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoObjectMapping;
}
export function deserializeIntoObjectMapping(objectMapping: ObjectMapping | undefined = {} as ObjectMapping) : Record<string, (node: ParseNode) => void> {
    return {
        "attributeMappings": n => { objectMapping.attributeMappings = n.getCollectionOfObjectValues<AttributeMapping>(createAttributeMappingFromDiscriminatorValue); },
        "enabled": n => { objectMapping.enabled = n.getBooleanValue(); },
        "flowTypes": n => { objectMapping.flowTypes = n.getCollectionOfEnumValues<ObjectFlowTypes>(ObjectFlowTypes); },
        "metadata": n => { objectMapping.metadata = n.getCollectionOfObjectValues<ObjectMappingMetadataEntry>(createObjectMappingMetadataEntryFromDiscriminatorValue); },
        "name": n => { objectMapping.name = n.getStringValue(); },
        "@odata.type": n => { objectMapping.odataType = n.getStringValue(); },
        "scope": n => { objectMapping.scope = n.getObjectValue<Filter>(createFilterFromDiscriminatorValue); },
        "sourceObjectName": n => { objectMapping.sourceObjectName = n.getStringValue(); },
        "targetObjectName": n => { objectMapping.targetObjectName = n.getStringValue(); },
    }
}
export interface ObjectMapping extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Attribute mappings define which attributes to map from the source object into the target object and how they should flow. A number of functions are available to support the transformation of the original source values.
     */
    attributeMappings?: AttributeMapping[];
    /**
     * When true, this object mapping will be processed during synchronization. When false, this object mapping will be skipped.
     */
    enabled?: boolean;
    /**
     * The flowTypes property
     */
    flowTypes?: ObjectFlowTypes[];
    /**
     * Additional extension properties. Unless mentioned explicitly, metadata values should not be changed.
     */
    metadata?: ObjectMappingMetadataEntry[];
    /**
     * Human-friendly name of the object mapping.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Defines a filter to be used when deciding whether a given object should be provisioned. For example, you might want to only provision users that are located in the US.
     */
    scope?: Filter;
    /**
     * Name of the object in the source directory. Must match the object name from the source directory definition.
     */
    sourceObjectName?: string;
    /**
     * Name of the object in target directory. Must match the object name from the target directory definition.
     */
    targetObjectName?: string;
}
export function serializeObjectMapping(writer: SerializationWriter, objectMapping: ObjectMapping | undefined = {} as ObjectMapping) : void {
        writer.writeCollectionOfObjectValues<AttributeMapping>("attributeMappings", objectMapping.attributeMappings, );
        writer.writeBooleanValue("enabled", objectMapping.enabled);
        writer.writeEnumValue<ObjectFlowTypes[]>("flowTypes", objectMapping.flowTypes);
        writer.writeCollectionOfObjectValues<ObjectMappingMetadataEntry>("metadata", objectMapping.metadata, );
        writer.writeStringValue("name", objectMapping.name);
        writer.writeStringValue("@odata.type", objectMapping.odataType);
        writer.writeObjectValue<Filter>("scope", objectMapping.scope, );
        writer.writeStringValue("sourceObjectName", objectMapping.sourceObjectName);
        writer.writeStringValue("targetObjectName", objectMapping.targetObjectName);
        writer.writeAdditionalData(objectMapping.additionalData);
}
// tslint:enable
// eslint-enable
