// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { BookingPriceType } from './bookingPriceType';
import { createBookingQuestionAssignmentFromDiscriminatorValue, serializeBookingQuestionAssignment, type BookingQuestionAssignment } from './bookingQuestionAssignment';
import { createBookingReminderFromDiscriminatorValue, serializeBookingReminder, type BookingReminder } from './bookingReminder';
import { createBookingSchedulingPolicyFromDiscriminatorValue, serializeBookingSchedulingPolicy, type BookingSchedulingPolicy } from './bookingSchedulingPolicy';
import { deserializeIntoEntity, serializeEntity, type Entity } from './entity';
import { createLocationFromDiscriminatorValue, serializeLocation, type Location } from './location';
import { Duration, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface BookingService extends Entity, Parsable {
    /**
     * Additional information that is sent to the customer when an appointment is confirmed.
     */
    additionalInformation?: string;
    /**
     * Contains the set of custom questions associated with a particular service.
     */
    customQuestions?: BookingQuestionAssignment[];
    /**
     * The default length of the service, represented in numbers of days, hours, minutes, and seconds. For example, P11D23H59M59.999999999999S.
     */
    defaultDuration?: Duration;
    /**
     * The default physical location for the service.
     */
    defaultLocation?: Location;
    /**
     * The default monetary price for the service.
     */
    defaultPrice?: number;
    /**
     * Represents the type of pricing of a booking service.
     */
    defaultPriceType?: BookingPriceType;
    /**
     * The default set of reminders for an appointment of this service. The value of this property is available only when reading this bookingService by its ID.
     */
    defaultReminders?: BookingReminder[];
    /**
     * A text description for the service.
     */
    description?: string;
    /**
     * A service name.
     */
    displayName?: string;
    /**
     * True if the URL to join the appointment anonymously (anonymousJoinWebUrl) will be generated for the appointment booked for this service.
     */
    isAnonymousJoinEnabled?: boolean;
    /**
     * True means this service is not available to customers for booking.
     */
    isHiddenFromCustomers?: boolean;
    /**
     * True indicates that the appointments for the service will be held online. Default value is false.
     */
    isLocationOnline?: boolean;
    /**
     * The language of the self-service booking page.
     */
    languageTag?: string;
    /**
     * The maximum number of customers allowed in a service. If maximumAttendeesCount of the service is greater than 1, pass valid customer IDs while creating or updating an appointment. To create a customer, use the Create bookingCustomer operation.
     */
    maximumAttendeesCount?: number;
    /**
     * Additional information about this service.
     */
    notes?: string;
    /**
     * The time to buffer after an appointment for this service ends, and before the next customer appointment can be booked.
     */
    postBuffer?: Duration;
    /**
     * The time to buffer before an appointment for this service can start.
     */
    preBuffer?: Duration;
    /**
     * The set of policies that determine how appointments for this type of service should be created and managed.
     */
    schedulingPolicy?: BookingSchedulingPolicy;
    /**
     * True indicates SMS notifications can be sent to the customers for the appointment of the service. Default value is false.
     */
    smsNotificationsEnabled?: boolean;
    /**
     * Represents those staff members who provide this service.
     */
    staffMemberIds?: string[];
    /**
     * The URL a customer uses to access the service.
     */
    webUrl?: string;
}
export function createBookingServiceFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoBookingService;
}
export function deserializeIntoBookingService(bookingService: BookingService | undefined = {} as BookingService) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(bookingService),
        "additionalInformation": n => { bookingService.additionalInformation = n.getStringValue(); },
        "customQuestions": n => { bookingService.customQuestions = n.getCollectionOfObjectValues<BookingQuestionAssignment>(createBookingQuestionAssignmentFromDiscriminatorValue); },
        "defaultDuration": n => { bookingService.defaultDuration = n.getDurationValue(); },
        "defaultLocation": n => { bookingService.defaultLocation = n.getObjectValue<Location>(createLocationFromDiscriminatorValue); },
        "defaultPrice": n => { bookingService.defaultPrice = n.getNumberValue(); },
        "defaultPriceType": n => { bookingService.defaultPriceType = n.getEnumValue<BookingPriceType>(BookingPriceType); },
        "defaultReminders": n => { bookingService.defaultReminders = n.getCollectionOfObjectValues<BookingReminder>(createBookingReminderFromDiscriminatorValue); },
        "description": n => { bookingService.description = n.getStringValue(); },
        "displayName": n => { bookingService.displayName = n.getStringValue(); },
        "isAnonymousJoinEnabled": n => { bookingService.isAnonymousJoinEnabled = n.getBooleanValue(); },
        "isHiddenFromCustomers": n => { bookingService.isHiddenFromCustomers = n.getBooleanValue(); },
        "isLocationOnline": n => { bookingService.isLocationOnline = n.getBooleanValue(); },
        "languageTag": n => { bookingService.languageTag = n.getStringValue(); },
        "maximumAttendeesCount": n => { bookingService.maximumAttendeesCount = n.getNumberValue(); },
        "notes": n => { bookingService.notes = n.getStringValue(); },
        "postBuffer": n => { bookingService.postBuffer = n.getDurationValue(); },
        "preBuffer": n => { bookingService.preBuffer = n.getDurationValue(); },
        "schedulingPolicy": n => { bookingService.schedulingPolicy = n.getObjectValue<BookingSchedulingPolicy>(createBookingSchedulingPolicyFromDiscriminatorValue); },
        "smsNotificationsEnabled": n => { bookingService.smsNotificationsEnabled = n.getBooleanValue(); },
        "staffMemberIds": n => { bookingService.staffMemberIds = n.getCollectionOfPrimitiveValues<string>(); },
        "webUrl": n => { bookingService.webUrl = n.getStringValue(); },
    }
}
export function serializeBookingService(writer: SerializationWriter, bookingService: BookingService | undefined = {} as BookingService) : void {
        serializeEntity(writer, bookingService)
        writer.writeStringValue("additionalInformation", bookingService.additionalInformation);
        writer.writeCollectionOfObjectValues<BookingQuestionAssignment>("customQuestions", bookingService.customQuestions, );
        writer.writeDurationValue("defaultDuration", bookingService.defaultDuration);
        writer.writeObjectValue<Location>("defaultLocation", bookingService.defaultLocation, );
        writer.writeNumberValue("defaultPrice", bookingService.defaultPrice);
        writer.writeEnumValue<BookingPriceType>("defaultPriceType", bookingService.defaultPriceType);
        writer.writeCollectionOfObjectValues<BookingReminder>("defaultReminders", bookingService.defaultReminders, );
        writer.writeStringValue("description", bookingService.description);
        writer.writeStringValue("displayName", bookingService.displayName);
        writer.writeBooleanValue("isAnonymousJoinEnabled", bookingService.isAnonymousJoinEnabled);
        writer.writeBooleanValue("isHiddenFromCustomers", bookingService.isHiddenFromCustomers);
        writer.writeBooleanValue("isLocationOnline", bookingService.isLocationOnline);
        writer.writeStringValue("languageTag", bookingService.languageTag);
        writer.writeNumberValue("maximumAttendeesCount", bookingService.maximumAttendeesCount);
        writer.writeStringValue("notes", bookingService.notes);
        writer.writeDurationValue("postBuffer", bookingService.postBuffer);
        writer.writeDurationValue("preBuffer", bookingService.preBuffer);
        writer.writeObjectValue<BookingSchedulingPolicy>("schedulingPolicy", bookingService.schedulingPolicy, );
        writer.writeBooleanValue("smsNotificationsEnabled", bookingService.smsNotificationsEnabled);
        writer.writeCollectionOfPrimitiveValues<string>("staffMemberIds", bookingService.staffMemberIds);
}
// tslint:enable
// eslint-enable
