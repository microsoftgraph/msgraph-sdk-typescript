// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { deserializeIntoEntity, serializeEntity, type Entity } from '../entity';
import { LifecycleWorkflowProcessingStatus } from './lifecycleWorkflowProcessingStatus';
import { createTaskFromDiscriminatorValue, serializeTask, type Task } from './task';
import { createTaskDefinitionFromDiscriminatorValue, serializeTaskDefinition, type TaskDefinition } from './taskDefinition';
import { createTaskProcessingResultFromDiscriminatorValue, serializeTaskProcessingResult, type TaskProcessingResult } from './taskProcessingResult';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createTaskReportFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoTaskReport;
}
export function deserializeIntoTaskReport(taskReport: TaskReport | undefined = {} as TaskReport) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(taskReport),
        "completedDateTime": n => { taskReport.completedDateTime = n.getDateValue(); },
        "failedUsersCount": n => { taskReport.failedUsersCount = n.getNumberValue(); },
        "lastUpdatedDateTime": n => { taskReport.lastUpdatedDateTime = n.getDateValue(); },
        "processingStatus": n => { taskReport.processingStatus = n.getEnumValue<LifecycleWorkflowProcessingStatus>(LifecycleWorkflowProcessingStatus); },
        "runId": n => { taskReport.runId = n.getStringValue(); },
        "startedDateTime": n => { taskReport.startedDateTime = n.getDateValue(); },
        "successfulUsersCount": n => { taskReport.successfulUsersCount = n.getNumberValue(); },
        "task": n => { taskReport.task = n.getObjectValue<Task>(createTaskFromDiscriminatorValue); },
        "taskDefinition": n => { taskReport.taskDefinition = n.getObjectValue<TaskDefinition>(createTaskDefinitionFromDiscriminatorValue); },
        "taskProcessingResults": n => { taskReport.taskProcessingResults = n.getCollectionOfObjectValues<TaskProcessingResult>(createTaskProcessingResultFromDiscriminatorValue); },
        "totalUsersCount": n => { taskReport.totalUsersCount = n.getNumberValue(); },
        "unprocessedUsersCount": n => { taskReport.unprocessedUsersCount = n.getNumberValue(); },
    }
}
export function serializeTaskReport(writer: SerializationWriter, taskReport: TaskReport | undefined = {} as TaskReport) : void {
        serializeEntity(writer, taskReport)
        writer.writeDateValue("completedDateTime", taskReport.completedDateTime);
        writer.writeNumberValue("failedUsersCount", taskReport.failedUsersCount);
        writer.writeDateValue("lastUpdatedDateTime", taskReport.lastUpdatedDateTime);
        writer.writeEnumValue<LifecycleWorkflowProcessingStatus>("processingStatus", taskReport.processingStatus);
        writer.writeStringValue("runId", taskReport.runId);
        writer.writeDateValue("startedDateTime", taskReport.startedDateTime);
        writer.writeNumberValue("successfulUsersCount", taskReport.successfulUsersCount);
        writer.writeObjectValue<Task>("task", taskReport.task, );
        writer.writeObjectValue<TaskDefinition>("taskDefinition", taskReport.taskDefinition, );
        writer.writeCollectionOfObjectValues<TaskProcessingResult>("taskProcessingResults", taskReport.taskProcessingResults, );
        writer.writeNumberValue("totalUsersCount", taskReport.totalUsersCount);
        writer.writeNumberValue("unprocessedUsersCount", taskReport.unprocessedUsersCount);
}
export interface TaskReport extends Entity, Parsable {
    /**
     * The date time that the associated run completed. Value is null if the run has not completed.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    completedDateTime?: Date;
    /**
     * The number of users in the run execution for which the associated task failed.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    failedUsersCount?: number;
    /**
     * The date and time that the task report was last updated.
     */
    lastUpdatedDateTime?: Date;
    /**
     * The processingStatus property
     */
    processingStatus?: LifecycleWorkflowProcessingStatus;
    /**
     * The unique identifier of the associated run.
     */
    runId?: string;
    /**
     * The date time that the associated run started. Value is null if the run has not started.
     */
    startedDateTime?: Date;
    /**
     * The number of users in the run execution for which the associated task succeeded.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    successfulUsersCount?: number;
    /**
     * The task property
     */
    task?: Task;
    /**
     * The taskDefinition property
     */
    taskDefinition?: TaskDefinition;
    /**
     * The related lifecycle workflow taskProcessingResults.
     */
    taskProcessingResults?: TaskProcessingResult[];
    /**
     * The total number of users in the run execution for which the associated task was scheduled to execute.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    totalUsersCount?: number;
    /**
     * The number of users in the run execution for which the associated task is queued, in progress, or canceled.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    unprocessedUsersCount?: number;
}
// tslint:enable
// eslint-enable
