import { createUserFromDiscriminatorValue, serializeUser, type User } from '../user';
import { type Workflow, type WorkflowVersion } from './index';
import { LifecycleWorkflowCategory } from './lifecycleWorkflowCategory';
import { createTaskFromDiscriminatorValue, serializeTask, type Task } from './task';
import { deserializeIntoWorkflow } from './workflow';
import { createWorkflowExecutionConditionsFromDiscriminatorValue, serializeWorkflowExecutionConditions, type WorkflowExecutionConditions } from './workflowExecutionConditions';
import { deserializeIntoWorkflowVersion } from './workflowVersion';
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function createWorkflowBaseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.identityGovernance.workflow":
                    return deserializeIntoWorkflow;
                case "#microsoft.graph.identityGovernance.workflowVersion":
                    return deserializeIntoWorkflowVersion;
            }
        }
    }
    return deserializeIntoWorkflowBase;
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function deserializeIntoWorkflowBase(workflowBase: WorkflowBase | undefined = {} as WorkflowBase) : Record<string, (node: ParseNode) => void> {
    return {
        "category": n => { workflowBase.category = n.getEnumValue<LifecycleWorkflowCategory>(LifecycleWorkflowCategory); },
        "createdBy": n => { workflowBase.createdBy = n.getObjectValue<User>(createUserFromDiscriminatorValue); },
        "createdDateTime": n => { workflowBase.createdDateTime = n.getDateValue(); },
        "description": n => { workflowBase.description = n.getStringValue(); },
        "displayName": n => { workflowBase.displayName = n.getStringValue(); },
        "executionConditions": n => { workflowBase.executionConditions = n.getObjectValue<WorkflowExecutionConditions>(createWorkflowExecutionConditionsFromDiscriminatorValue); },
        "isEnabled": n => { workflowBase.isEnabled = n.getBooleanValue(); },
        "isSchedulingEnabled": n => { workflowBase.isSchedulingEnabled = n.getBooleanValue(); },
        "lastModifiedBy": n => { workflowBase.lastModifiedBy = n.getObjectValue<User>(createUserFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { workflowBase.lastModifiedDateTime = n.getDateValue(); },
        "@odata.type": n => { workflowBase.odataType = n.getStringValue(); },
        "tasks": n => { workflowBase.tasks = n.getCollectionOfObjectValues<Task>(createTaskFromDiscriminatorValue); },
    }
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function serializeWorkflowBase(writer: SerializationWriter, workflowBase: WorkflowBase | undefined = {} as WorkflowBase) : void {
        writer.writeEnumValue<LifecycleWorkflowCategory>("category", workflowBase.category);
        writer.writeObjectValue<User>("createdBy", workflowBase.createdBy, );
        writer.writeDateValue("createdDateTime", workflowBase.createdDateTime);
        writer.writeStringValue("description", workflowBase.description);
        writer.writeStringValue("displayName", workflowBase.displayName);
        writer.writeObjectValue<WorkflowExecutionConditions>("executionConditions", workflowBase.executionConditions, );
        writer.writeBooleanValue("isEnabled", workflowBase.isEnabled);
        writer.writeBooleanValue("isSchedulingEnabled", workflowBase.isSchedulingEnabled);
        writer.writeObjectValue<User>("lastModifiedBy", workflowBase.lastModifiedBy, );
        writer.writeDateValue("lastModifiedDateTime", workflowBase.lastModifiedDateTime);
        writer.writeStringValue("@odata.type", workflowBase.odataType);
        writer.writeCollectionOfObjectValues<Task>("tasks", workflowBase.tasks, );
        writer.writeAdditionalData(workflowBase.additionalData);
}
export interface WorkflowBase extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The category property
     */
    category?: LifecycleWorkflowCategory;
    /**
     * The user who created the workflow.
     */
    createdBy?: User;
    /**
     * When a workflow was created.
     */
    createdDateTime?: Date;
    /**
     * A string that describes the purpose of the workflow.
     */
    description?: string;
    /**
     * A string to identify the workflow.
     */
    displayName?: string;
    /**
     * Defines when and for who the workflow will run.
     */
    executionConditions?: WorkflowExecutionConditions;
    /**
     * Whether the workflow is enabled or disabled. If this setting is true, the workflow can be run on demand or on schedule when isSchedulingEnabled is true.
     */
    isEnabled?: boolean;
    /**
     * If true, the Lifecycle Workflow engine executes the workflow based on the schedule defined by tenant settings. Can't be true for a disabled workflow (where isEnabled is false).
     */
    isSchedulingEnabled?: boolean;
    /**
     * The unique identifier of the Azure Active Directory identity that last modified the workflow.
     */
    lastModifiedBy?: User;
    /**
     * When the workflow was last modified.
     */
    lastModifiedDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The tasks in the workflow.
     */
    tasks?: Task[];
}
