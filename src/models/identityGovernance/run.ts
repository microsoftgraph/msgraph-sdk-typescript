// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { deserializeIntoEntity, serializeEntity, type Entity } from '../entity';
import { LifecycleWorkflowProcessingStatus } from './lifecycleWorkflowProcessingStatus';
import { createTaskProcessingResultFromDiscriminatorValue, serializeTaskProcessingResult, type TaskProcessingResult } from './taskProcessingResult';
import { createUserProcessingResultFromDiscriminatorValue, serializeUserProcessingResult, type UserProcessingResult } from './userProcessingResult';
import { WorkflowExecutionType } from './workflowExecutionType';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createRunFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoRun;
}
export function deserializeIntoRun(run: Run | undefined = {} as Run) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(run),
        "completedDateTime": n => { run.completedDateTime = n.getDateValue(); },
        "failedTasksCount": n => { run.failedTasksCount = n.getNumberValue(); },
        "failedUsersCount": n => { run.failedUsersCount = n.getNumberValue(); },
        "lastUpdatedDateTime": n => { run.lastUpdatedDateTime = n.getDateValue(); },
        "processingStatus": n => { run.processingStatus = n.getEnumValue<LifecycleWorkflowProcessingStatus>(LifecycleWorkflowProcessingStatus); },
        "scheduledDateTime": n => { run.scheduledDateTime = n.getDateValue(); },
        "startedDateTime": n => { run.startedDateTime = n.getDateValue(); },
        "successfulUsersCount": n => { run.successfulUsersCount = n.getNumberValue(); },
        "taskProcessingResults": n => { run.taskProcessingResults = n.getCollectionOfObjectValues<TaskProcessingResult>(createTaskProcessingResultFromDiscriminatorValue); },
        "totalTasksCount": n => { run.totalTasksCount = n.getNumberValue(); },
        "totalUnprocessedTasksCount": n => { run.totalUnprocessedTasksCount = n.getNumberValue(); },
        "totalUsersCount": n => { run.totalUsersCount = n.getNumberValue(); },
        "userProcessingResults": n => { run.userProcessingResults = n.getCollectionOfObjectValues<UserProcessingResult>(createUserProcessingResultFromDiscriminatorValue); },
        "workflowExecutionType": n => { run.workflowExecutionType = n.getEnumValue<WorkflowExecutionType>(WorkflowExecutionType); },
    }
}
export interface Run extends Entity, Parsable {
    /**
     * The date time that the run completed. Value is null if the workflow hasn't completed.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    completedDateTime?: Date;
    /**
     * The number of tasks that failed in the run execution.
     */
    failedTasksCount?: number;
    /**
     * The number of users that failed in the run execution.
     */
    failedUsersCount?: number;
    /**
     * The datetime that the run was last updated.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    lastUpdatedDateTime?: Date;
    /**
     * The processingStatus property
     */
    processingStatus?: LifecycleWorkflowProcessingStatus;
    /**
     * The date time that the run is scheduled to be executed for a workflow.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    scheduledDateTime?: Date;
    /**
     * The date time that the run execution started.Supports $filter(lt, le, gt, ge, eq, ne) and $orderby.
     */
    startedDateTime?: Date;
    /**
     * The number of successfully completed users in the run.
     */
    successfulUsersCount?: number;
    /**
     * The related taskProcessingResults.
     */
    taskProcessingResults?: TaskProcessingResult[];
    /**
     * The totalTasksCount property
     */
    totalTasksCount?: number;
    /**
     * The total number of unprocessed tasks in the run execution.
     */
    totalUnprocessedTasksCount?: number;
    /**
     * The total number of users in the workflow execution.
     */
    totalUsersCount?: number;
    /**
     * The associated individual user execution.
     */
    userProcessingResults?: UserProcessingResult[];
    /**
     * The workflowExecutionType property
     */
    workflowExecutionType?: WorkflowExecutionType;
}
export function serializeRun(writer: SerializationWriter, run: Run | undefined = {} as Run) : void {
        serializeEntity(writer, run)
        writer.writeDateValue("completedDateTime", run.completedDateTime);
        writer.writeNumberValue("failedTasksCount", run.failedTasksCount);
        writer.writeNumberValue("failedUsersCount", run.failedUsersCount);
        writer.writeDateValue("lastUpdatedDateTime", run.lastUpdatedDateTime);
        writer.writeEnumValue<LifecycleWorkflowProcessingStatus>("processingStatus", run.processingStatus);
        writer.writeDateValue("scheduledDateTime", run.scheduledDateTime);
        writer.writeDateValue("startedDateTime", run.startedDateTime);
        writer.writeNumberValue("successfulUsersCount", run.successfulUsersCount);
        writer.writeCollectionOfObjectValues<TaskProcessingResult>("taskProcessingResults", run.taskProcessingResults, );
        writer.writeNumberValue("totalTasksCount", run.totalTasksCount);
        writer.writeNumberValue("totalUnprocessedTasksCount", run.totalUnprocessedTasksCount);
        writer.writeNumberValue("totalUsersCount", run.totalUsersCount);
        writer.writeCollectionOfObjectValues<UserProcessingResult>("userProcessingResults", run.userProcessingResults, );
        writer.writeEnumValue<WorkflowExecutionType>("workflowExecutionType", run.workflowExecutionType);
}
// tslint:enable
// eslint-enable
