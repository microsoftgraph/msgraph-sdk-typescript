// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { deserializeIntoAzureCommunicationServicesUserIdentity } from './azureCommunicationServicesUserIdentity';
import { deserializeIntoCommunicationsApplicationIdentity } from './communicationsApplicationIdentity';
import { deserializeIntoCommunicationsApplicationInstanceIdentity } from './communicationsApplicationInstanceIdentity';
import { deserializeIntoCommunicationsEncryptedIdentity } from './communicationsEncryptedIdentity';
import { deserializeIntoCommunicationsGuestIdentity } from './communicationsGuestIdentity';
import { deserializeIntoCommunicationsPhoneIdentity } from './communicationsPhoneIdentity';
import { deserializeIntoCommunicationsUserIdentity } from './communicationsUserIdentity';
import { deserializeIntoEmailIdentity } from './emailIdentity';
import { type AzureCommunicationServicesUserIdentity, type CommunicationsApplicationIdentity, type CommunicationsApplicationInstanceIdentity, type CommunicationsEncryptedIdentity, type CommunicationsGuestIdentity, type CommunicationsPhoneIdentity, type CommunicationsUserIdentity, type EmailIdentity, type Initiator, type ProvisionedIdentity, type ProvisioningServicePrincipal, type ProvisioningSystem, type ServicePrincipalIdentity, type SharePointIdentity, type TeamworkApplicationIdentity, type TeamworkConversationIdentity, type TeamworkTagIdentity, type TeamworkUserIdentity, type UserIdentity } from './index';
import { deserializeIntoInitiator } from './initiator';
import { deserializeIntoProvisionedIdentity } from './provisionedIdentity';
import { deserializeIntoProvisioningServicePrincipal } from './provisioningServicePrincipal';
import { deserializeIntoProvisioningSystem } from './provisioningSystem';
import { deserializeIntoServicePrincipalIdentity } from './servicePrincipalIdentity';
import { deserializeIntoSharePointIdentity } from './sharePointIdentity';
import { deserializeIntoTeamworkApplicationIdentity } from './teamworkApplicationIdentity';
import { deserializeIntoTeamworkConversationIdentity } from './teamworkConversationIdentity';
import { deserializeIntoTeamworkTagIdentity } from './teamworkTagIdentity';
import { deserializeIntoTeamworkUserIdentity } from './teamworkUserIdentity';
import { deserializeIntoUserIdentity } from './userIdentity';
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.azureCommunicationServicesUserIdentity":
                    return deserializeIntoAzureCommunicationServicesUserIdentity;
                case "#microsoft.graph.communicationsApplicationIdentity":
                    return deserializeIntoCommunicationsApplicationIdentity;
                case "#microsoft.graph.communicationsApplicationInstanceIdentity":
                    return deserializeIntoCommunicationsApplicationInstanceIdentity;
                case "#microsoft.graph.communicationsEncryptedIdentity":
                    return deserializeIntoCommunicationsEncryptedIdentity;
                case "#microsoft.graph.communicationsGuestIdentity":
                    return deserializeIntoCommunicationsGuestIdentity;
                case "#microsoft.graph.communicationsPhoneIdentity":
                    return deserializeIntoCommunicationsPhoneIdentity;
                case "#microsoft.graph.communicationsUserIdentity":
                    return deserializeIntoCommunicationsUserIdentity;
                case "#microsoft.graph.emailIdentity":
                    return deserializeIntoEmailIdentity;
                case "#microsoft.graph.initiator":
                    return deserializeIntoInitiator;
                case "#microsoft.graph.provisionedIdentity":
                    return deserializeIntoProvisionedIdentity;
                case "#microsoft.graph.provisioningServicePrincipal":
                    return deserializeIntoProvisioningServicePrincipal;
                case "#microsoft.graph.provisioningSystem":
                    return deserializeIntoProvisioningSystem;
                case "#microsoft.graph.servicePrincipalIdentity":
                    return deserializeIntoServicePrincipalIdentity;
                case "#microsoft.graph.sharePointIdentity":
                    return deserializeIntoSharePointIdentity;
                case "#microsoft.graph.teamworkApplicationIdentity":
                    return deserializeIntoTeamworkApplicationIdentity;
                case "#microsoft.graph.teamworkConversationIdentity":
                    return deserializeIntoTeamworkConversationIdentity;
                case "#microsoft.graph.teamworkTagIdentity":
                    return deserializeIntoTeamworkTagIdentity;
                case "#microsoft.graph.teamworkUserIdentity":
                    return deserializeIntoTeamworkUserIdentity;
                case "#microsoft.graph.userIdentity":
                    return deserializeIntoUserIdentity;
            }
        }
    }
    return deserializeIntoIdentity;
}
export function deserializeIntoIdentity(identity: Identity | undefined = {} as Identity) : Record<string, (node: ParseNode) => void> {
    return {
        "displayName": n => { identity.displayName = n.getStringValue(); },
        "id": n => { identity.id = n.getStringValue(); },
        "@odata.type": n => { identity.odataType = n.getStringValue(); },
    }
}
export interface Identity extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The display name of the identity. The display name might not always be available or up to date. For example, if a user changes their display name, the API might show the new value in a future response, but the items associated with the user won't show up as having changed when using delta.
     */
    displayName?: string;
    /**
     * Unique identifier for the identity.
     */
    id?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export function serializeIdentity(writer: SerializationWriter, identity: Identity | undefined = {} as Identity) : void {
    writer.writeStringValue("displayName", identity.displayName);
    writer.writeStringValue("id", identity.id);
    writer.writeStringValue("@odata.type", identity.odataType);
    writer.writeAdditionalData(identity.additionalData);
}
// tslint:enable
// eslint-enable
