// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { createBookingCustomerInformationBaseFromDiscriminatorValue, serializeBookingCustomerInformationBase, type BookingCustomerInformationBase } from './bookingCustomerInformationBase';
import { BookingPriceType } from './bookingPriceType';
import { createBookingReminderFromDiscriminatorValue, serializeBookingReminder, type BookingReminder } from './bookingReminder';
import { createDateTimeTimeZoneFromDiscriminatorValue, serializeDateTimeTimeZone, type DateTimeTimeZone } from './dateTimeTimeZone';
import { deserializeIntoEntity, serializeEntity, type Entity } from './entity';
import { createLocationFromDiscriminatorValue, serializeLocation, type Location } from './location';
import { type Duration, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface BookingAppointment extends Entity, Parsable {
    /**
     * Additional information that is sent to the customer when an appointment is confirmed.
     */
    additionalInformation?: string;
    /**
     * The URL of the meeting to join anonymously.
     */
    anonymousJoinWebUrl?: string;
    /**
     * A collection of customer properties for an appointment. An appointment contains a list of customer information and each unit will indicate the properties of a customer who is part of that appointment. Optional.
     */
    customers?: BookingCustomerInformationBase[];
    /**
     * The time zone of the customer. For a list of possible values, see dateTimeTimeZone.
     */
    customerTimeZone?: string;
    /**
     * The length of the appointment, denoted in ISO8601 format.
     */
    duration?: Duration;
    /**
     * The endDateTime property
     */
    endDateTime?: DateTimeTimeZone;
    /**
     * The current number of customers in the appointment
     */
    filledAttendeesCount?: number;
    /**
     * If true, indicates that the appointment will be held online. Default value is false.
     */
    isLocationOnline?: boolean;
    /**
     * The URL of the online meeting for the appointment.
     */
    joinWebUrl?: string;
    /**
     * The maximum number of customers allowed in an appointment. If maximumAttendeesCount of the service is greater than 1, pass valid customer IDs while creating or updating an appointment. To create a customer, use the Create bookingCustomer operation.
     */
    maximumAttendeesCount?: number;
    /**
     * If true indicates that the bookingCustomer for this appointment doesn't wish to receive a confirmation for this appointment.
     */
    optOutOfCustomerEmail?: boolean;
    /**
     * The amount of time to reserve after the appointment ends, for cleaning up, as an example. The value is expressed in ISO8601 format.
     */
    postBuffer?: Duration;
    /**
     * The amount of time to reserve before the appointment begins, for preparation, as an example. The value is expressed in ISO8601 format.
     */
    preBuffer?: Duration;
    /**
     * The regular price for an appointment for the specified bookingService.
     */
    price?: number;
    /**
     * Represents the type of pricing of a booking service.
     */
    priceType?: BookingPriceType;
    /**
     * The collection of customer reminders sent for this appointment. The value of this property is available only when reading this bookingAppointment by its ID.
     */
    reminders?: BookingReminder[];
    /**
     * An additional tracking ID for the appointment, if the appointment has been created directly by the customer on the scheduling page, as opposed to by a staff member on the behalf of the customer. Only supported for appointment if maxAttendeeCount is 1.
     */
    selfServiceAppointmentId?: string;
    /**
     * The ID of the bookingService associated with this appointment.
     */
    serviceId?: string;
    /**
     * The location where the service is delivered.
     */
    serviceLocation?: Location;
    /**
     * The name of the bookingService associated with this appointment.This property is optional when creating a new appointment. If not specified, it's computed from the service associated with the appointment by the serviceId property.
     */
    serviceName?: string;
    /**
     * Notes from a bookingStaffMember. The value of this property is available only when reading this bookingAppointment by its ID.
     */
    serviceNotes?: string;
    /**
     * If true, indicates SMS notifications will be sent to the customers for the appointment. Default value is false.
     */
    smsNotificationsEnabled?: boolean;
    /**
     * The ID of each bookingStaffMember who is scheduled in this appointment.
     */
    staffMemberIds?: string[];
    /**
     * The startDateTime property
     */
    startDateTime?: DateTimeTimeZone;
}
export function createBookingAppointmentFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoBookingAppointment;
}
export function deserializeIntoBookingAppointment(bookingAppointment: BookingAppointment | undefined = {} as BookingAppointment) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(bookingAppointment),
        "additionalInformation": n => { bookingAppointment.additionalInformation = n.getStringValue(); },
        "anonymousJoinWebUrl": n => { bookingAppointment.anonymousJoinWebUrl = n.getStringValue(); },
        "customers": n => { bookingAppointment.customers = n.getCollectionOfObjectValues<BookingCustomerInformationBase>(createBookingCustomerInformationBaseFromDiscriminatorValue); },
        "customerTimeZone": n => { bookingAppointment.customerTimeZone = n.getStringValue(); },
        "duration": n => { bookingAppointment.duration = n.getDurationValue(); },
        "endDateTime": n => { bookingAppointment.endDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "filledAttendeesCount": n => { bookingAppointment.filledAttendeesCount = n.getNumberValue(); },
        "isLocationOnline": n => { bookingAppointment.isLocationOnline = n.getBooleanValue(); },
        "joinWebUrl": n => { bookingAppointment.joinWebUrl = n.getStringValue(); },
        "maximumAttendeesCount": n => { bookingAppointment.maximumAttendeesCount = n.getNumberValue(); },
        "optOutOfCustomerEmail": n => { bookingAppointment.optOutOfCustomerEmail = n.getBooleanValue(); },
        "postBuffer": n => { bookingAppointment.postBuffer = n.getDurationValue(); },
        "preBuffer": n => { bookingAppointment.preBuffer = n.getDurationValue(); },
        "price": n => { bookingAppointment.price = n.getNumberValue(); },
        "priceType": n => { bookingAppointment.priceType = n.getEnumValue<BookingPriceType>(BookingPriceType); },
        "reminders": n => { bookingAppointment.reminders = n.getCollectionOfObjectValues<BookingReminder>(createBookingReminderFromDiscriminatorValue); },
        "selfServiceAppointmentId": n => { bookingAppointment.selfServiceAppointmentId = n.getStringValue(); },
        "serviceId": n => { bookingAppointment.serviceId = n.getStringValue(); },
        "serviceLocation": n => { bookingAppointment.serviceLocation = n.getObjectValue<Location>(createLocationFromDiscriminatorValue); },
        "serviceName": n => { bookingAppointment.serviceName = n.getStringValue(); },
        "serviceNotes": n => { bookingAppointment.serviceNotes = n.getStringValue(); },
        "smsNotificationsEnabled": n => { bookingAppointment.smsNotificationsEnabled = n.getBooleanValue(); },
        "staffMemberIds": n => { bookingAppointment.staffMemberIds = n.getCollectionOfPrimitiveValues<string>(); },
        "startDateTime": n => { bookingAppointment.startDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
    }
}
export function serializeBookingAppointment(writer: SerializationWriter, bookingAppointment: BookingAppointment | undefined = {} as BookingAppointment) : void {
        serializeEntity(writer, bookingAppointment)
        writer.writeStringValue("additionalInformation", bookingAppointment.additionalInformation);
        writer.writeStringValue("anonymousJoinWebUrl", bookingAppointment.anonymousJoinWebUrl);
        writer.writeCollectionOfObjectValues<BookingCustomerInformationBase>("customers", bookingAppointment.customers, serializeBookingCustomerInformationBase);
        writer.writeStringValue("customerTimeZone", bookingAppointment.customerTimeZone);
        writer.writeObjectValue<DateTimeTimeZone>("endDateTime", bookingAppointment.endDateTime, serializeDateTimeTimeZone);
        writer.writeBooleanValue("isLocationOnline", bookingAppointment.isLocationOnline);
        writer.writeStringValue("joinWebUrl", bookingAppointment.joinWebUrl);
        writer.writeNumberValue("maximumAttendeesCount", bookingAppointment.maximumAttendeesCount);
        writer.writeBooleanValue("optOutOfCustomerEmail", bookingAppointment.optOutOfCustomerEmail);
        writer.writeDurationValue("postBuffer", bookingAppointment.postBuffer);
        writer.writeDurationValue("preBuffer", bookingAppointment.preBuffer);
        writer.writeNumberValue("price", bookingAppointment.price);
        writer.writeEnumValue<BookingPriceType>("priceType", bookingAppointment.priceType);
        writer.writeCollectionOfObjectValues<BookingReminder>("reminders", bookingAppointment.reminders, serializeBookingReminder);
        writer.writeStringValue("selfServiceAppointmentId", bookingAppointment.selfServiceAppointmentId);
        writer.writeStringValue("serviceId", bookingAppointment.serviceId);
        writer.writeObjectValue<Location>("serviceLocation", bookingAppointment.serviceLocation, serializeLocation);
        writer.writeStringValue("serviceName", bookingAppointment.serviceName);
        writer.writeStringValue("serviceNotes", bookingAppointment.serviceNotes);
        writer.writeBooleanValue("smsNotificationsEnabled", bookingAppointment.smsNotificationsEnabled);
        writer.writeCollectionOfPrimitiveValues<string>("staffMemberIds", bookingAppointment.staffMemberIds);
        writer.writeObjectValue<DateTimeTimeZone>("startDateTime", bookingAppointment.startDateTime, serializeDateTimeTimeZone);
}
// tslint:enable
// eslint-enable
