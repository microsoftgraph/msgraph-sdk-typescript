import { deserializeIntoActivityBasedTimeoutPolicy } from './activityBasedTimeoutPolicy';
import { deserializeIntoClaimsMappingPolicy } from './claimsMappingPolicy';
import { createDirectoryObjectFromDiscriminatorValue, serializeDirectoryObject, type DirectoryObject } from './directoryObject';
import { deserializeIntoHomeRealmDiscoveryPolicy } from './homeRealmDiscoveryPolicy';
import { type ActivityBasedTimeoutPolicy, type ClaimsMappingPolicy, type HomeRealmDiscoveryPolicy, type TokenIssuancePolicy, type TokenLifetimePolicy } from './index';
import { deserializeIntoPolicyBase, serializePolicyBase, type PolicyBase } from './policyBase';
import { deserializeIntoTokenIssuancePolicy } from './tokenIssuancePolicy';
import { deserializeIntoTokenLifetimePolicy } from './tokenLifetimePolicy';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function createStsPolicyFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.activityBasedTimeoutPolicy":
                    return deserializeIntoActivityBasedTimeoutPolicy;
                case "#microsoft.graph.claimsMappingPolicy":
                    return deserializeIntoClaimsMappingPolicy;
                case "#microsoft.graph.homeRealmDiscoveryPolicy":
                    return deserializeIntoHomeRealmDiscoveryPolicy;
                case "#microsoft.graph.tokenIssuancePolicy":
                    return deserializeIntoTokenIssuancePolicy;
                case "#microsoft.graph.tokenLifetimePolicy":
                    return deserializeIntoTokenLifetimePolicy;
            }
        }
    }
    return deserializeIntoStsPolicy;
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function deserializeIntoStsPolicy(stsPolicy: StsPolicy | undefined = {} as StsPolicy) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoPolicyBase(stsPolicy),
        "appliesTo": n => { stsPolicy.appliesTo = n.getCollectionOfObjectValues<DirectoryObject>(createDirectoryObjectFromDiscriminatorValue); },
        "definition": n => { stsPolicy.definition = n.getCollectionOfPrimitiveValues<string>(); },
        "isOrganizationDefault": n => { stsPolicy.isOrganizationDefault = n.getBooleanValue(); },
    }
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function serializeStsPolicy(writer: SerializationWriter, stsPolicy: StsPolicy | undefined = {} as StsPolicy) : void {
        serializePolicyBase(writer, stsPolicy)
        writer.writeCollectionOfObjectValues<DirectoryObject>("appliesTo", stsPolicy.appliesTo, );
        writer.writeCollectionOfPrimitiveValues<string>("definition", stsPolicy.definition);
        writer.writeBooleanValue("isOrganizationDefault", stsPolicy.isOrganizationDefault);
}
export interface StsPolicy extends Parsable, PolicyBase {
    /**
     * The appliesTo property
     */
    appliesTo?: DirectoryObject[];
    /**
     * A string collection containing a JSON string that defines the rules and settings for a policy. The syntax for the definition differs for each derived policy type. Required.
     */
    definition?: string[];
    /**
     * If set to true, activates this policy. There can be many policies for the same policy type, but only one can be activated as the organization default. Optional, default value is false.
     */
    isOrganizationDefault?: boolean;
}
