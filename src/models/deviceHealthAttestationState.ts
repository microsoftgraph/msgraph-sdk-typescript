import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function createDeviceHealthAttestationStateFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoDeviceHealthAttestationState;
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function deserializeIntoDeviceHealthAttestationState(deviceHealthAttestationState: DeviceHealthAttestationState | undefined = {} as DeviceHealthAttestationState) : Record<string, (node: ParseNode) => void> {
    return {
        "attestationIdentityKey": n => { deviceHealthAttestationState.attestationIdentityKey = n.getStringValue(); },
        "bitLockerStatus": n => { deviceHealthAttestationState.bitLockerStatus = n.getStringValue(); },
        "bootAppSecurityVersion": n => { deviceHealthAttestationState.bootAppSecurityVersion = n.getStringValue(); },
        "bootDebugging": n => { deviceHealthAttestationState.bootDebugging = n.getStringValue(); },
        "bootManagerSecurityVersion": n => { deviceHealthAttestationState.bootManagerSecurityVersion = n.getStringValue(); },
        "bootManagerVersion": n => { deviceHealthAttestationState.bootManagerVersion = n.getStringValue(); },
        "bootRevisionListInfo": n => { deviceHealthAttestationState.bootRevisionListInfo = n.getStringValue(); },
        "codeIntegrity": n => { deviceHealthAttestationState.codeIntegrity = n.getStringValue(); },
        "codeIntegrityCheckVersion": n => { deviceHealthAttestationState.codeIntegrityCheckVersion = n.getStringValue(); },
        "codeIntegrityPolicy": n => { deviceHealthAttestationState.codeIntegrityPolicy = n.getStringValue(); },
        "contentNamespaceUrl": n => { deviceHealthAttestationState.contentNamespaceUrl = n.getStringValue(); },
        "contentVersion": n => { deviceHealthAttestationState.contentVersion = n.getStringValue(); },
        "dataExcutionPolicy": n => { deviceHealthAttestationState.dataExcutionPolicy = n.getStringValue(); },
        "deviceHealthAttestationStatus": n => { deviceHealthAttestationState.deviceHealthAttestationStatus = n.getStringValue(); },
        "earlyLaunchAntiMalwareDriverProtection": n => { deviceHealthAttestationState.earlyLaunchAntiMalwareDriverProtection = n.getStringValue(); },
        "healthAttestationSupportedStatus": n => { deviceHealthAttestationState.healthAttestationSupportedStatus = n.getStringValue(); },
        "healthStatusMismatchInfo": n => { deviceHealthAttestationState.healthStatusMismatchInfo = n.getStringValue(); },
        "issuedDateTime": n => { deviceHealthAttestationState.issuedDateTime = n.getDateValue(); },
        "lastUpdateDateTime": n => { deviceHealthAttestationState.lastUpdateDateTime = n.getStringValue(); },
        "@odata.type": n => { deviceHealthAttestationState.odataType = n.getStringValue(); },
        "operatingSystemKernelDebugging": n => { deviceHealthAttestationState.operatingSystemKernelDebugging = n.getStringValue(); },
        "operatingSystemRevListInfo": n => { deviceHealthAttestationState.operatingSystemRevListInfo = n.getStringValue(); },
        "pcr0": n => { deviceHealthAttestationState.pcr0 = n.getStringValue(); },
        "pcrHashAlgorithm": n => { deviceHealthAttestationState.pcrHashAlgorithm = n.getStringValue(); },
        "resetCount": n => { deviceHealthAttestationState.resetCount = n.getNumberValue(); },
        "restartCount": n => { deviceHealthAttestationState.restartCount = n.getNumberValue(); },
        "safeMode": n => { deviceHealthAttestationState.safeMode = n.getStringValue(); },
        "secureBoot": n => { deviceHealthAttestationState.secureBoot = n.getStringValue(); },
        "secureBootConfigurationPolicyFingerPrint": n => { deviceHealthAttestationState.secureBootConfigurationPolicyFingerPrint = n.getStringValue(); },
        "testSigning": n => { deviceHealthAttestationState.testSigning = n.getStringValue(); },
        "tpmVersion": n => { deviceHealthAttestationState.tpmVersion = n.getStringValue(); },
        "virtualSecureMode": n => { deviceHealthAttestationState.virtualSecureMode = n.getStringValue(); },
        "windowsPE": n => { deviceHealthAttestationState.windowsPE = n.getStringValue(); },
    }
}
export interface DeviceHealthAttestationState extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * TWhen an Attestation Identity Key (AIK) is present on a device, it indicates that the device has an endorsement key (EK) certificate.
     */
    attestationIdentityKey?: string;
    /**
     * On or Off of BitLocker Drive Encryption
     */
    bitLockerStatus?: string;
    /**
     * The security version number of the Boot Application
     */
    bootAppSecurityVersion?: string;
    /**
     * When bootDebugging is enabled, the device is used in development and testing
     */
    bootDebugging?: string;
    /**
     * The security version number of the Boot Application
     */
    bootManagerSecurityVersion?: string;
    /**
     * The version of the Boot Manager
     */
    bootManagerVersion?: string;
    /**
     * The Boot Revision List that was loaded during initial boot on the attested device
     */
    bootRevisionListInfo?: string;
    /**
     * When code integrity is enabled, code execution is restricted to integrity verified code
     */
    codeIntegrity?: string;
    /**
     * The version of the Boot Manager
     */
    codeIntegrityCheckVersion?: string;
    /**
     * The Code Integrity policy that is controlling the security of the boot environment
     */
    codeIntegrityPolicy?: string;
    /**
     * The DHA report version. (Namespace version)
     */
    contentNamespaceUrl?: string;
    /**
     * The HealthAttestation state schema version
     */
    contentVersion?: string;
    /**
     * DEP Policy defines a set of hardware and software technologies that perform additional checks on memory
     */
    dataExcutionPolicy?: string;
    /**
     * The DHA report version. (Namespace version)
     */
    deviceHealthAttestationStatus?: string;
    /**
     * ELAM provides protection for the computers in your network when they start up
     */
    earlyLaunchAntiMalwareDriverProtection?: string;
    /**
     * This attribute indicates if DHA is supported for the device
     */
    healthAttestationSupportedStatus?: string;
    /**
     * This attribute appears if DHA-Service detects an integrity issue
     */
    healthStatusMismatchInfo?: string;
    /**
     * The DateTime when device was evaluated or issued to MDM
     */
    issuedDateTime?: Date;
    /**
     * The Timestamp of the last update.
     */
    lastUpdateDateTime?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * When operatingSystemKernelDebugging is enabled, the device is used in development and testing
     */
    operatingSystemKernelDebugging?: string;
    /**
     * The Operating System Revision List that was loaded during initial boot on the attested device
     */
    operatingSystemRevListInfo?: string;
    /**
     * The measurement that is captured in PCR[0]
     */
    pcr0?: string;
    /**
     * Informational attribute that identifies the HASH algorithm that was used by TPM
     */
    pcrHashAlgorithm?: string;
    /**
     * The number of times a PC device has hibernated or resumed
     */
    resetCount?: number;
    /**
     * The number of times a PC device has rebooted
     */
    restartCount?: number;
    /**
     * Safe mode is a troubleshooting option for Windows that starts your computer in a limited state
     */
    safeMode?: string;
    /**
     * When Secure Boot is enabled, the core components must have the correct cryptographic signatures
     */
    secureBoot?: string;
    /**
     * Fingerprint of the Custom Secure Boot Configuration Policy
     */
    secureBootConfigurationPolicyFingerPrint?: string;
    /**
     * When test signing is allowed, the device does not enforce signature validation during boot
     */
    testSigning?: string;
    /**
     * The security version number of the Boot Application
     */
    tpmVersion?: string;
    /**
     * VSM is a container that protects high value assets from a compromised kernel
     */
    virtualSecureMode?: string;
    /**
     * Operating system running with limited services that is used to prepare a computer for Windows
     */
    windowsPE?: string;
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function serializeDeviceHealthAttestationState(writer: SerializationWriter, deviceHealthAttestationState: DeviceHealthAttestationState | undefined = {} as DeviceHealthAttestationState) : void {
        writer.writeStringValue("attestationIdentityKey", deviceHealthAttestationState.attestationIdentityKey);
        writer.writeStringValue("bitLockerStatus", deviceHealthAttestationState.bitLockerStatus);
        writer.writeStringValue("bootAppSecurityVersion", deviceHealthAttestationState.bootAppSecurityVersion);
        writer.writeStringValue("bootDebugging", deviceHealthAttestationState.bootDebugging);
        writer.writeStringValue("bootManagerSecurityVersion", deviceHealthAttestationState.bootManagerSecurityVersion);
        writer.writeStringValue("bootManagerVersion", deviceHealthAttestationState.bootManagerVersion);
        writer.writeStringValue("bootRevisionListInfo", deviceHealthAttestationState.bootRevisionListInfo);
        writer.writeStringValue("codeIntegrity", deviceHealthAttestationState.codeIntegrity);
        writer.writeStringValue("codeIntegrityCheckVersion", deviceHealthAttestationState.codeIntegrityCheckVersion);
        writer.writeStringValue("codeIntegrityPolicy", deviceHealthAttestationState.codeIntegrityPolicy);
        writer.writeStringValue("contentNamespaceUrl", deviceHealthAttestationState.contentNamespaceUrl);
        writer.writeStringValue("contentVersion", deviceHealthAttestationState.contentVersion);
        writer.writeStringValue("dataExcutionPolicy", deviceHealthAttestationState.dataExcutionPolicy);
        writer.writeStringValue("deviceHealthAttestationStatus", deviceHealthAttestationState.deviceHealthAttestationStatus);
        writer.writeStringValue("earlyLaunchAntiMalwareDriverProtection", deviceHealthAttestationState.earlyLaunchAntiMalwareDriverProtection);
        writer.writeStringValue("healthAttestationSupportedStatus", deviceHealthAttestationState.healthAttestationSupportedStatus);
        writer.writeStringValue("healthStatusMismatchInfo", deviceHealthAttestationState.healthStatusMismatchInfo);
        writer.writeDateValue("issuedDateTime", deviceHealthAttestationState.issuedDateTime);
        writer.writeStringValue("lastUpdateDateTime", deviceHealthAttestationState.lastUpdateDateTime);
        writer.writeStringValue("@odata.type", deviceHealthAttestationState.odataType);
        writer.writeStringValue("operatingSystemKernelDebugging", deviceHealthAttestationState.operatingSystemKernelDebugging);
        writer.writeStringValue("operatingSystemRevListInfo", deviceHealthAttestationState.operatingSystemRevListInfo);
        writer.writeStringValue("pcr0", deviceHealthAttestationState.pcr0);
        writer.writeStringValue("pcrHashAlgorithm", deviceHealthAttestationState.pcrHashAlgorithm);
        writer.writeNumberValue("resetCount", deviceHealthAttestationState.resetCount);
        writer.writeNumberValue("restartCount", deviceHealthAttestationState.restartCount);
        writer.writeStringValue("safeMode", deviceHealthAttestationState.safeMode);
        writer.writeStringValue("secureBoot", deviceHealthAttestationState.secureBoot);
        writer.writeStringValue("secureBootConfigurationPolicyFingerPrint", deviceHealthAttestationState.secureBootConfigurationPolicyFingerPrint);
        writer.writeStringValue("testSigning", deviceHealthAttestationState.testSigning);
        writer.writeStringValue("tpmVersion", deviceHealthAttestationState.tpmVersion);
        writer.writeStringValue("virtualSecureMode", deviceHealthAttestationState.virtualSecureMode);
        writer.writeStringValue("windowsPE", deviceHealthAttestationState.windowsPE);
        writer.writeAdditionalData(deviceHealthAttestationState.additionalData);
}
