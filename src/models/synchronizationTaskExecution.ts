// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { createSynchronizationErrorFromDiscriminatorValue, serializeSynchronizationError, type SynchronizationError } from './synchronizationError';
import { SynchronizationTaskExecutionResult } from './synchronizationTaskExecutionResult';
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createSynchronizationTaskExecutionFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoSynchronizationTaskExecution;
}
export function deserializeIntoSynchronizationTaskExecution(synchronizationTaskExecution: SynchronizationTaskExecution | undefined = {} as SynchronizationTaskExecution) : Record<string, (node: ParseNode) => void> {
    return {
        "activityIdentifier": n => { synchronizationTaskExecution.activityIdentifier = n.getStringValue(); },
        "countEntitled": n => { synchronizationTaskExecution.countEntitled = n.getNumberValue(); },
        "countEntitledForProvisioning": n => { synchronizationTaskExecution.countEntitledForProvisioning = n.getNumberValue(); },
        "countEscrowed": n => { synchronizationTaskExecution.countEscrowed = n.getNumberValue(); },
        "countEscrowedRaw": n => { synchronizationTaskExecution.countEscrowedRaw = n.getNumberValue(); },
        "countExported": n => { synchronizationTaskExecution.countExported = n.getNumberValue(); },
        "countExports": n => { synchronizationTaskExecution.countExports = n.getNumberValue(); },
        "countImported": n => { synchronizationTaskExecution.countImported = n.getNumberValue(); },
        "countImportedDeltas": n => { synchronizationTaskExecution.countImportedDeltas = n.getNumberValue(); },
        "countImportedReferenceDeltas": n => { synchronizationTaskExecution.countImportedReferenceDeltas = n.getNumberValue(); },
        "error": n => { synchronizationTaskExecution.errorEscaped = n.getObjectValue<SynchronizationError>(createSynchronizationErrorFromDiscriminatorValue); },
        "@odata.type": n => { synchronizationTaskExecution.odataType = n.getStringValue(); },
        "state": n => { synchronizationTaskExecution.state = n.getEnumValue<SynchronizationTaskExecutionResult>(SynchronizationTaskExecutionResult); },
        "timeBegan": n => { synchronizationTaskExecution.timeBegan = n.getDateValue(); },
        "timeEnded": n => { synchronizationTaskExecution.timeEnded = n.getDateValue(); },
    }
}
export function serializeSynchronizationTaskExecution(writer: SerializationWriter, synchronizationTaskExecution: SynchronizationTaskExecution | undefined = {} as SynchronizationTaskExecution) : void {
        writer.writeStringValue("activityIdentifier", synchronizationTaskExecution.activityIdentifier);
        writer.writeNumberValue("countEntitled", synchronizationTaskExecution.countEntitled);
        writer.writeNumberValue("countEntitledForProvisioning", synchronizationTaskExecution.countEntitledForProvisioning);
        writer.writeNumberValue("countEscrowed", synchronizationTaskExecution.countEscrowed);
        writer.writeNumberValue("countEscrowedRaw", synchronizationTaskExecution.countEscrowedRaw);
        writer.writeNumberValue("countExported", synchronizationTaskExecution.countExported);
        writer.writeNumberValue("countExports", synchronizationTaskExecution.countExports);
        writer.writeNumberValue("countImported", synchronizationTaskExecution.countImported);
        writer.writeNumberValue("countImportedDeltas", synchronizationTaskExecution.countImportedDeltas);
        writer.writeNumberValue("countImportedReferenceDeltas", synchronizationTaskExecution.countImportedReferenceDeltas);
        writer.writeObjectValue<SynchronizationError>("error", synchronizationTaskExecution.errorEscaped, );
        writer.writeStringValue("@odata.type", synchronizationTaskExecution.odataType);
        writer.writeEnumValue<SynchronizationTaskExecutionResult>("state", synchronizationTaskExecution.state);
        writer.writeDateValue("timeBegan", synchronizationTaskExecution.timeBegan);
        writer.writeDateValue("timeEnded", synchronizationTaskExecution.timeEnded);
        writer.writeAdditionalData(synchronizationTaskExecution.additionalData);
}
export interface SynchronizationTaskExecution extends AdditionalDataHolder, Parsable {
    /**
     * Identifier of the job run.
     */
    activityIdentifier?: string;
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Count of processed entries that were assigned for this application.
     */
    countEntitled?: number;
    /**
     * Count of processed entries that were assigned for provisioning.
     */
    countEntitledForProvisioning?: number;
    /**
     * Count of entries that were escrowed (errors).
     */
    countEscrowed?: number;
    /**
     * Count of entries that were escrowed, including system-generated escrows.
     */
    countEscrowedRaw?: number;
    /**
     * Count of exported entries.
     */
    countExported?: number;
    /**
     * Count of entries that were expected to be exported.
     */
    countExports?: number;
    /**
     * Count of imported entries.
     */
    countImported?: number;
    /**
     * Count of imported delta-changes.
     */
    countImportedDeltas?: number;
    /**
     * Count of imported delta-changes pertaining to reference changes.
     */
    countImportedReferenceDeltas?: number;
    /**
     * If an error was encountered, contains a synchronizationError object with details.
     */
    errorEscaped?: SynchronizationError;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The state property
     */
    state?: SynchronizationTaskExecutionResult;
    /**
     * Time when this job run began. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    timeBegan?: Date;
    /**
     * Time when this job run ended. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    timeEnded?: Date;
}
// tslint:enable
// eslint-enable
