// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { deserializeIntoEntity, serializeEntity, type Entity } from '../entity';
import { createIdentitySetFromDiscriminatorValue, serializeIdentitySet, type IdentitySet } from '../identitySet';
import { createResultInfoFromDiscriminatorValue, serializeResultInfo, type ResultInfo } from '../resultInfo';
import { CaseAction } from './caseAction';
import { CaseOperationStatus } from './caseOperationStatus';
import { deserializeIntoEdiscoveryAddToReviewSetOperation } from './ediscoveryAddToReviewSetOperation';
import { deserializeIntoEdiscoveryEstimateOperation } from './ediscoveryEstimateOperation';
import { deserializeIntoEdiscoveryExportOperation } from './ediscoveryExportOperation';
import { deserializeIntoEdiscoveryHoldOperation } from './ediscoveryHoldOperation';
import { deserializeIntoEdiscoveryIndexOperation } from './ediscoveryIndexOperation';
import { deserializeIntoEdiscoveryPurgeDataOperation } from './ediscoveryPurgeDataOperation';
import { deserializeIntoEdiscoveryTagOperation } from './ediscoveryTagOperation';
import { type EdiscoveryAddToReviewSetOperation, type EdiscoveryEstimateOperation, type EdiscoveryExportOperation, type EdiscoveryHoldOperation, type EdiscoveryIndexOperation, type EdiscoveryPurgeDataOperation, type EdiscoveryTagOperation } from './index';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface CaseOperation extends Entity, Parsable {
    /**
     * The type of action the operation represents. Possible values are: addToReviewSet,applyTags,contentExport,convertToPdf,estimateStatistics, purgeData
     */
    action?: CaseAction;
    /**
     * The date and time the operation was completed.
     */
    completedDateTime?: Date;
    /**
     * The user that created the operation.
     */
    createdBy?: IdentitySet;
    /**
     * The date and time the operation was created.
     */
    createdDateTime?: Date;
    /**
     * The progress of the operation.
     */
    percentProgress?: number;
    /**
     * Contains success and failure-specific result information.
     */
    resultInfo?: ResultInfo;
    /**
     * The status of the case operation. Possible values are: notStarted, submissionFailed, running, succeeded, partiallySucceeded, failed.
     */
    status?: CaseOperationStatus;
}
export function createCaseOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.ediscoveryAddToReviewSetOperation":
                    return deserializeIntoEdiscoveryAddToReviewSetOperation;
                case "#microsoft.graph.security.ediscoveryEstimateOperation":
                    return deserializeIntoEdiscoveryEstimateOperation;
                case "#microsoft.graph.security.ediscoveryExportOperation":
                    return deserializeIntoEdiscoveryExportOperation;
                case "#microsoft.graph.security.ediscoveryHoldOperation":
                    return deserializeIntoEdiscoveryHoldOperation;
                case "#microsoft.graph.security.ediscoveryIndexOperation":
                    return deserializeIntoEdiscoveryIndexOperation;
                case "#microsoft.graph.security.ediscoveryPurgeDataOperation":
                    return deserializeIntoEdiscoveryPurgeDataOperation;
                case "#microsoft.graph.security.ediscoveryTagOperation":
                    return deserializeIntoEdiscoveryTagOperation;
            }
        }
    }
    return deserializeIntoCaseOperation;
}
export function deserializeIntoCaseOperation(caseOperation: CaseOperation | undefined = {} as CaseOperation) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(caseOperation),
        "action": n => { caseOperation.action = n.getEnumValue<CaseAction>(CaseAction); },
        "completedDateTime": n => { caseOperation.completedDateTime = n.getDateValue(); },
        "createdBy": n => { caseOperation.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { caseOperation.createdDateTime = n.getDateValue(); },
        "percentProgress": n => { caseOperation.percentProgress = n.getNumberValue(); },
        "resultInfo": n => { caseOperation.resultInfo = n.getObjectValue<ResultInfo>(createResultInfoFromDiscriminatorValue); },
        "status": n => { caseOperation.status = n.getEnumValue<CaseOperationStatus>(CaseOperationStatus); },
    }
}
export function serializeCaseOperation(writer: SerializationWriter, caseOperation: CaseOperation | undefined = {} as CaseOperation) : void {
    serializeEntity(writer, caseOperation)
    writer.writeEnumValue<CaseAction>("action", caseOperation.action);
    writer.writeDateValue("completedDateTime", caseOperation.completedDateTime);
    writer.writeObjectValue<IdentitySet>("createdBy", caseOperation.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", caseOperation.createdDateTime);
    writer.writeNumberValue("percentProgress", caseOperation.percentProgress);
    writer.writeObjectValue<ResultInfo>("resultInfo", caseOperation.resultInfo, serializeResultInfo);
    writer.writeEnumValue<CaseOperationStatus>("status", caseOperation.status);
}
// tslint:enable
// eslint-enable
