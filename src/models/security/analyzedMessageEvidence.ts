// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { deserializeIntoAlertEvidence, serializeAlertEvidence, type AlertEvidence } from './alertEvidence';
import { createEmailSenderFromDiscriminatorValue, serializeEmailSender, type EmailSender } from './emailSender';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface AnalyzedMessageEvidence extends AlertEvidence, Parsable {
    /**
     * Direction of the email relative to your network. The possible values are: inbound, outbound or intraorg.
     */
    antiSpamDirection?: string;
    /**
     * Number of attachments in the email.
     */
    attachmentsCount?: number;
    /**
     * Delivery action of the email. The possible values are: delivered, deliveredAsSpam, junked, blocked, or replaced.
     */
    deliveryAction?: string;
    /**
     * Location where the email was delivered. The possible values are: inbox, external, junkFolder, quarantine, failed, dropped, deletedFolder or forwarded.
     */
    deliveryLocation?: string;
    /**
     * Public-facing identifier for the email that is set by the sending email system.
     */
    internetMessageId?: string;
    /**
     * Detected language of the email content.
     */
    language?: string;
    /**
     * Unique identifier for the email, generated by Microsoft 365.
     */
    networkMessageId?: string;
    /**
     * The P1 sender.
     */
    p1Sender?: EmailSender;
    /**
     * The P2 sender.
     */
    p2Sender?: EmailSender;
    /**
     * Date and time when the email was received.
     */
    receivedDateTime?: Date;
    /**
     * Email address of the recipient, or email address of the recipient after distribution list expansion.
     */
    recipientEmailAddress?: string;
    /**
     * IP address of the last detected mail server that relayed the message.
     */
    senderIp?: string;
    /**
     * Subject of the email.
     */
    subject?: string;
    /**
     * Collection of methods used to detect malware, phishing, or other threats found in the email.
     */
    threatDetectionMethods?: string[];
    /**
     * Collection of detection names for malware or other threats found.
     */
    threats?: string[];
    /**
     * Number of embedded URLs in the email.
     */
    urlCount?: number;
    /**
     * Collection of the URLs contained in this email.
     */
    urls?: string[];
    /**
     * Uniform resource name (URN) of the automated investigation where the cluster was identified.
     */
    urn?: string;
}
export function createAnalyzedMessageEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoAnalyzedMessageEvidence;
}
export function deserializeIntoAnalyzedMessageEvidence(analyzedMessageEvidence: AnalyzedMessageEvidence | undefined = {} as AnalyzedMessageEvidence) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(analyzedMessageEvidence),
        "antiSpamDirection": n => { analyzedMessageEvidence.antiSpamDirection = n.getStringValue(); },
        "attachmentsCount": n => { analyzedMessageEvidence.attachmentsCount = n.getNumberValue(); },
        "deliveryAction": n => { analyzedMessageEvidence.deliveryAction = n.getStringValue(); },
        "deliveryLocation": n => { analyzedMessageEvidence.deliveryLocation = n.getStringValue(); },
        "internetMessageId": n => { analyzedMessageEvidence.internetMessageId = n.getStringValue(); },
        "language": n => { analyzedMessageEvidence.language = n.getStringValue(); },
        "networkMessageId": n => { analyzedMessageEvidence.networkMessageId = n.getStringValue(); },
        "p1Sender": n => { analyzedMessageEvidence.p1Sender = n.getObjectValue<EmailSender>(createEmailSenderFromDiscriminatorValue); },
        "p2Sender": n => { analyzedMessageEvidence.p2Sender = n.getObjectValue<EmailSender>(createEmailSenderFromDiscriminatorValue); },
        "receivedDateTime": n => { analyzedMessageEvidence.receivedDateTime = n.getDateValue(); },
        "recipientEmailAddress": n => { analyzedMessageEvidence.recipientEmailAddress = n.getStringValue(); },
        "senderIp": n => { analyzedMessageEvidence.senderIp = n.getStringValue(); },
        "subject": n => { analyzedMessageEvidence.subject = n.getStringValue(); },
        "threatDetectionMethods": n => { analyzedMessageEvidence.threatDetectionMethods = n.getCollectionOfPrimitiveValues<string>(); },
        "threats": n => { analyzedMessageEvidence.threats = n.getCollectionOfPrimitiveValues<string>(); },
        "urlCount": n => { analyzedMessageEvidence.urlCount = n.getNumberValue(); },
        "urls": n => { analyzedMessageEvidence.urls = n.getCollectionOfPrimitiveValues<string>(); },
        "urn": n => { analyzedMessageEvidence.urn = n.getStringValue(); },
    }
}
export function serializeAnalyzedMessageEvidence(writer: SerializationWriter, analyzedMessageEvidence: AnalyzedMessageEvidence | undefined = {} as AnalyzedMessageEvidence) : void {
    serializeAlertEvidence(writer, analyzedMessageEvidence)
    writer.writeStringValue("antiSpamDirection", analyzedMessageEvidence.antiSpamDirection);
    writer.writeNumberValue("attachmentsCount", analyzedMessageEvidence.attachmentsCount);
    writer.writeStringValue("deliveryAction", analyzedMessageEvidence.deliveryAction);
    writer.writeStringValue("deliveryLocation", analyzedMessageEvidence.deliveryLocation);
    writer.writeStringValue("internetMessageId", analyzedMessageEvidence.internetMessageId);
    writer.writeStringValue("language", analyzedMessageEvidence.language);
    writer.writeStringValue("networkMessageId", analyzedMessageEvidence.networkMessageId);
    writer.writeObjectValue<EmailSender>("p1Sender", analyzedMessageEvidence.p1Sender, serializeEmailSender);
    writer.writeObjectValue<EmailSender>("p2Sender", analyzedMessageEvidence.p2Sender, serializeEmailSender);
    writer.writeDateValue("receivedDateTime", analyzedMessageEvidence.receivedDateTime);
    writer.writeStringValue("recipientEmailAddress", analyzedMessageEvidence.recipientEmailAddress);
    writer.writeStringValue("senderIp", analyzedMessageEvidence.senderIp);
    writer.writeStringValue("subject", analyzedMessageEvidence.subject);
    writer.writeCollectionOfPrimitiveValues<string>("threatDetectionMethods", analyzedMessageEvidence.threatDetectionMethods);
    writer.writeCollectionOfPrimitiveValues<string>("threats", analyzedMessageEvidence.threats);
    writer.writeNumberValue("urlCount", analyzedMessageEvidence.urlCount);
    writer.writeCollectionOfPrimitiveValues<string>("urls", analyzedMessageEvidence.urls);
    writer.writeStringValue("urn", analyzedMessageEvidence.urn);
}
// tslint:enable
// eslint-enable
