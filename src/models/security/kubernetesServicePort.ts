// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { ContainerPortProtocol } from './containerPortProtocol';
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createKubernetesServicePortFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoKubernetesServicePort;
}
export function deserializeIntoKubernetesServicePort(kubernetesServicePort: KubernetesServicePort | undefined = {} as KubernetesServicePort) : Record<string, (node: ParseNode) => void> {
    return {
        "appProtocol": n => { kubernetesServicePort.appProtocol = n.getStringValue(); },
        "name": n => { kubernetesServicePort.name = n.getStringValue(); },
        "nodePort": n => { kubernetesServicePort.nodePort = n.getNumberValue(); },
        "@odata.type": n => { kubernetesServicePort.odataType = n.getStringValue(); },
        "port": n => { kubernetesServicePort.port = n.getNumberValue(); },
        "protocol": n => { kubernetesServicePort.protocol = n.getEnumValue<ContainerPortProtocol>(ContainerPortProtocol); },
        "targetPort": n => { kubernetesServicePort.targetPort = n.getStringValue(); },
    }
}
export interface KubernetesServicePort extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The application protocol for this port.
     */
    appProtocol?: string;
    /**
     * The name of this port within the service.
     */
    name?: string;
    /**
     * The port on each node on which this service is exposed when the type is either NodePort or LoadBalancer.
     */
    nodePort?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The port that this service exposes.
     */
    port?: number;
    /**
     * The protocol name. Possible values are: udp, tcp, sctp, unknownFutureValue.
     */
    protocol?: ContainerPortProtocol;
    /**
     * The name or number of the port to access on the pods targeted by the service. The port number must be in the range 1 to 65535. The name must be an IANASVCNAME.
     */
    targetPort?: string;
}
export function serializeKubernetesServicePort(writer: SerializationWriter, kubernetesServicePort: KubernetesServicePort | undefined = {} as KubernetesServicePort) : void {
    writer.writeStringValue("appProtocol", kubernetesServicePort.appProtocol);
    writer.writeStringValue("name", kubernetesServicePort.name);
    writer.writeNumberValue("nodePort", kubernetesServicePort.nodePort);
    writer.writeStringValue("@odata.type", kubernetesServicePort.odataType);
    writer.writeNumberValue("port", kubernetesServicePort.port);
    writer.writeEnumValue<ContainerPortProtocol>("protocol", kubernetesServicePort.protocol);
    writer.writeStringValue("targetPort", kubernetesServicePort.targetPort);
    writer.writeAdditionalData(kubernetesServicePort.additionalData);
}
// tslint:enable
// eslint-enable
