// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { deserializeIntoEntity, serializeEntity, type Entity } from '../entity';
import { createHostFromDiscriminatorValue, serializeHost, type Host } from './host';
import { createHostPortBannerFromDiscriminatorValue, serializeHostPortBanner, type HostPortBanner } from './hostPortBanner';
import { createHostPortComponentFromDiscriminatorValue, serializeHostPortComponent, type HostPortComponent } from './hostPortComponent';
import { HostPortProtocol } from './hostPortProtocol';
import { HostPortStatus } from './hostPortStatus';
import { createSslCertificateFromDiscriminatorValue, serializeSslCertificate, type SslCertificate } from './sslCertificate';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createHostPortFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoHostPort;
}
export function deserializeIntoHostPort(hostPort: HostPort | undefined = {} as HostPort) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(hostPort),
        "banners": n => { hostPort.banners = n.getCollectionOfObjectValues<HostPortBanner>(createHostPortBannerFromDiscriminatorValue); },
        "firstSeenDateTime": n => { hostPort.firstSeenDateTime = n.getDateValue(); },
        "host": n => { hostPort.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "lastScanDateTime": n => { hostPort.lastScanDateTime = n.getDateValue(); },
        "lastSeenDateTime": n => { hostPort.lastSeenDateTime = n.getDateValue(); },
        "mostRecentSslCertificate": n => { hostPort.mostRecentSslCertificate = n.getObjectValue<SslCertificate>(createSslCertificateFromDiscriminatorValue); },
        "port": n => { hostPort.port = n.getNumberValue(); },
        "protocol": n => { hostPort.protocol = n.getEnumValue<HostPortProtocol>(HostPortProtocol); },
        "services": n => { hostPort.services = n.getCollectionOfObjectValues<HostPortComponent>(createHostPortComponentFromDiscriminatorValue); },
        "status": n => { hostPort.status = n.getEnumValue<HostPortStatus>(HostPortStatus); },
        "timesObserved": n => { hostPort.timesObserved = n.getNumberValue(); },
    }
}
export interface HostPort extends Entity, Parsable {
    /**
     * The hostPortBanners retrieved from scanning the port.
     */
    banners?: HostPortBanner[];
    /**
     * The first date and time when Microsoft Defender Threat Intelligence observed the hostPort. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host property
     */
    host?: Host;
    /**
     * The last date and time when Microsoft Defender Threat Intelligence scanned the hostPort. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    lastScanDateTime?: Date;
    /**
     * The last date and time when Microsoft Defender Threat Intelligence observed the hostPort. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The most recent sslCertificate used to communicate on the port.
     */
    mostRecentSslCertificate?: SslCertificate;
    /**
     * The numerical identifier of the port which is standardized across the internet.
     */
    port?: number;
    /**
     * The general protocol used to scan the port. The possible values are: tcp, udp, unknownFutureValue.
     */
    protocol?: HostPortProtocol;
    /**
     * The hostPortComponents retrieved from scanning the port.
     */
    services?: HostPortComponent[];
    /**
     * The status of the port. The possible values are: open, filtered, closed, unknownFutureValue.
     */
    status?: HostPortStatus;
    /**
     * The total amount of times that Microsoft Defender Threat Intelligence has observed the hostPort in all its scans.
     */
    timesObserved?: number;
}
export function serializeHostPort(writer: SerializationWriter, hostPort: HostPort | undefined = {} as HostPort) : void {
        serializeEntity(writer, hostPort)
        writer.writeCollectionOfObjectValues<HostPortBanner>("banners", hostPort.banners, serializeHostPortBanner);
        writer.writeDateValue("firstSeenDateTime", hostPort.firstSeenDateTime);
        writer.writeObjectValue<Host>("host", hostPort.host, serializeHost);
        writer.writeDateValue("lastScanDateTime", hostPort.lastScanDateTime);
        writer.writeDateValue("lastSeenDateTime", hostPort.lastSeenDateTime);
        writer.writeObjectValue<SslCertificate>("mostRecentSslCertificate", hostPort.mostRecentSslCertificate, serializeSslCertificate);
        writer.writeNumberValue("port", hostPort.port);
        writer.writeEnumValue<HostPortProtocol>("protocol", hostPort.protocol);
        writer.writeCollectionOfObjectValues<HostPortComponent>("services", hostPort.services, serializeHostPortComponent);
        writer.writeEnumValue<HostPortStatus>("status", hostPort.status);
        writer.writeNumberValue("timesObserved", hostPort.timesObserved);
}
// tslint:enable
// eslint-enable
