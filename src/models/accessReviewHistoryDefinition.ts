// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { AccessReviewHistoryDecisionFilter } from './accessReviewHistoryDecisionFilter';
import { createAccessReviewHistoryInstanceFromDiscriminatorValue, serializeAccessReviewHistoryInstance, type AccessReviewHistoryInstance } from './accessReviewHistoryInstance';
import { createAccessReviewHistoryScheduleSettingsFromDiscriminatorValue, serializeAccessReviewHistoryScheduleSettings, type AccessReviewHistoryScheduleSettings } from './accessReviewHistoryScheduleSettings';
import { AccessReviewHistoryStatus } from './accessReviewHistoryStatus';
import { createAccessReviewScopeFromDiscriminatorValue, serializeAccessReviewScope, type AccessReviewScope } from './accessReviewScope';
import { deserializeIntoEntity, serializeEntity, type Entity } from './entity';
import { createUserIdentityFromDiscriminatorValue, serializeUserIdentity, type UserIdentity } from './userIdentity';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface AccessReviewHistoryDefinition extends Entity, Parsable {
    /**
     * The createdBy property
     */
    createdBy?: UserIdentity;
    /**
     * Timestamp when the access review definition was created.
     */
    createdDateTime?: Date;
    /**
     * Determines which review decisions will be included in the fetched review history data if specified. Optional on create. All decisions are included by default if no decisions are provided on create. Possible values are: approve, deny, dontKnow, notReviewed, and notNotified.
     */
    decisions?: AccessReviewHistoryDecisionFilter[];
    /**
     * Name for the access review history data collection. Required.
     */
    displayName?: string;
    /**
     * If the accessReviewHistoryDefinition is a recurring definition, instances represent each recurrence. A definition that doesn't recur will have exactly one instance.
     */
    instances?: AccessReviewHistoryInstance[];
    /**
     * A timestamp. Reviews ending on or before this date will be included in the fetched history data. Only required if scheduleSettings isn't defined.
     */
    reviewHistoryPeriodEndDateTime?: Date;
    /**
     * A timestamp. Reviews starting on or before this date will be included in the fetched history data. Only required if scheduleSettings isn't defined.
     */
    reviewHistoryPeriodStartDateTime?: Date;
    /**
     * The settings for a recurring access review history definition series. Only required if reviewHistoryPeriodStartDateTime or reviewHistoryPeriodEndDateTime aren't defined. Not supported yet.
     */
    scheduleSettings?: AccessReviewHistoryScheduleSettings;
    /**
     * Used to scope what reviews are included in the fetched history data. Fetches reviews whose scope matches with this provided scope. Required.
     */
    scopes?: AccessReviewScope[];
    /**
     * Represents the status of the review history data collection. The possible values are: done, inProgress, error, requested, unknownFutureValue.
     */
    status?: AccessReviewHistoryStatus;
}
export function createAccessReviewHistoryDefinitionFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoAccessReviewHistoryDefinition;
}
export function deserializeIntoAccessReviewHistoryDefinition(accessReviewHistoryDefinition: AccessReviewHistoryDefinition | undefined = {} as AccessReviewHistoryDefinition) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(accessReviewHistoryDefinition),
        "createdBy": n => { accessReviewHistoryDefinition.createdBy = n.getObjectValue<UserIdentity>(createUserIdentityFromDiscriminatorValue); },
        "createdDateTime": n => { accessReviewHistoryDefinition.createdDateTime = n.getDateValue(); },
        "decisions": n => { accessReviewHistoryDefinition.decisions = n.getCollectionOfEnumValues<AccessReviewHistoryDecisionFilter>(AccessReviewHistoryDecisionFilter); },
        "displayName": n => { accessReviewHistoryDefinition.displayName = n.getStringValue(); },
        "instances": n => { accessReviewHistoryDefinition.instances = n.getCollectionOfObjectValues<AccessReviewHistoryInstance>(createAccessReviewHistoryInstanceFromDiscriminatorValue); },
        "reviewHistoryPeriodEndDateTime": n => { accessReviewHistoryDefinition.reviewHistoryPeriodEndDateTime = n.getDateValue(); },
        "reviewHistoryPeriodStartDateTime": n => { accessReviewHistoryDefinition.reviewHistoryPeriodStartDateTime = n.getDateValue(); },
        "scheduleSettings": n => { accessReviewHistoryDefinition.scheduleSettings = n.getObjectValue<AccessReviewHistoryScheduleSettings>(createAccessReviewHistoryScheduleSettingsFromDiscriminatorValue); },
        "scopes": n => { accessReviewHistoryDefinition.scopes = n.getCollectionOfObjectValues<AccessReviewScope>(createAccessReviewScopeFromDiscriminatorValue); },
        "status": n => { accessReviewHistoryDefinition.status = n.getEnumValue<AccessReviewHistoryStatus>(AccessReviewHistoryStatus); },
    }
}
export function serializeAccessReviewHistoryDefinition(writer: SerializationWriter, accessReviewHistoryDefinition: AccessReviewHistoryDefinition | undefined = {} as AccessReviewHistoryDefinition) : void {
        serializeEntity(writer, accessReviewHistoryDefinition)
        writer.writeObjectValue<UserIdentity>("createdBy", accessReviewHistoryDefinition.createdBy, );
        writer.writeDateValue("createdDateTime", accessReviewHistoryDefinition.createdDateTime);
        if(accessReviewHistoryDefinition.decisions)
        writer.writeEnumValue<AccessReviewHistoryDecisionFilter>("decisions", ...accessReviewHistoryDefinition.decisions);
        writer.writeStringValue("displayName", accessReviewHistoryDefinition.displayName);
        writer.writeCollectionOfObjectValues<AccessReviewHistoryInstance>("instances", accessReviewHistoryDefinition.instances, );
        writer.writeDateValue("reviewHistoryPeriodEndDateTime", accessReviewHistoryDefinition.reviewHistoryPeriodEndDateTime);
        writer.writeDateValue("reviewHistoryPeriodStartDateTime", accessReviewHistoryDefinition.reviewHistoryPeriodStartDateTime);
        writer.writeObjectValue<AccessReviewHistoryScheduleSettings>("scheduleSettings", accessReviewHistoryDefinition.scheduleSettings, );
        writer.writeCollectionOfObjectValues<AccessReviewScope>("scopes", accessReviewHistoryDefinition.scopes, );
        writer.writeEnumValue<AccessReviewHistoryStatus>("status", accessReviewHistoryDefinition.status);
}
// tslint:enable
// eslint-enable
