// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createDeviceInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoDeviceInfo;
}
export function deserializeIntoDeviceInfo(deviceInfo: DeviceInfo | undefined = {} as DeviceInfo) : Record<string, (node: ParseNode) => void> {
    return {
        "captureDeviceDriver": n => { deviceInfo.captureDeviceDriver = n.getStringValue(); },
        "captureDeviceName": n => { deviceInfo.captureDeviceName = n.getStringValue(); },
        "captureNotFunctioningEventRatio": n => { deviceInfo.captureNotFunctioningEventRatio = n.getNumberValue(); },
        "cpuInsufficentEventRatio": n => { deviceInfo.cpuInsufficentEventRatio = n.getNumberValue(); },
        "deviceClippingEventRatio": n => { deviceInfo.deviceClippingEventRatio = n.getNumberValue(); },
        "deviceGlitchEventRatio": n => { deviceInfo.deviceGlitchEventRatio = n.getNumberValue(); },
        "howlingEventCount": n => { deviceInfo.howlingEventCount = n.getNumberValue(); },
        "initialSignalLevelRootMeanSquare": n => { deviceInfo.initialSignalLevelRootMeanSquare = n.getNumberValue(); },
        "lowSpeechLevelEventRatio": n => { deviceInfo.lowSpeechLevelEventRatio = n.getNumberValue(); },
        "lowSpeechToNoiseEventRatio": n => { deviceInfo.lowSpeechToNoiseEventRatio = n.getNumberValue(); },
        "micGlitchRate": n => { deviceInfo.micGlitchRate = n.getNumberValue(); },
        "@odata.type": n => { deviceInfo.odataType = n.getStringValue(); },
        "receivedNoiseLevel": n => { deviceInfo.receivedNoiseLevel = n.getNumberValue(); },
        "receivedSignalLevel": n => { deviceInfo.receivedSignalLevel = n.getNumberValue(); },
        "renderDeviceDriver": n => { deviceInfo.renderDeviceDriver = n.getStringValue(); },
        "renderDeviceName": n => { deviceInfo.renderDeviceName = n.getStringValue(); },
        "renderMuteEventRatio": n => { deviceInfo.renderMuteEventRatio = n.getNumberValue(); },
        "renderNotFunctioningEventRatio": n => { deviceInfo.renderNotFunctioningEventRatio = n.getNumberValue(); },
        "renderZeroVolumeEventRatio": n => { deviceInfo.renderZeroVolumeEventRatio = n.getNumberValue(); },
        "sentNoiseLevel": n => { deviceInfo.sentNoiseLevel = n.getNumberValue(); },
        "sentSignalLevel": n => { deviceInfo.sentSignalLevel = n.getNumberValue(); },
        "speakerGlitchRate": n => { deviceInfo.speakerGlitchRate = n.getNumberValue(); },
    }
}
export interface DeviceInfo extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Name of the capture device driver used by the media endpoint.
     */
    captureDeviceDriver?: string;
    /**
     * Name of the capture device used by the media endpoint.
     */
    captureDeviceName?: string;
    /**
     * Fraction of the call that the media endpoint detected the capture device was not working properly.
     */
    captureNotFunctioningEventRatio?: number;
    /**
     * Fraction of the call that the media endpoint detected the CPU resources available were insufficient and caused poor quality of the audio sent and received.
     */
    cpuInsufficentEventRatio?: number;
    /**
     * Fraction of the call that the media endpoint detected clipping in the captured audio that caused poor quality of the audio being sent.
     */
    deviceClippingEventRatio?: number;
    /**
     * Fraction of the call that the media endpoint detected glitches or gaps in the audio played or captured that caused poor quality of the audio being sent or received.
     */
    deviceGlitchEventRatio?: number;
    /**
     * Number of times during the call that the media endpoint detected howling or screeching audio.
     */
    howlingEventCount?: number;
    /**
     * The root mean square (RMS) of the incoming signal of up to the first 30 seconds of the call.
     */
    initialSignalLevelRootMeanSquare?: number;
    /**
     * Fraction of the call that the media endpoint detected low speech level that caused poor quality of the audio being sent.
     */
    lowSpeechLevelEventRatio?: number;
    /**
     * Fraction of the call that the media endpoint detected low speech to noise level that caused poor quality of the audio being sent.
     */
    lowSpeechToNoiseEventRatio?: number;
    /**
     * Glitches per 5 minute interval for the media endpoint's microphone.
     */
    micGlitchRate?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Average energy level of received audio for audio classified as mono noise or left channel of stereo noise by the media endpoint.
     */
    receivedNoiseLevel?: number;
    /**
     * Average energy level of received audio for audio classified as mono speech, or left channel of stereo speech by the media endpoint.
     */
    receivedSignalLevel?: number;
    /**
     * Name of the render device driver used by the media endpoint.
     */
    renderDeviceDriver?: string;
    /**
     * Name of the render device used by the media endpoint.
     */
    renderDeviceName?: string;
    /**
     * Fraction of the call that media endpoint detected device render is muted.
     */
    renderMuteEventRatio?: number;
    /**
     * Fraction of the call that the media endpoint detected the render device was not working properly.
     */
    renderNotFunctioningEventRatio?: number;
    /**
     * Fraction of the call that media endpoint detected device render volume is set to 0.
     */
    renderZeroVolumeEventRatio?: number;
    /**
     * Average energy level of sent audio for audio classified as mono noise or left channel of stereo noise by the media endpoint.
     */
    sentNoiseLevel?: number;
    /**
     * Average energy level of sent audio for audio classified as mono speech, or left channel of stereo speech by the media endpoint.
     */
    sentSignalLevel?: number;
    /**
     * Glitches per 5 minute internal for the media endpoint's loudspeaker.
     */
    speakerGlitchRate?: number;
}
export function serializeDeviceInfo(writer: SerializationWriter, deviceInfo: DeviceInfo | undefined = {} as DeviceInfo) : void {
    writer.writeStringValue("captureDeviceDriver", deviceInfo.captureDeviceDriver);
    writer.writeStringValue("captureDeviceName", deviceInfo.captureDeviceName);
    writer.writeNumberValue("captureNotFunctioningEventRatio", deviceInfo.captureNotFunctioningEventRatio);
    writer.writeNumberValue("cpuInsufficentEventRatio", deviceInfo.cpuInsufficentEventRatio);
    writer.writeNumberValue("deviceClippingEventRatio", deviceInfo.deviceClippingEventRatio);
    writer.writeNumberValue("deviceGlitchEventRatio", deviceInfo.deviceGlitchEventRatio);
    writer.writeNumberValue("howlingEventCount", deviceInfo.howlingEventCount);
    writer.writeNumberValue("initialSignalLevelRootMeanSquare", deviceInfo.initialSignalLevelRootMeanSquare);
    writer.writeNumberValue("lowSpeechLevelEventRatio", deviceInfo.lowSpeechLevelEventRatio);
    writer.writeNumberValue("lowSpeechToNoiseEventRatio", deviceInfo.lowSpeechToNoiseEventRatio);
    writer.writeNumberValue("micGlitchRate", deviceInfo.micGlitchRate);
    writer.writeStringValue("@odata.type", deviceInfo.odataType);
    writer.writeNumberValue("receivedNoiseLevel", deviceInfo.receivedNoiseLevel);
    writer.writeNumberValue("receivedSignalLevel", deviceInfo.receivedSignalLevel);
    writer.writeStringValue("renderDeviceDriver", deviceInfo.renderDeviceDriver);
    writer.writeStringValue("renderDeviceName", deviceInfo.renderDeviceName);
    writer.writeNumberValue("renderMuteEventRatio", deviceInfo.renderMuteEventRatio);
    writer.writeNumberValue("renderNotFunctioningEventRatio", deviceInfo.renderNotFunctioningEventRatio);
    writer.writeNumberValue("renderZeroVolumeEventRatio", deviceInfo.renderZeroVolumeEventRatio);
    writer.writeNumberValue("sentNoiseLevel", deviceInfo.sentNoiseLevel);
    writer.writeNumberValue("sentSignalLevel", deviceInfo.sentSignalLevel);
    writer.writeNumberValue("speakerGlitchRate", deviceInfo.speakerGlitchRate);
    writer.writeAdditionalData(deviceInfo.additionalData);
}
// tslint:enable
// eslint-enable
