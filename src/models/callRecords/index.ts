// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { createIdentitySetFromDiscriminatorValue, deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, serializeBaseCollectionPaginationCountResponse, serializeEntity, serializeIdentitySet, type BaseCollectionPaginationCountResponse, type Entity, type IdentitySet } from '../';
import { type AdditionalDataHolder, type Duration, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export enum AudioCodec {
    Unknown = "unknown",
    Invalid = "invalid",
    Cn = "cn",
    Pcma = "pcma",
    Pcmu = "pcmu",
    AmrWide = "amrWide",
    G722 = "g722",
    G7221 = "g7221",
    G7221c = "g7221c",
    G729 = "g729",
    MultiChannelAudio = "multiChannelAudio",
    Muchv2 = "muchv2",
    Opus = "opus",
    Satin = "satin",
    SatinFullband = "satinFullband",
    RtAudio8 = "rtAudio8",
    RtAudio16 = "rtAudio16",
    Silk = "silk",
    SilkNarrow = "silkNarrow",
    SilkWide = "silkWide",
    Siren = "siren",
    XmsRta = "xmsRta",
    UnknownFutureValue = "unknownFutureValue",
}
export interface CallRecord extends Entity, Parsable {
    /**
     * UTC time when the last user left the call. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    endDateTime?: Date;
    /**
     * Meeting URL associated to the call. May not be available for a peerToPeer call record type.
     */
    joinWebUrl?: string;
    /**
     * UTC time when the call record was created. The DatetimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    lastModifiedDateTime?: Date;
    /**
     * List of all the modalities used in the call. Possible values are: unknown, audio, video, videoBasedScreenSharing, data, screenSharing, unknownFutureValue.
     */
    modalities?: Modality[];
    /**
     * The organizing party's identity.
     */
    organizer?: IdentitySet;
    /**
     * List of distinct identities involved in the call.
     */
    participants?: IdentitySet[];
    /**
     * List of sessions involved in the call. Peer-to-peer calls typically only have one session, whereas group calls typically have at least one session per participant. Read-only. Nullable.
     */
    sessions?: Session[];
    /**
     * UTC time when the first user joined the call. The DatetimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    startDateTime?: Date;
    /**
     * The type property
     */
    type?: CallType;
    /**
     * Monotonically increasing version of the call record. Higher version call records with the same id includes additional data compared to the lower version.
     */
    version?: number;
}
export interface CallRecordCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: CallRecord[];
}
export enum CallType {
    Unknown = "unknown",
    GroupCall = "groupCall",
    PeerToPeer = "peerToPeer",
    UnknownFutureValue = "unknownFutureValue",
}
export enum ClientPlatform {
    Unknown = "unknown",
    Windows = "windows",
    MacOS = "macOS",
    IOS = "iOS",
    Android = "android",
    Web = "web",
    IpPhone = "ipPhone",
    RoomSystem = "roomSystem",
    SurfaceHub = "surfaceHub",
    HoloLens = "holoLens",
    UnknownFutureValue = "unknownFutureValue",
}
export interface ClientUserAgent extends Parsable, UserAgent {
    /**
     * The unique identifier of the Microsoft Entra application used by this endpoint.
     */
    azureADAppId?: string;
    /**
     * Immutable resource identifier of the Azure Communication Service associated with this endpoint based on Communication Services APIs.
     */
    communicationServiceId?: string;
    /**
     * The platform property
     */
    platform?: ClientPlatform;
    /**
     * The productFamily property
     */
    productFamily?: ProductFamily;
}
export function createCallRecordCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoCallRecordCollectionResponse;
}
export function createCallRecordFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoCallRecord;
}
export function createClientUserAgentFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoClientUserAgent;
}
export function createDeviceInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoDeviceInfo;
}
export function createDirectRoutingLogRowFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoDirectRoutingLogRow;
}
export function createEndpointFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.callRecords.participantEndpoint":
                    return deserializeIntoParticipantEndpoint;
                case "#microsoft.graph.callRecords.serviceEndpoint":
                    return deserializeIntoServiceEndpoint;
            }
        }
    }
    return deserializeIntoEndpoint;
}
export function createFailureInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoFailureInfo;
}
export function createFeedbackTokenSetFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoFeedbackTokenSet;
}
export function createMediaFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoMedia;
}
export function createMediaStreamFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoMediaStream;
}
export function createNetworkInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoNetworkInfo;
}
export function createParticipantEndpointFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoParticipantEndpoint;
}
export function createPstnCallLogRowFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoPstnCallLogRow;
}
export function createSegmentCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoSegmentCollectionResponse;
}
export function createSegmentFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoSegment;
}
export function createServiceEndpointFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoServiceEndpoint;
}
export function createServiceUserAgentFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoServiceUserAgent;
}
export function createSessionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoSessionCollectionResponse;
}
export function createSessionFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoSession;
}
export function createTraceRouteHopFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoTraceRouteHop;
}
export function createUserAgentFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.callRecords.clientUserAgent":
                    return deserializeIntoClientUserAgent;
                case "#microsoft.graph.callRecords.serviceUserAgent":
                    return deserializeIntoServiceUserAgent;
            }
        }
    }
    return deserializeIntoUserAgent;
}
export function createUserFeedbackFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoUserFeedback;
}
export function deserializeIntoCallRecord(callRecord: CallRecord | undefined = {} as CallRecord) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(callRecord),
        "endDateTime": n => { callRecord.endDateTime = n.getDateValue(); },
        "joinWebUrl": n => { callRecord.joinWebUrl = n.getStringValue(); },
        "lastModifiedDateTime": n => { callRecord.lastModifiedDateTime = n.getDateValue(); },
        "modalities": n => { callRecord.modalities = n.getCollectionOfEnumValues<Modality>(Modality); },
        "organizer": n => { callRecord.organizer = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "participants": n => { callRecord.participants = n.getCollectionOfObjectValues<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "sessions": n => { callRecord.sessions = n.getCollectionOfObjectValues<Session>(createSessionFromDiscriminatorValue); },
        "startDateTime": n => { callRecord.startDateTime = n.getDateValue(); },
        "type": n => { callRecord.type = n.getEnumValue<CallType>(CallType); },
        "version": n => { callRecord.version = n.getNumberValue(); },
    }
}
export function deserializeIntoCallRecordCollectionResponse(callRecordCollectionResponse: CallRecordCollectionResponse | undefined = {} as CallRecordCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(callRecordCollectionResponse),
        "value": n => { callRecordCollectionResponse.value = n.getCollectionOfObjectValues<CallRecord>(createCallRecordFromDiscriminatorValue); },
    }
}
export function deserializeIntoClientUserAgent(clientUserAgent: ClientUserAgent | undefined = {} as ClientUserAgent) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoUserAgent(clientUserAgent),
        "azureADAppId": n => { clientUserAgent.azureADAppId = n.getStringValue(); },
        "communicationServiceId": n => { clientUserAgent.communicationServiceId = n.getStringValue(); },
        "platform": n => { clientUserAgent.platform = n.getEnumValue<ClientPlatform>(ClientPlatform); },
        "productFamily": n => { clientUserAgent.productFamily = n.getEnumValue<ProductFamily>(ProductFamily); },
    }
}
export function deserializeIntoDeviceInfo(deviceInfo: DeviceInfo | undefined = {} as DeviceInfo) : Record<string, (node: ParseNode) => void> {
    return {
        "captureDeviceDriver": n => { deviceInfo.captureDeviceDriver = n.getStringValue(); },
        "captureDeviceName": n => { deviceInfo.captureDeviceName = n.getStringValue(); },
        "captureNotFunctioningEventRatio": n => { deviceInfo.captureNotFunctioningEventRatio = n.getNumberValue(); },
        "cpuInsufficentEventRatio": n => { deviceInfo.cpuInsufficentEventRatio = n.getNumberValue(); },
        "deviceClippingEventRatio": n => { deviceInfo.deviceClippingEventRatio = n.getNumberValue(); },
        "deviceGlitchEventRatio": n => { deviceInfo.deviceGlitchEventRatio = n.getNumberValue(); },
        "howlingEventCount": n => { deviceInfo.howlingEventCount = n.getNumberValue(); },
        "initialSignalLevelRootMeanSquare": n => { deviceInfo.initialSignalLevelRootMeanSquare = n.getNumberValue(); },
        "lowSpeechLevelEventRatio": n => { deviceInfo.lowSpeechLevelEventRatio = n.getNumberValue(); },
        "lowSpeechToNoiseEventRatio": n => { deviceInfo.lowSpeechToNoiseEventRatio = n.getNumberValue(); },
        "micGlitchRate": n => { deviceInfo.micGlitchRate = n.getNumberValue(); },
        "@odata.type": n => { deviceInfo.odataType = n.getStringValue(); },
        "receivedNoiseLevel": n => { deviceInfo.receivedNoiseLevel = n.getNumberValue(); },
        "receivedSignalLevel": n => { deviceInfo.receivedSignalLevel = n.getNumberValue(); },
        "renderDeviceDriver": n => { deviceInfo.renderDeviceDriver = n.getStringValue(); },
        "renderDeviceName": n => { deviceInfo.renderDeviceName = n.getStringValue(); },
        "renderMuteEventRatio": n => { deviceInfo.renderMuteEventRatio = n.getNumberValue(); },
        "renderNotFunctioningEventRatio": n => { deviceInfo.renderNotFunctioningEventRatio = n.getNumberValue(); },
        "renderZeroVolumeEventRatio": n => { deviceInfo.renderZeroVolumeEventRatio = n.getNumberValue(); },
        "sentNoiseLevel": n => { deviceInfo.sentNoiseLevel = n.getNumberValue(); },
        "sentSignalLevel": n => { deviceInfo.sentSignalLevel = n.getNumberValue(); },
        "speakerGlitchRate": n => { deviceInfo.speakerGlitchRate = n.getNumberValue(); },
    }
}
export function deserializeIntoDirectRoutingLogRow(directRoutingLogRow: DirectRoutingLogRow | undefined = {} as DirectRoutingLogRow) : Record<string, (node: ParseNode) => void> {
    return {
        "calleeNumber": n => { directRoutingLogRow.calleeNumber = n.getStringValue(); },
        "callEndSubReason": n => { directRoutingLogRow.callEndSubReason = n.getNumberValue(); },
        "callerNumber": n => { directRoutingLogRow.callerNumber = n.getStringValue(); },
        "callType": n => { directRoutingLogRow.callType = n.getStringValue(); },
        "correlationId": n => { directRoutingLogRow.correlationId = n.getStringValue(); },
        "duration": n => { directRoutingLogRow.duration = n.getNumberValue(); },
        "endDateTime": n => { directRoutingLogRow.endDateTime = n.getDateValue(); },
        "failureDateTime": n => { directRoutingLogRow.failureDateTime = n.getDateValue(); },
        "finalSipCode": n => { directRoutingLogRow.finalSipCode = n.getNumberValue(); },
        "finalSipCodePhrase": n => { directRoutingLogRow.finalSipCodePhrase = n.getStringValue(); },
        "id": n => { directRoutingLogRow.id = n.getStringValue(); },
        "inviteDateTime": n => { directRoutingLogRow.inviteDateTime = n.getDateValue(); },
        "mediaBypassEnabled": n => { directRoutingLogRow.mediaBypassEnabled = n.getBooleanValue(); },
        "mediaPathLocation": n => { directRoutingLogRow.mediaPathLocation = n.getStringValue(); },
        "@odata.type": n => { directRoutingLogRow.odataType = n.getStringValue(); },
        "signalingLocation": n => { directRoutingLogRow.signalingLocation = n.getStringValue(); },
        "startDateTime": n => { directRoutingLogRow.startDateTime = n.getDateValue(); },
        "successfulCall": n => { directRoutingLogRow.successfulCall = n.getBooleanValue(); },
        "trunkFullyQualifiedDomainName": n => { directRoutingLogRow.trunkFullyQualifiedDomainName = n.getStringValue(); },
        "userDisplayName": n => { directRoutingLogRow.userDisplayName = n.getStringValue(); },
        "userId": n => { directRoutingLogRow.userId = n.getStringValue(); },
        "userPrincipalName": n => { directRoutingLogRow.userPrincipalName = n.getStringValue(); },
    }
}
export function deserializeIntoEndpoint(endpoint: Endpoint | undefined = {} as Endpoint) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.type": n => { endpoint.odataType = n.getStringValue(); },
        "userAgent": n => { endpoint.userAgent = n.getObjectValue<UserAgent>(createUserAgentFromDiscriminatorValue); },
    }
}
export function deserializeIntoFailureInfo(failureInfo: FailureInfo | undefined = {} as FailureInfo) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.type": n => { failureInfo.odataType = n.getStringValue(); },
        "reason": n => { failureInfo.reason = n.getStringValue(); },
        "stage": n => { failureInfo.stage = n.getEnumValue<FailureStage>(FailureStage); },
    }
}
export function deserializeIntoFeedbackTokenSet(feedbackTokenSet: FeedbackTokenSet | undefined = {} as FeedbackTokenSet) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.type": n => { feedbackTokenSet.odataType = n.getStringValue(); },
    }
}
export function deserializeIntoMedia(media: Media | undefined = {} as Media) : Record<string, (node: ParseNode) => void> {
    return {
        "calleeDevice": n => { media.calleeDevice = n.getObjectValue<DeviceInfo>(createDeviceInfoFromDiscriminatorValue); },
        "calleeNetwork": n => { media.calleeNetwork = n.getObjectValue<NetworkInfo>(createNetworkInfoFromDiscriminatorValue); },
        "callerDevice": n => { media.callerDevice = n.getObjectValue<DeviceInfo>(createDeviceInfoFromDiscriminatorValue); },
        "callerNetwork": n => { media.callerNetwork = n.getObjectValue<NetworkInfo>(createNetworkInfoFromDiscriminatorValue); },
        "label": n => { media.label = n.getStringValue(); },
        "@odata.type": n => { media.odataType = n.getStringValue(); },
        "streams": n => { media.streams = n.getCollectionOfObjectValues<MediaStream>(createMediaStreamFromDiscriminatorValue); },
    }
}
export function deserializeIntoMediaStream(mediaStream: MediaStream | undefined = {} as MediaStream) : Record<string, (node: ParseNode) => void> {
    return {
        "audioCodec": n => { mediaStream.audioCodec = n.getEnumValue<AudioCodec>(AudioCodec); },
        "averageAudioDegradation": n => { mediaStream.averageAudioDegradation = n.getNumberValue(); },
        "averageAudioNetworkJitter": n => { mediaStream.averageAudioNetworkJitter = n.getDurationValue(); },
        "averageBandwidthEstimate": n => { mediaStream.averageBandwidthEstimate = n.getNumberValue(); },
        "averageFreezeDuration": n => { mediaStream.averageFreezeDuration = n.getDurationValue(); },
        "averageJitter": n => { mediaStream.averageJitter = n.getDurationValue(); },
        "averagePacketLossRate": n => { mediaStream.averagePacketLossRate = n.getNumberValue(); },
        "averageRatioOfConcealedSamples": n => { mediaStream.averageRatioOfConcealedSamples = n.getNumberValue(); },
        "averageReceivedFrameRate": n => { mediaStream.averageReceivedFrameRate = n.getNumberValue(); },
        "averageRoundTripTime": n => { mediaStream.averageRoundTripTime = n.getDurationValue(); },
        "averageVideoFrameLossPercentage": n => { mediaStream.averageVideoFrameLossPercentage = n.getNumberValue(); },
        "averageVideoFrameRate": n => { mediaStream.averageVideoFrameRate = n.getNumberValue(); },
        "averageVideoPacketLossRate": n => { mediaStream.averageVideoPacketLossRate = n.getNumberValue(); },
        "endDateTime": n => { mediaStream.endDateTime = n.getDateValue(); },
        "isAudioForwardErrorCorrectionUsed": n => { mediaStream.isAudioForwardErrorCorrectionUsed = n.getBooleanValue(); },
        "lowFrameRateRatio": n => { mediaStream.lowFrameRateRatio = n.getNumberValue(); },
        "lowVideoProcessingCapabilityRatio": n => { mediaStream.lowVideoProcessingCapabilityRatio = n.getNumberValue(); },
        "maxAudioNetworkJitter": n => { mediaStream.maxAudioNetworkJitter = n.getDurationValue(); },
        "maxJitter": n => { mediaStream.maxJitter = n.getDurationValue(); },
        "maxPacketLossRate": n => { mediaStream.maxPacketLossRate = n.getNumberValue(); },
        "maxRatioOfConcealedSamples": n => { mediaStream.maxRatioOfConcealedSamples = n.getNumberValue(); },
        "maxRoundTripTime": n => { mediaStream.maxRoundTripTime = n.getDurationValue(); },
        "@odata.type": n => { mediaStream.odataType = n.getStringValue(); },
        "packetUtilization": n => { mediaStream.packetUtilization = n.getNumberValue(); },
        "postForwardErrorCorrectionPacketLossRate": n => { mediaStream.postForwardErrorCorrectionPacketLossRate = n.getNumberValue(); },
        "rmsFreezeDuration": n => { mediaStream.rmsFreezeDuration = n.getDurationValue(); },
        "startDateTime": n => { mediaStream.startDateTime = n.getDateValue(); },
        "streamDirection": n => { mediaStream.streamDirection = n.getEnumValue<MediaStreamDirection>(MediaStreamDirection); },
        "streamId": n => { mediaStream.streamId = n.getStringValue(); },
        "videoCodec": n => { mediaStream.videoCodec = n.getEnumValue<VideoCodec>(VideoCodec); },
        "wasMediaBypassed": n => { mediaStream.wasMediaBypassed = n.getBooleanValue(); },
    }
}
export function deserializeIntoNetworkInfo(networkInfo: NetworkInfo | undefined = {} as NetworkInfo) : Record<string, (node: ParseNode) => void> {
    return {
        "bandwidthLowEventRatio": n => { networkInfo.bandwidthLowEventRatio = n.getNumberValue(); },
        "basicServiceSetIdentifier": n => { networkInfo.basicServiceSetIdentifier = n.getStringValue(); },
        "connectionType": n => { networkInfo.connectionType = n.getEnumValue<NetworkConnectionType>(NetworkConnectionType); },
        "delayEventRatio": n => { networkInfo.delayEventRatio = n.getNumberValue(); },
        "dnsSuffix": n => { networkInfo.dnsSuffix = n.getStringValue(); },
        "ipAddress": n => { networkInfo.ipAddress = n.getStringValue(); },
        "linkSpeed": n => { networkInfo.linkSpeed = n.getNumberValue(); },
        "macAddress": n => { networkInfo.macAddress = n.getStringValue(); },
        "networkTransportProtocol": n => { networkInfo.networkTransportProtocol = n.getEnumValue<NetworkTransportProtocol>(NetworkTransportProtocol); },
        "@odata.type": n => { networkInfo.odataType = n.getStringValue(); },
        "port": n => { networkInfo.port = n.getNumberValue(); },
        "receivedQualityEventRatio": n => { networkInfo.receivedQualityEventRatio = n.getNumberValue(); },
        "reflexiveIPAddress": n => { networkInfo.reflexiveIPAddress = n.getStringValue(); },
        "relayIPAddress": n => { networkInfo.relayIPAddress = n.getStringValue(); },
        "relayPort": n => { networkInfo.relayPort = n.getNumberValue(); },
        "sentQualityEventRatio": n => { networkInfo.sentQualityEventRatio = n.getNumberValue(); },
        "subnet": n => { networkInfo.subnet = n.getStringValue(); },
        "traceRouteHops": n => { networkInfo.traceRouteHops = n.getCollectionOfObjectValues<TraceRouteHop>(createTraceRouteHopFromDiscriminatorValue); },
        "wifiBand": n => { networkInfo.wifiBand = n.getEnumValue<WifiBand>(WifiBand); },
        "wifiBatteryCharge": n => { networkInfo.wifiBatteryCharge = n.getNumberValue(); },
        "wifiChannel": n => { networkInfo.wifiChannel = n.getNumberValue(); },
        "wifiMicrosoftDriver": n => { networkInfo.wifiMicrosoftDriver = n.getStringValue(); },
        "wifiMicrosoftDriverVersion": n => { networkInfo.wifiMicrosoftDriverVersion = n.getStringValue(); },
        "wifiRadioType": n => { networkInfo.wifiRadioType = n.getEnumValue<WifiRadioType>(WifiRadioType); },
        "wifiSignalStrength": n => { networkInfo.wifiSignalStrength = n.getNumberValue(); },
        "wifiVendorDriver": n => { networkInfo.wifiVendorDriver = n.getStringValue(); },
        "wifiVendorDriverVersion": n => { networkInfo.wifiVendorDriverVersion = n.getStringValue(); },
    }
}
export function deserializeIntoParticipantEndpoint(participantEndpoint: ParticipantEndpoint | undefined = {} as ParticipantEndpoint) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEndpoint(participantEndpoint),
        "cpuCoresCount": n => { participantEndpoint.cpuCoresCount = n.getNumberValue(); },
        "cpuName": n => { participantEndpoint.cpuName = n.getStringValue(); },
        "cpuProcessorSpeedInMhz": n => { participantEndpoint.cpuProcessorSpeedInMhz = n.getNumberValue(); },
        "feedback": n => { participantEndpoint.feedback = n.getObjectValue<UserFeedback>(createUserFeedbackFromDiscriminatorValue); },
        "identity": n => { participantEndpoint.identity = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "name": n => { participantEndpoint.name = n.getStringValue(); },
    }
}
export function deserializeIntoPstnCallLogRow(pstnCallLogRow: PstnCallLogRow | undefined = {} as PstnCallLogRow) : Record<string, (node: ParseNode) => void> {
    return {
        "callDurationSource": n => { pstnCallLogRow.callDurationSource = n.getEnumValue<PstnCallDurationSource>(PstnCallDurationSource); },
        "calleeNumber": n => { pstnCallLogRow.calleeNumber = n.getStringValue(); },
        "callerNumber": n => { pstnCallLogRow.callerNumber = n.getStringValue(); },
        "callId": n => { pstnCallLogRow.callId = n.getStringValue(); },
        "callType": n => { pstnCallLogRow.callType = n.getStringValue(); },
        "charge": n => { pstnCallLogRow.charge = n.getNumberValue(); },
        "conferenceId": n => { pstnCallLogRow.conferenceId = n.getStringValue(); },
        "connectionCharge": n => { pstnCallLogRow.connectionCharge = n.getNumberValue(); },
        "currency": n => { pstnCallLogRow.currency = n.getStringValue(); },
        "destinationContext": n => { pstnCallLogRow.destinationContext = n.getStringValue(); },
        "destinationName": n => { pstnCallLogRow.destinationName = n.getStringValue(); },
        "duration": n => { pstnCallLogRow.duration = n.getNumberValue(); },
        "endDateTime": n => { pstnCallLogRow.endDateTime = n.getDateValue(); },
        "id": n => { pstnCallLogRow.id = n.getStringValue(); },
        "inventoryType": n => { pstnCallLogRow.inventoryType = n.getStringValue(); },
        "licenseCapability": n => { pstnCallLogRow.licenseCapability = n.getStringValue(); },
        "@odata.type": n => { pstnCallLogRow.odataType = n.getStringValue(); },
        "operator": n => { pstnCallLogRow.operator = n.getStringValue(); },
        "startDateTime": n => { pstnCallLogRow.startDateTime = n.getDateValue(); },
        "tenantCountryCode": n => { pstnCallLogRow.tenantCountryCode = n.getStringValue(); },
        "usageCountryCode": n => { pstnCallLogRow.usageCountryCode = n.getStringValue(); },
        "userDisplayName": n => { pstnCallLogRow.userDisplayName = n.getStringValue(); },
        "userId": n => { pstnCallLogRow.userId = n.getStringValue(); },
        "userPrincipalName": n => { pstnCallLogRow.userPrincipalName = n.getStringValue(); },
    }
}
export function deserializeIntoSegment(segment: Segment | undefined = {} as Segment) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(segment),
        "callee": n => { segment.callee = n.getObjectValue<Endpoint>(createEndpointFromDiscriminatorValue); },
        "caller": n => { segment.caller = n.getObjectValue<Endpoint>(createEndpointFromDiscriminatorValue); },
        "endDateTime": n => { segment.endDateTime = n.getDateValue(); },
        "failureInfo": n => { segment.failureInfo = n.getObjectValue<FailureInfo>(createFailureInfoFromDiscriminatorValue); },
        "media": n => { segment.media = n.getCollectionOfObjectValues<Media>(createMediaFromDiscriminatorValue); },
        "startDateTime": n => { segment.startDateTime = n.getDateValue(); },
    }
}
export function deserializeIntoSegmentCollectionResponse(segmentCollectionResponse: SegmentCollectionResponse | undefined = {} as SegmentCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(segmentCollectionResponse),
        "value": n => { segmentCollectionResponse.value = n.getCollectionOfObjectValues<Segment>(createSegmentFromDiscriminatorValue); },
    }
}
export function deserializeIntoServiceEndpoint(serviceEndpoint: ServiceEndpoint | undefined = {} as ServiceEndpoint) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEndpoint(serviceEndpoint),
    }
}
export function deserializeIntoServiceUserAgent(serviceUserAgent: ServiceUserAgent | undefined = {} as ServiceUserAgent) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoUserAgent(serviceUserAgent),
        "role": n => { serviceUserAgent.role = n.getEnumValue<ServiceRole>(ServiceRole); },
    }
}
export function deserializeIntoSession(session: Session | undefined = {} as Session) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(session),
        "callee": n => { session.callee = n.getObjectValue<Endpoint>(createEndpointFromDiscriminatorValue); },
        "caller": n => { session.caller = n.getObjectValue<Endpoint>(createEndpointFromDiscriminatorValue); },
        "endDateTime": n => { session.endDateTime = n.getDateValue(); },
        "failureInfo": n => { session.failureInfo = n.getObjectValue<FailureInfo>(createFailureInfoFromDiscriminatorValue); },
        "isTest": n => { session.isTest = n.getBooleanValue(); },
        "modalities": n => { session.modalities = n.getCollectionOfEnumValues<Modality>(Modality); },
        "segments": n => { session.segments = n.getCollectionOfObjectValues<Segment>(createSegmentFromDiscriminatorValue); },
        "startDateTime": n => { session.startDateTime = n.getDateValue(); },
    }
}
export function deserializeIntoSessionCollectionResponse(sessionCollectionResponse: SessionCollectionResponse | undefined = {} as SessionCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(sessionCollectionResponse),
        "value": n => { sessionCollectionResponse.value = n.getCollectionOfObjectValues<Session>(createSessionFromDiscriminatorValue); },
    }
}
export function deserializeIntoTraceRouteHop(traceRouteHop: TraceRouteHop | undefined = {} as TraceRouteHop) : Record<string, (node: ParseNode) => void> {
    return {
        "hopCount": n => { traceRouteHop.hopCount = n.getNumberValue(); },
        "ipAddress": n => { traceRouteHop.ipAddress = n.getStringValue(); },
        "@odata.type": n => { traceRouteHop.odataType = n.getStringValue(); },
        "roundTripTime": n => { traceRouteHop.roundTripTime = n.getDurationValue(); },
    }
}
export function deserializeIntoUserAgent(userAgent: UserAgent | undefined = {} as UserAgent) : Record<string, (node: ParseNode) => void> {
    return {
        "applicationVersion": n => { userAgent.applicationVersion = n.getStringValue(); },
        "headerValue": n => { userAgent.headerValue = n.getStringValue(); },
        "@odata.type": n => { userAgent.odataType = n.getStringValue(); },
    }
}
export function deserializeIntoUserFeedback(userFeedback: UserFeedback | undefined = {} as UserFeedback) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.type": n => { userFeedback.odataType = n.getStringValue(); },
        "rating": n => { userFeedback.rating = n.getEnumValue<UserFeedbackRating>(UserFeedbackRating); },
        "text": n => { userFeedback.text = n.getStringValue(); },
        "tokens": n => { userFeedback.tokens = n.getObjectValue<FeedbackTokenSet>(createFeedbackTokenSetFromDiscriminatorValue); },
    }
}
export interface DeviceInfo extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Name of the capture device driver used by the media endpoint.
     */
    captureDeviceDriver?: string;
    /**
     * Name of the capture device used by the media endpoint.
     */
    captureDeviceName?: string;
    /**
     * Fraction of the call that the media endpoint detected the capture device was not working properly.
     */
    captureNotFunctioningEventRatio?: number;
    /**
     * Fraction of the call that the media endpoint detected the CPU resources available were insufficient and caused poor quality of the audio sent and received.
     */
    cpuInsufficentEventRatio?: number;
    /**
     * Fraction of the call that the media endpoint detected clipping in the captured audio that caused poor quality of the audio being sent.
     */
    deviceClippingEventRatio?: number;
    /**
     * Fraction of the call that the media endpoint detected glitches or gaps in the audio played or captured that caused poor quality of the audio being sent or received.
     */
    deviceGlitchEventRatio?: number;
    /**
     * Number of times during the call that the media endpoint detected howling or screeching audio.
     */
    howlingEventCount?: number;
    /**
     * The root mean square (RMS) of the incoming signal of up to the first 30 seconds of the call.
     */
    initialSignalLevelRootMeanSquare?: number;
    /**
     * Fraction of the call that the media endpoint detected low speech level that caused poor quality of the audio being sent.
     */
    lowSpeechLevelEventRatio?: number;
    /**
     * Fraction of the call that the media endpoint detected low speech to noise level that caused poor quality of the audio being sent.
     */
    lowSpeechToNoiseEventRatio?: number;
    /**
     * Glitches per 5 minute interval for the media endpoint's microphone.
     */
    micGlitchRate?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Average energy level of received audio for audio classified as mono noise or left channel of stereo noise by the media endpoint.
     */
    receivedNoiseLevel?: number;
    /**
     * Average energy level of received audio for audio classified as mono speech, or left channel of stereo speech by the media endpoint.
     */
    receivedSignalLevel?: number;
    /**
     * Name of the render device driver used by the media endpoint.
     */
    renderDeviceDriver?: string;
    /**
     * Name of the render device used by the media endpoint.
     */
    renderDeviceName?: string;
    /**
     * Fraction of the call that media endpoint detected device render is muted.
     */
    renderMuteEventRatio?: number;
    /**
     * Fraction of the call that the media endpoint detected the render device was not working properly.
     */
    renderNotFunctioningEventRatio?: number;
    /**
     * Fraction of the call that media endpoint detected device render volume is set to 0.
     */
    renderZeroVolumeEventRatio?: number;
    /**
     * Average energy level of sent audio for audio classified as mono noise or left channel of stereo noise by the media endpoint.
     */
    sentNoiseLevel?: number;
    /**
     * Average energy level of sent audio for audio classified as mono speech, or left channel of stereo speech by the media endpoint.
     */
    sentSignalLevel?: number;
    /**
     * Glitches per 5 minute internal for the media endpoint's loudspeaker.
     */
    speakerGlitchRate?: number;
}
export interface DirectRoutingLogRow extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Number of the user or bot who received the call. E.164 format, but might include other data.
     */
    calleeNumber?: string;
    /**
     * In addition to the SIP codes, Microsoft has subcodes that indicate the specific issue.
     */
    callEndSubReason?: number;
    /**
     * Number of the user or bot who made the call. E.164 format, but might include other data.
     */
    callerNumber?: string;
    /**
     * Call type and direction.
     */
    callType?: string;
    /**
     * Identifier for the call that you can use when calling Microsoft Support. GUID.
     */
    correlationId?: string;
    /**
     * Duration of the call in seconds.
     */
    duration?: number;
    /**
     * Only exists for successful (fully established) calls. Time when call ended.
     */
    endDateTime?: Date;
    /**
     * Only exists for failed (not fully established) calls.
     */
    failureDateTime?: Date;
    /**
     * The code with which the call ended. For more information, see RFC 3261.
     */
    finalSipCode?: number;
    /**
     * Description of the SIP code and Microsoft subcode.
     */
    finalSipCodePhrase?: string;
    /**
     * Unique call identifier. GUID.
     */
    id?: string;
    /**
     * When the initial invite was sent.
     */
    inviteDateTime?: Date;
    /**
     * Indicates whether the trunk was enabled for media bypass.
     */
    mediaBypassEnabled?: boolean;
    /**
     * The datacenter used for media path in a nonbypass call.
     */
    mediaPathLocation?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The datacenter used for signaling for both bypass and nonbypass calls.
     */
    signalingLocation?: string;
    /**
     * Call start time.For failed and unanswered calls, this can be equal to the invite or failure time.
     */
    startDateTime?: Date;
    /**
     * Success or attempt.
     */
    successfulCall?: boolean;
    /**
     * Fully qualified domain name of the session border controller.
     */
    trunkFullyQualifiedDomainName?: string;
    /**
     * Display name of the user.
     */
    userDisplayName?: string;
    /**
     * Calling user's ID in Microsoft Graph. This and other user information is null/empty for bot call types. GUID.
     */
    userId?: string;
    /**
     * UserPrincipalName (sign-in name) in Microsoft Entra ID. This is usually the same as the user's SIP Address, and can be the same as the user's email address.
     */
    userPrincipalName?: string;
}
export interface Endpoint extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * User-agent reported by this endpoint.
     */
    userAgent?: UserAgent;
}
export interface FailureInfo extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Classification of why a call or portion of a call failed.
     */
    reason?: string;
    /**
     * The stage property
     */
    stage?: FailureStage;
}
export enum FailureStage {
    Unknown = "unknown",
    CallSetup = "callSetup",
    Midcall = "midcall",
    UnknownFutureValue = "unknownFutureValue",
}
export interface FeedbackTokenSet extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface Media extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Device information associated with the callee endpoint of this media.
     */
    calleeDevice?: DeviceInfo;
    /**
     * Network information associated with the callee endpoint of this media.
     */
    calleeNetwork?: NetworkInfo;
    /**
     * Device information associated with the caller endpoint of this media.
     */
    callerDevice?: DeviceInfo;
    /**
     * Network information associated with the caller endpoint of this media.
     */
    callerNetwork?: NetworkInfo;
    /**
     * How the media was identified during media negotiation stage.
     */
    label?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Network streams associated with this media.
     */
    streams?: MediaStream[];
}
export interface MediaStream extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Codec name used to encode audio for transmission on the network. Possible values are: unknown, invalid, cn, pcma, pcmu, amrWide, g722, g7221, g7221c, g729, multiChannelAudio, muchv2, opus, satin, satinFullband, rtAudio8, rtAudio16, silk, silkNarrow, silkWide, siren, xmsRta, unknownFutureValue.
     */
    audioCodec?: AudioCodec;
    /**
     * Average Network Mean Opinion Score degradation for stream. Represents how much the network loss and jitter has impacted the quality of received audio.
     */
    averageAudioDegradation?: number;
    /**
     * Average jitter for the stream computed as specified in [RFC 3550][], denoted in [ISO 8601][] format. For example, 1 second is denoted as 'PT1S', where 'P' is the duration designator, 'T' is the time designator, and 'S' is the second designator.
     */
    averageAudioNetworkJitter?: Duration;
    /**
     * Average estimated bandwidth available between two endpoints in bits per second.
     */
    averageBandwidthEstimate?: number;
    /**
     * Average duration of the received freezing time in the video stream.
     */
    averageFreezeDuration?: Duration;
    /**
     * Average jitter for the stream computed as specified in [RFC 3550][], denoted in [ISO 8601][] format. For example, 1 second is denoted as 'PT1S', where 'P' is the duration designator, 'T' is the time designator, and 'S' is the second designator.
     */
    averageJitter?: Duration;
    /**
     * Average packet loss rate for stream.
     */
    averagePacketLossRate?: number;
    /**
     * Ratio of the number of audio frames with samples generated by packet loss concealment to the total number of audio frames.
     */
    averageRatioOfConcealedSamples?: number;
    /**
     * Average frames per second received for all video streams computed over the duration of the session.
     */
    averageReceivedFrameRate?: number;
    /**
     * Average network propagation round-trip time computed as specified in [RFC 3550][], denoted in [ISO 8601][] format. For example, 1 second is denoted as 'PT1S', where 'P' is the duration designator, 'T' is the time designator, and 'S' is the second designator.
     */
    averageRoundTripTime?: Duration;
    /**
     * Average percentage of video frames lost as displayed to the user.
     */
    averageVideoFrameLossPercentage?: number;
    /**
     * Average frames per second received for a video stream, computed over the duration of the session.
     */
    averageVideoFrameRate?: number;
    /**
     * Average fraction of packets lost, as specified in [RFC 3550][], computed over the duration of the session.
     */
    averageVideoPacketLossRate?: number;
    /**
     * UTC time when the stream ended. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. This field is only available for streams that use the SIP protocol.
     */
    endDateTime?: Date;
    /**
     * Indicates whether the forward error correction (FEC) was used at some point during the session. The default value is null.
     */
    isAudioForwardErrorCorrectionUsed?: boolean;
    /**
     * Fraction of the call where frame rate is less than 7.5 frames per second.
     */
    lowFrameRateRatio?: number;
    /**
     * Fraction of the call that the client is running less than 70% expected video processing capability.
     */
    lowVideoProcessingCapabilityRatio?: number;
    /**
     * Maximum of audio network jitter computed over each of the 20 second windows during the session, denoted in [ISO 8601][] format. For example, 1 second is denoted as 'PT1S', where 'P' is the duration designator, 'T' is the time designator, and 'S' is the second designator.
     */
    maxAudioNetworkJitter?: Duration;
    /**
     * Maximum jitter for the stream computed as specified in RFC 3550, denoted in [ISO 8601][] format. For example, 1 second is denoted as 'PT1S', where 'P' is the duration designator, 'T' is the time designator, and 'S' is the second designator.
     */
    maxJitter?: Duration;
    /**
     * Maximum packet loss rate for the stream.
     */
    maxPacketLossRate?: number;
    /**
     * Maximum ratio of packets concealed by the healer.
     */
    maxRatioOfConcealedSamples?: number;
    /**
     * Maximum network propagation round-trip time computed as specified in [RFC 3550][], denoted in [ISO 8601][] format. For example, 1 second is denoted as 'PT1S', where 'P' is the duration designator, 'T' is the time designator, and 'S' is the second designator.
     */
    maxRoundTripTime?: Duration;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Packet count for the stream.
     */
    packetUtilization?: number;
    /**
     * Packet loss rate after FEC has been applied aggregated across all video streams and codecs.
     */
    postForwardErrorCorrectionPacketLossRate?: number;
    /**
     * Average duration of the received freezing time in the video stream represented in root mean square.
     */
    rmsFreezeDuration?: Duration;
    /**
     * UTC time when the stream started. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. This field is only available for streams that use the SIP protocol.
     */
    startDateTime?: Date;
    /**
     * The streamDirection property
     */
    streamDirection?: MediaStreamDirection;
    /**
     * Unique identifier for the stream.
     */
    streamId?: string;
    /**
     * Codec name used to encode video for transmission on the network. Possible values are: unknown, invalid, av1, h263, h264, h264s, h264uc, h265, rtvc1, rtVideo, xrtvc1, unknownFutureValue.
     */
    videoCodec?: VideoCodec;
    /**
     * True if the media stream bypassed the Mediation Server and went straight between client and PSTN Gateway/PBX, false otherwise.
     */
    wasMediaBypassed?: boolean;
}
export enum MediaStreamDirection {
    CallerToCallee = "callerToCallee",
    CalleeToCaller = "calleeToCaller",
}
export enum Modality {
    Audio = "audio",
    Video = "video",
    VideoBasedScreenSharing = "videoBasedScreenSharing",
    Data = "data",
    ScreenSharing = "screenSharing",
    UnknownFutureValue = "unknownFutureValue",
}
export enum NetworkConnectionType {
    Unknown = "unknown",
    Wired = "wired",
    Wifi = "wifi",
    Mobile = "mobile",
    Tunnel = "tunnel",
    UnknownFutureValue = "unknownFutureValue",
}
export interface NetworkInfo extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Fraction of the call that the media endpoint detected the available bandwidth or bandwidth policy was low enough to cause poor quality of the audio sent.
     */
    bandwidthLowEventRatio?: number;
    /**
     * The wireless LAN basic service set identifier of the media endpoint used to connect to the network.
     */
    basicServiceSetIdentifier?: string;
    /**
     * The connectionType property
     */
    connectionType?: NetworkConnectionType;
    /**
     * Fraction of the call that the media endpoint detected the network delay was significant enough to impact the ability to have real-time two-way communication.
     */
    delayEventRatio?: number;
    /**
     * DNS suffix associated with the network adapter of the media endpoint.
     */
    dnsSuffix?: string;
    /**
     * IP address of the media endpoint.
     */
    ipAddress?: string;
    /**
     * Link speed in bits per second reported by the network adapter used by the media endpoint.
     */
    linkSpeed?: number;
    /**
     * The media access control (MAC) address of the media endpoint's network device. This value may be missing or shown as 02:00:00:00:00:00 due to operating system privacy policies.
     */
    macAddress?: string;
    /**
     * The networkTransportProtocol property
     */
    networkTransportProtocol?: NetworkTransportProtocol;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Network port number used by media endpoint.
     */
    port?: number;
    /**
     * Fraction of the call that the media endpoint detected the network was causing poor quality of the audio received.
     */
    receivedQualityEventRatio?: number;
    /**
     * IP address of the media endpoint as seen by the media relay server. This is typically the public internet IP address associated to the endpoint.
     */
    reflexiveIPAddress?: string;
    /**
     * IP address of the media relay server allocated by the media endpoint.
     */
    relayIPAddress?: string;
    /**
     * Network port number allocated on the media relay server by the media endpoint.
     */
    relayPort?: number;
    /**
     * Fraction of the call that the media endpoint detected the network was causing poor quality of the audio sent.
     */
    sentQualityEventRatio?: number;
    /**
     * Subnet used for media stream by the media endpoint.
     */
    subnet?: string;
    /**
     * List of network trace route hops collected for this media stream.*
     */
    traceRouteHops?: TraceRouteHop[];
    /**
     * The wifiBand property
     */
    wifiBand?: WifiBand;
    /**
     * Estimated remaining battery charge in percentage reported by the media endpoint.
     */
    wifiBatteryCharge?: number;
    /**
     * WiFi channel used by the media endpoint.
     */
    wifiChannel?: number;
    /**
     * Name of the Microsoft WiFi driver used by the media endpoint. Value may be localized based on the language used by endpoint.
     */
    wifiMicrosoftDriver?: string;
    /**
     * Version of the Microsoft WiFi driver used by the media endpoint.
     */
    wifiMicrosoftDriverVersion?: string;
    /**
     * The wifiRadioType property
     */
    wifiRadioType?: WifiRadioType;
    /**
     * WiFi signal strength in percentage reported by the media endpoint.
     */
    wifiSignalStrength?: number;
    /**
     * Name of the WiFi driver used by the media endpoint. Value may be localized based on the language used by endpoint.
     */
    wifiVendorDriver?: string;
    /**
     * Version of the WiFi driver used by the media endpoint.
     */
    wifiVendorDriverVersion?: string;
}
export enum NetworkTransportProtocol {
    Unknown = "unknown",
    Udp = "udp",
    Tcp = "tcp",
    UnknownFutureValue = "unknownFutureValue",
}
export interface ParticipantEndpoint extends Endpoint, Parsable {
    /**
     * CPU number of cores used by the media endpoint.
     */
    cpuCoresCount?: number;
    /**
     * CPU name used by the media endpoint.
     */
    cpuName?: string;
    /**
     * CPU processor speed used by the media endpoint.
     */
    cpuProcessorSpeedInMhz?: number;
    /**
     * The feedback provided by the user of this endpoint about the quality of the session.
     */
    feedback?: UserFeedback;
    /**
     * Identity associated with the endpoint.
     */
    identity?: IdentitySet;
    /**
     * Name of the device used by the media endpoint.
     */
    name?: string;
}
export enum ProductFamily {
    Unknown = "unknown",
    Teams = "teams",
    SkypeForBusiness = "skypeForBusiness",
    Lync = "lync",
    UnknownFutureValue = "unknownFutureValue",
    AzureCommunicationServices = "azureCommunicationServices",
}
export enum PstnCallDurationSource {
    Microsoft = "microsoft",
    Operator = "operator",
}
export interface PstnCallLogRow extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The source of the call duration data. If the call uses a third-party telecommunications operator via the Operator Connect Program, the operator can provide their own call duration data. In this case, the property value is operator. Otherwise, the value is microsoft.
     */
    callDurationSource?: PstnCallDurationSource;
    /**
     * Number dialed in E.164 format.
     */
    calleeNumber?: string;
    /**
     * Number that received the call for inbound calls or the number dialed for outbound calls. E.164 format.
     */
    callerNumber?: string;
    /**
     * Call identifier. Not guaranteed to be unique.
     */
    callId?: string;
    /**
     * Indicates whether the call was a PSTN outbound or inbound call and the type of call, such as a call placed by a user or an audio conference.
     */
    callType?: string;
    /**
     * Amount of money or cost of the call that is charged to your account.
     */
    charge?: number;
    /**
     * ID of the audio conference.
     */
    conferenceId?: string;
    /**
     * Connection fee price.
     */
    connectionCharge?: number;
    /**
     * Type of currency used to calculate the cost of the call. For details, see (ISO 4217.
     */
    currency?: string;
    /**
     * Whether the call was domestic (within a country or region) or international (outside a country or region), based on the user's location.
     */
    destinationContext?: string;
    /**
     * Country or region dialed.
     */
    destinationName?: string;
    /**
     * How long the call was connected, in seconds.
     */
    duration?: number;
    /**
     * Call end time.
     */
    endDateTime?: Date;
    /**
     * Unique call identifier. GUID.
     */
    id?: string;
    /**
     * User's phone number type, such as a service of toll-free number.
     */
    inventoryType?: string;
    /**
     * The license used for the call.
     */
    licenseCapability?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The telecommunications operator which provided PSTN services for this call. This might be Microsoft, or it might be a third-party operator via the Operator Connect Program.
     */
    operator?: string;
    /**
     * Call start time.
     */
    startDateTime?: Date;
    /**
     * Country code of the tenant. For details, see ISO 3166-1 alpha-2.
     */
    tenantCountryCode?: string;
    /**
     * Country code of the user. For details, see ISO 3166-1 alpha-2.
     */
    usageCountryCode?: string;
    /**
     * Display name of the user.
     */
    userDisplayName?: string;
    /**
     * Calling user's ID in Microsoft Graph. GUID. This and other user info will be null/empty for bot call types (ucapin, ucapout).
     */
    userId?: string;
    /**
     * The user principal name (sign-in name) in Microsoft Entra ID. This is usually the same as the user's SIP address, and can be the same as the user's email address.
     */
    userPrincipalName?: string;
}
export interface Segment extends Entity, Parsable {
    /**
     * Endpoint that answered this segment.
     */
    callee?: Endpoint;
    /**
     * Endpoint that initiated this segment.
     */
    caller?: Endpoint;
    /**
     * UTC time when the segment ended. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    endDateTime?: Date;
    /**
     * Failure information associated with the segment if it failed.
     */
    failureInfo?: FailureInfo;
    /**
     * Media associated with this segment.
     */
    media?: Media[];
    /**
     * UTC time when the segment started. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    startDateTime?: Date;
}
export interface SegmentCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Segment[];
}
export function serializeCallRecord(writer: SerializationWriter, callRecord: CallRecord | undefined = {} as CallRecord) : void {
    serializeEntity(writer, callRecord)
    writer.writeDateValue("endDateTime", callRecord.endDateTime);
    writer.writeStringValue("joinWebUrl", callRecord.joinWebUrl);
    writer.writeDateValue("lastModifiedDateTime", callRecord.lastModifiedDateTime);
    if(callRecord.modalities)
    writer.writeEnumValue<Modality>("modalities", ...callRecord.modalities);
    writer.writeObjectValue<IdentitySet>("organizer", callRecord.organizer, serializeIdentitySet);
    writer.writeCollectionOfObjectValues<IdentitySet>("participants", callRecord.participants, serializeIdentitySet);
    writer.writeCollectionOfObjectValues<Session>("sessions", callRecord.sessions, serializeSession);
    writer.writeDateValue("startDateTime", callRecord.startDateTime);
    writer.writeEnumValue<CallType>("type", callRecord.type);
    writer.writeNumberValue("version", callRecord.version);
}
export function serializeCallRecordCollectionResponse(writer: SerializationWriter, callRecordCollectionResponse: CallRecordCollectionResponse | undefined = {} as CallRecordCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, callRecordCollectionResponse)
    writer.writeCollectionOfObjectValues<CallRecord>("value", callRecordCollectionResponse.value, serializeCallRecord);
}
export function serializeClientUserAgent(writer: SerializationWriter, clientUserAgent: ClientUserAgent | undefined = {} as ClientUserAgent) : void {
    serializeUserAgent(writer, clientUserAgent)
    writer.writeStringValue("azureADAppId", clientUserAgent.azureADAppId);
    writer.writeStringValue("communicationServiceId", clientUserAgent.communicationServiceId);
    writer.writeEnumValue<ClientPlatform>("platform", clientUserAgent.platform);
    writer.writeEnumValue<ProductFamily>("productFamily", clientUserAgent.productFamily);
}
export function serializeDeviceInfo(writer: SerializationWriter, deviceInfo: DeviceInfo | undefined = {} as DeviceInfo) : void {
    writer.writeStringValue("captureDeviceDriver", deviceInfo.captureDeviceDriver);
    writer.writeStringValue("captureDeviceName", deviceInfo.captureDeviceName);
    writer.writeNumberValue("captureNotFunctioningEventRatio", deviceInfo.captureNotFunctioningEventRatio);
    writer.writeNumberValue("cpuInsufficentEventRatio", deviceInfo.cpuInsufficentEventRatio);
    writer.writeNumberValue("deviceClippingEventRatio", deviceInfo.deviceClippingEventRatio);
    writer.writeNumberValue("deviceGlitchEventRatio", deviceInfo.deviceGlitchEventRatio);
    writer.writeNumberValue("howlingEventCount", deviceInfo.howlingEventCount);
    writer.writeNumberValue("initialSignalLevelRootMeanSquare", deviceInfo.initialSignalLevelRootMeanSquare);
    writer.writeNumberValue("lowSpeechLevelEventRatio", deviceInfo.lowSpeechLevelEventRatio);
    writer.writeNumberValue("lowSpeechToNoiseEventRatio", deviceInfo.lowSpeechToNoiseEventRatio);
    writer.writeNumberValue("micGlitchRate", deviceInfo.micGlitchRate);
    writer.writeStringValue("@odata.type", deviceInfo.odataType);
    writer.writeNumberValue("receivedNoiseLevel", deviceInfo.receivedNoiseLevel);
    writer.writeNumberValue("receivedSignalLevel", deviceInfo.receivedSignalLevel);
    writer.writeStringValue("renderDeviceDriver", deviceInfo.renderDeviceDriver);
    writer.writeStringValue("renderDeviceName", deviceInfo.renderDeviceName);
    writer.writeNumberValue("renderMuteEventRatio", deviceInfo.renderMuteEventRatio);
    writer.writeNumberValue("renderNotFunctioningEventRatio", deviceInfo.renderNotFunctioningEventRatio);
    writer.writeNumberValue("renderZeroVolumeEventRatio", deviceInfo.renderZeroVolumeEventRatio);
    writer.writeNumberValue("sentNoiseLevel", deviceInfo.sentNoiseLevel);
    writer.writeNumberValue("sentSignalLevel", deviceInfo.sentSignalLevel);
    writer.writeNumberValue("speakerGlitchRate", deviceInfo.speakerGlitchRate);
    writer.writeAdditionalData(deviceInfo.additionalData);
}
export function serializeDirectRoutingLogRow(writer: SerializationWriter, directRoutingLogRow: DirectRoutingLogRow | undefined = {} as DirectRoutingLogRow) : void {
    writer.writeStringValue("calleeNumber", directRoutingLogRow.calleeNumber);
    writer.writeNumberValue("callEndSubReason", directRoutingLogRow.callEndSubReason);
    writer.writeStringValue("callerNumber", directRoutingLogRow.callerNumber);
    writer.writeStringValue("callType", directRoutingLogRow.callType);
    writer.writeStringValue("correlationId", directRoutingLogRow.correlationId);
    writer.writeNumberValue("duration", directRoutingLogRow.duration);
    writer.writeDateValue("endDateTime", directRoutingLogRow.endDateTime);
    writer.writeDateValue("failureDateTime", directRoutingLogRow.failureDateTime);
    writer.writeNumberValue("finalSipCode", directRoutingLogRow.finalSipCode);
    writer.writeStringValue("finalSipCodePhrase", directRoutingLogRow.finalSipCodePhrase);
    writer.writeStringValue("id", directRoutingLogRow.id);
    writer.writeDateValue("inviteDateTime", directRoutingLogRow.inviteDateTime);
    writer.writeBooleanValue("mediaBypassEnabled", directRoutingLogRow.mediaBypassEnabled);
    writer.writeStringValue("mediaPathLocation", directRoutingLogRow.mediaPathLocation);
    writer.writeStringValue("@odata.type", directRoutingLogRow.odataType);
    writer.writeStringValue("signalingLocation", directRoutingLogRow.signalingLocation);
    writer.writeDateValue("startDateTime", directRoutingLogRow.startDateTime);
    writer.writeBooleanValue("successfulCall", directRoutingLogRow.successfulCall);
    writer.writeStringValue("trunkFullyQualifiedDomainName", directRoutingLogRow.trunkFullyQualifiedDomainName);
    writer.writeStringValue("userDisplayName", directRoutingLogRow.userDisplayName);
    writer.writeStringValue("userId", directRoutingLogRow.userId);
    writer.writeStringValue("userPrincipalName", directRoutingLogRow.userPrincipalName);
    writer.writeAdditionalData(directRoutingLogRow.additionalData);
}
export function serializeEndpoint(writer: SerializationWriter, endpoint: Endpoint | undefined = {} as Endpoint) : void {
    writer.writeStringValue("@odata.type", endpoint.odataType);
    writer.writeObjectValue<UserAgent>("userAgent", endpoint.userAgent, serializeUserAgent);
    writer.writeAdditionalData(endpoint.additionalData);
}
export function serializeFailureInfo(writer: SerializationWriter, failureInfo: FailureInfo | undefined = {} as FailureInfo) : void {
    writer.writeStringValue("@odata.type", failureInfo.odataType);
    writer.writeStringValue("reason", failureInfo.reason);
    writer.writeEnumValue<FailureStage>("stage", failureInfo.stage);
    writer.writeAdditionalData(failureInfo.additionalData);
}
export function serializeFeedbackTokenSet(writer: SerializationWriter, feedbackTokenSet: FeedbackTokenSet | undefined = {} as FeedbackTokenSet) : void {
    writer.writeStringValue("@odata.type", feedbackTokenSet.odataType);
    writer.writeAdditionalData(feedbackTokenSet.additionalData);
}
export function serializeMedia(writer: SerializationWriter, media: Media | undefined = {} as Media) : void {
    writer.writeObjectValue<DeviceInfo>("calleeDevice", media.calleeDevice, serializeDeviceInfo);
    writer.writeObjectValue<NetworkInfo>("calleeNetwork", media.calleeNetwork, serializeNetworkInfo);
    writer.writeObjectValue<DeviceInfo>("callerDevice", media.callerDevice, serializeDeviceInfo);
    writer.writeObjectValue<NetworkInfo>("callerNetwork", media.callerNetwork, serializeNetworkInfo);
    writer.writeStringValue("label", media.label);
    writer.writeStringValue("@odata.type", media.odataType);
    writer.writeCollectionOfObjectValues<MediaStream>("streams", media.streams, serializeMediaStream);
    writer.writeAdditionalData(media.additionalData);
}
export function serializeMediaStream(writer: SerializationWriter, mediaStream: MediaStream | undefined = {} as MediaStream) : void {
    writer.writeEnumValue<AudioCodec>("audioCodec", mediaStream.audioCodec);
    writer.writeNumberValue("averageAudioDegradation", mediaStream.averageAudioDegradation);
    writer.writeDurationValue("averageAudioNetworkJitter", mediaStream.averageAudioNetworkJitter);
    writer.writeNumberValue("averageBandwidthEstimate", mediaStream.averageBandwidthEstimate);
    writer.writeDurationValue("averageFreezeDuration", mediaStream.averageFreezeDuration);
    writer.writeDurationValue("averageJitter", mediaStream.averageJitter);
    writer.writeNumberValue("averagePacketLossRate", mediaStream.averagePacketLossRate);
    writer.writeNumberValue("averageRatioOfConcealedSamples", mediaStream.averageRatioOfConcealedSamples);
    writer.writeNumberValue("averageReceivedFrameRate", mediaStream.averageReceivedFrameRate);
    writer.writeDurationValue("averageRoundTripTime", mediaStream.averageRoundTripTime);
    writer.writeNumberValue("averageVideoFrameLossPercentage", mediaStream.averageVideoFrameLossPercentage);
    writer.writeNumberValue("averageVideoFrameRate", mediaStream.averageVideoFrameRate);
    writer.writeNumberValue("averageVideoPacketLossRate", mediaStream.averageVideoPacketLossRate);
    writer.writeDateValue("endDateTime", mediaStream.endDateTime);
    writer.writeBooleanValue("isAudioForwardErrorCorrectionUsed", mediaStream.isAudioForwardErrorCorrectionUsed);
    writer.writeNumberValue("lowFrameRateRatio", mediaStream.lowFrameRateRatio);
    writer.writeNumberValue("lowVideoProcessingCapabilityRatio", mediaStream.lowVideoProcessingCapabilityRatio);
    writer.writeDurationValue("maxAudioNetworkJitter", mediaStream.maxAudioNetworkJitter);
    writer.writeDurationValue("maxJitter", mediaStream.maxJitter);
    writer.writeNumberValue("maxPacketLossRate", mediaStream.maxPacketLossRate);
    writer.writeNumberValue("maxRatioOfConcealedSamples", mediaStream.maxRatioOfConcealedSamples);
    writer.writeDurationValue("maxRoundTripTime", mediaStream.maxRoundTripTime);
    writer.writeStringValue("@odata.type", mediaStream.odataType);
    writer.writeNumberValue("packetUtilization", mediaStream.packetUtilization);
    writer.writeNumberValue("postForwardErrorCorrectionPacketLossRate", mediaStream.postForwardErrorCorrectionPacketLossRate);
    writer.writeDurationValue("rmsFreezeDuration", mediaStream.rmsFreezeDuration);
    writer.writeDateValue("startDateTime", mediaStream.startDateTime);
    writer.writeEnumValue<MediaStreamDirection>("streamDirection", mediaStream.streamDirection);
    writer.writeStringValue("streamId", mediaStream.streamId);
    writer.writeEnumValue<VideoCodec>("videoCodec", mediaStream.videoCodec);
    writer.writeBooleanValue("wasMediaBypassed", mediaStream.wasMediaBypassed);
    writer.writeAdditionalData(mediaStream.additionalData);
}
export function serializeNetworkInfo(writer: SerializationWriter, networkInfo: NetworkInfo | undefined = {} as NetworkInfo) : void {
    writer.writeNumberValue("bandwidthLowEventRatio", networkInfo.bandwidthLowEventRatio);
    writer.writeStringValue("basicServiceSetIdentifier", networkInfo.basicServiceSetIdentifier);
    writer.writeEnumValue<NetworkConnectionType>("connectionType", networkInfo.connectionType);
    writer.writeNumberValue("delayEventRatio", networkInfo.delayEventRatio);
    writer.writeStringValue("dnsSuffix", networkInfo.dnsSuffix);
    writer.writeStringValue("ipAddress", networkInfo.ipAddress);
    writer.writeNumberValue("linkSpeed", networkInfo.linkSpeed);
    writer.writeStringValue("macAddress", networkInfo.macAddress);
    writer.writeEnumValue<NetworkTransportProtocol>("networkTransportProtocol", networkInfo.networkTransportProtocol);
    writer.writeStringValue("@odata.type", networkInfo.odataType);
    writer.writeNumberValue("port", networkInfo.port);
    writer.writeNumberValue("receivedQualityEventRatio", networkInfo.receivedQualityEventRatio);
    writer.writeStringValue("reflexiveIPAddress", networkInfo.reflexiveIPAddress);
    writer.writeStringValue("relayIPAddress", networkInfo.relayIPAddress);
    writer.writeNumberValue("relayPort", networkInfo.relayPort);
    writer.writeNumberValue("sentQualityEventRatio", networkInfo.sentQualityEventRatio);
    writer.writeStringValue("subnet", networkInfo.subnet);
    writer.writeCollectionOfObjectValues<TraceRouteHop>("traceRouteHops", networkInfo.traceRouteHops, serializeTraceRouteHop);
    writer.writeEnumValue<WifiBand>("wifiBand", networkInfo.wifiBand);
    writer.writeNumberValue("wifiBatteryCharge", networkInfo.wifiBatteryCharge);
    writer.writeNumberValue("wifiChannel", networkInfo.wifiChannel);
    writer.writeStringValue("wifiMicrosoftDriver", networkInfo.wifiMicrosoftDriver);
    writer.writeStringValue("wifiMicrosoftDriverVersion", networkInfo.wifiMicrosoftDriverVersion);
    writer.writeEnumValue<WifiRadioType>("wifiRadioType", networkInfo.wifiRadioType);
    writer.writeNumberValue("wifiSignalStrength", networkInfo.wifiSignalStrength);
    writer.writeStringValue("wifiVendorDriver", networkInfo.wifiVendorDriver);
    writer.writeStringValue("wifiVendorDriverVersion", networkInfo.wifiVendorDriverVersion);
    writer.writeAdditionalData(networkInfo.additionalData);
}
export function serializeParticipantEndpoint(writer: SerializationWriter, participantEndpoint: ParticipantEndpoint | undefined = {} as ParticipantEndpoint) : void {
    serializeEndpoint(writer, participantEndpoint)
    writer.writeNumberValue("cpuCoresCount", participantEndpoint.cpuCoresCount);
    writer.writeStringValue("cpuName", participantEndpoint.cpuName);
    writer.writeNumberValue("cpuProcessorSpeedInMhz", participantEndpoint.cpuProcessorSpeedInMhz);
    writer.writeObjectValue<UserFeedback>("feedback", participantEndpoint.feedback, serializeUserFeedback);
    writer.writeObjectValue<IdentitySet>("identity", participantEndpoint.identity, serializeIdentitySet);
    writer.writeStringValue("name", participantEndpoint.name);
}
export function serializePstnCallLogRow(writer: SerializationWriter, pstnCallLogRow: PstnCallLogRow | undefined = {} as PstnCallLogRow) : void {
    writer.writeEnumValue<PstnCallDurationSource>("callDurationSource", pstnCallLogRow.callDurationSource);
    writer.writeStringValue("calleeNumber", pstnCallLogRow.calleeNumber);
    writer.writeStringValue("callerNumber", pstnCallLogRow.callerNumber);
    writer.writeStringValue("callId", pstnCallLogRow.callId);
    writer.writeStringValue("callType", pstnCallLogRow.callType);
    writer.writeNumberValue("charge", pstnCallLogRow.charge);
    writer.writeStringValue("conferenceId", pstnCallLogRow.conferenceId);
    writer.writeNumberValue("connectionCharge", pstnCallLogRow.connectionCharge);
    writer.writeStringValue("currency", pstnCallLogRow.currency);
    writer.writeStringValue("destinationContext", pstnCallLogRow.destinationContext);
    writer.writeStringValue("destinationName", pstnCallLogRow.destinationName);
    writer.writeNumberValue("duration", pstnCallLogRow.duration);
    writer.writeDateValue("endDateTime", pstnCallLogRow.endDateTime);
    writer.writeStringValue("id", pstnCallLogRow.id);
    writer.writeStringValue("inventoryType", pstnCallLogRow.inventoryType);
    writer.writeStringValue("licenseCapability", pstnCallLogRow.licenseCapability);
    writer.writeStringValue("@odata.type", pstnCallLogRow.odataType);
    writer.writeStringValue("operator", pstnCallLogRow.operator);
    writer.writeDateValue("startDateTime", pstnCallLogRow.startDateTime);
    writer.writeStringValue("tenantCountryCode", pstnCallLogRow.tenantCountryCode);
    writer.writeStringValue("usageCountryCode", pstnCallLogRow.usageCountryCode);
    writer.writeStringValue("userDisplayName", pstnCallLogRow.userDisplayName);
    writer.writeStringValue("userId", pstnCallLogRow.userId);
    writer.writeStringValue("userPrincipalName", pstnCallLogRow.userPrincipalName);
    writer.writeAdditionalData(pstnCallLogRow.additionalData);
}
export function serializeSegment(writer: SerializationWriter, segment: Segment | undefined = {} as Segment) : void {
    serializeEntity(writer, segment)
    writer.writeObjectValue<Endpoint>("callee", segment.callee, serializeEndpoint);
    writer.writeObjectValue<Endpoint>("caller", segment.caller, serializeEndpoint);
    writer.writeDateValue("endDateTime", segment.endDateTime);
    writer.writeObjectValue<FailureInfo>("failureInfo", segment.failureInfo, serializeFailureInfo);
    writer.writeCollectionOfObjectValues<Media>("media", segment.media, serializeMedia);
    writer.writeDateValue("startDateTime", segment.startDateTime);
}
export function serializeSegmentCollectionResponse(writer: SerializationWriter, segmentCollectionResponse: SegmentCollectionResponse | undefined = {} as SegmentCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, segmentCollectionResponse)
    writer.writeCollectionOfObjectValues<Segment>("value", segmentCollectionResponse.value, serializeSegment);
}
export function serializeServiceEndpoint(writer: SerializationWriter, serviceEndpoint: ServiceEndpoint | undefined = {} as ServiceEndpoint) : void {
    serializeEndpoint(writer, serviceEndpoint)
}
export function serializeServiceUserAgent(writer: SerializationWriter, serviceUserAgent: ServiceUserAgent | undefined = {} as ServiceUserAgent) : void {
    serializeUserAgent(writer, serviceUserAgent)
    writer.writeEnumValue<ServiceRole>("role", serviceUserAgent.role);
}
export function serializeSession(writer: SerializationWriter, session: Session | undefined = {} as Session) : void {
    serializeEntity(writer, session)
    writer.writeObjectValue<Endpoint>("callee", session.callee, serializeEndpoint);
    writer.writeObjectValue<Endpoint>("caller", session.caller, serializeEndpoint);
    writer.writeDateValue("endDateTime", session.endDateTime);
    writer.writeObjectValue<FailureInfo>("failureInfo", session.failureInfo, serializeFailureInfo);
    writer.writeBooleanValue("isTest", session.isTest);
    if(session.modalities)
    writer.writeEnumValue<Modality>("modalities", ...session.modalities);
    writer.writeCollectionOfObjectValues<Segment>("segments", session.segments, serializeSegment);
    writer.writeDateValue("startDateTime", session.startDateTime);
}
export function serializeSessionCollectionResponse(writer: SerializationWriter, sessionCollectionResponse: SessionCollectionResponse | undefined = {} as SessionCollectionResponse) : void {
    serializeBaseCollectionPaginationCountResponse(writer, sessionCollectionResponse)
    writer.writeCollectionOfObjectValues<Session>("value", sessionCollectionResponse.value, serializeSession);
}
export function serializeTraceRouteHop(writer: SerializationWriter, traceRouteHop: TraceRouteHop | undefined = {} as TraceRouteHop) : void {
    writer.writeNumberValue("hopCount", traceRouteHop.hopCount);
    writer.writeStringValue("ipAddress", traceRouteHop.ipAddress);
    writer.writeStringValue("@odata.type", traceRouteHop.odataType);
    writer.writeDurationValue("roundTripTime", traceRouteHop.roundTripTime);
    writer.writeAdditionalData(traceRouteHop.additionalData);
}
export function serializeUserAgent(writer: SerializationWriter, userAgent: UserAgent | undefined = {} as UserAgent) : void {
    writer.writeStringValue("applicationVersion", userAgent.applicationVersion);
    writer.writeStringValue("headerValue", userAgent.headerValue);
    writer.writeStringValue("@odata.type", userAgent.odataType);
    writer.writeAdditionalData(userAgent.additionalData);
}
export function serializeUserFeedback(writer: SerializationWriter, userFeedback: UserFeedback | undefined = {} as UserFeedback) : void {
    writer.writeStringValue("@odata.type", userFeedback.odataType);
    writer.writeEnumValue<UserFeedbackRating>("rating", userFeedback.rating);
    writer.writeStringValue("text", userFeedback.text);
    writer.writeObjectValue<FeedbackTokenSet>("tokens", userFeedback.tokens, serializeFeedbackTokenSet);
    writer.writeAdditionalData(userFeedback.additionalData);
}
export interface ServiceEndpoint extends Endpoint, Parsable {
}
export enum ServiceRole {
    Unknown = "unknown",
    CustomBot = "customBot",
    SkypeForBusinessMicrosoftTeamsGateway = "skypeForBusinessMicrosoftTeamsGateway",
    SkypeForBusinessAudioVideoMcu = "skypeForBusinessAudioVideoMcu",
    SkypeForBusinessApplicationSharingMcu = "skypeForBusinessApplicationSharingMcu",
    SkypeForBusinessCallQueues = "skypeForBusinessCallQueues",
    SkypeForBusinessAutoAttendant = "skypeForBusinessAutoAttendant",
    MediationServer = "mediationServer",
    MediationServerCloudConnectorEdition = "mediationServerCloudConnectorEdition",
    ExchangeUnifiedMessagingService = "exchangeUnifiedMessagingService",
    MediaController = "mediaController",
    ConferencingAnnouncementService = "conferencingAnnouncementService",
    ConferencingAttendant = "conferencingAttendant",
    AudioTeleconferencerController = "audioTeleconferencerController",
    SkypeForBusinessUnifiedCommunicationApplicationPlatform = "skypeForBusinessUnifiedCommunicationApplicationPlatform",
    ResponseGroupServiceAnnouncementService = "responseGroupServiceAnnouncementService",
    Gateway = "gateway",
    SkypeTranslator = "skypeTranslator",
    SkypeForBusinessAttendant = "skypeForBusinessAttendant",
    ResponseGroupService = "responseGroupService",
    Voicemail = "voicemail",
    UnknownFutureValue = "unknownFutureValue",
}
export interface ServiceUserAgent extends Parsable, UserAgent {
    /**
     * The role property
     */
    role?: ServiceRole;
}
export interface Session extends Entity, Parsable {
    /**
     * Endpoint that answered the session.
     */
    callee?: Endpoint;
    /**
     * Endpoint that initiated the session.
     */
    caller?: Endpoint;
    /**
     * UTC time when the last user left the session. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    endDateTime?: Date;
    /**
     * Failure information associated with the session if the session failed.
     */
    failureInfo?: FailureInfo;
    /**
     * Specifies whether the session is a test.
     */
    isTest?: boolean;
    /**
     * List of modalities present in the session. Possible values are: unknown, audio, video, videoBasedScreenSharing, data, screenSharing, unknownFutureValue.
     */
    modalities?: Modality[];
    /**
     * The list of segments involved in the session. Read-only. Nullable.
     */
    segments?: Segment[];
    /**
     * UTC time when the first user joined the session. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    startDateTime?: Date;
}
export interface SessionCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Session[];
}
export interface TraceRouteHop extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The network path count of this hop that was used to compute the RTT.
     */
    hopCount?: number;
    /**
     * IP address used for this hop in the network trace.
     */
    ipAddress?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The time from when the trace route packet was sent from the client to this hop and back to the client, denoted in [ISO 8601][] format. For example, 1 second is denoted as PT1S, where P is the duration designator, T is the time designator, and S is the second designator.
     */
    roundTripTime?: Duration;
}
export interface UserAgent extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Identifies the version of application software used by this endpoint.
     */
    applicationVersion?: string;
    /**
     * User-agent header value reported by this endpoint.
     */
    headerValue?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface UserFeedback extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The rating property
     */
    rating?: UserFeedbackRating;
    /**
     * The feedback text provided by the user of this endpoint for the session.
     */
    text?: string;
    /**
     * The set of feedback tokens provided by the user of this endpoint for the session. This is a set of Boolean properties. The property names should not be relied upon since they may change depending on what tokens are offered to the user.
     */
    tokens?: FeedbackTokenSet;
}
export enum UserFeedbackRating {
    NotRated = "notRated",
    Bad = "bad",
    Poor = "poor",
    Fair = "fair",
    Good = "good",
    Excellent = "excellent",
    UnknownFutureValue = "unknownFutureValue",
}
export enum VideoCodec {
    Unknown = "unknown",
    Invalid = "invalid",
    Av1 = "av1",
    H263 = "h263",
    H264 = "h264",
    H264s = "h264s",
    H264uc = "h264uc",
    H265 = "h265",
    Rtvc1 = "rtvc1",
    RtVideo = "rtVideo",
    Xrtvc1 = "xrtvc1",
    UnknownFutureValue = "unknownFutureValue",
}
export enum WifiBand {
    Unknown = "unknown",
    Frequency24GHz = "frequency24GHz",
    Frequency50GHz = "frequency50GHz",
    Frequency60GHz = "frequency60GHz",
    UnknownFutureValue = "unknownFutureValue",
}
export enum WifiRadioType {
    Unknown = "unknown",
    Wifi80211a = "wifi80211a",
    Wifi80211b = "wifi80211b",
    Wifi80211g = "wifi80211g",
    Wifi80211n = "wifi80211n",
    Wifi80211ac = "wifi80211ac",
    Wifi80211ax = "wifi80211ax",
    UnknownFutureValue = "unknownFutureValue",
}
// tslint:enable
// eslint-enable
