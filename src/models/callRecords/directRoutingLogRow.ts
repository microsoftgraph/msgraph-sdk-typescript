import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function createDirectRoutingLogRowFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoDirectRoutingLogRow;
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function deserializeIntoDirectRoutingLogRow(directRoutingLogRow: DirectRoutingLogRow | undefined = {} as DirectRoutingLogRow) : Record<string, (node: ParseNode) => void> {
    return {
        "calleeNumber": n => { directRoutingLogRow.calleeNumber = n.getStringValue(); },
        "callEndSubReason": n => { directRoutingLogRow.callEndSubReason = n.getNumberValue(); },
        "callerNumber": n => { directRoutingLogRow.callerNumber = n.getStringValue(); },
        "callType": n => { directRoutingLogRow.callType = n.getStringValue(); },
        "correlationId": n => { directRoutingLogRow.correlationId = n.getStringValue(); },
        "duration": n => { directRoutingLogRow.duration = n.getNumberValue(); },
        "endDateTime": n => { directRoutingLogRow.endDateTime = n.getDateValue(); },
        "failureDateTime": n => { directRoutingLogRow.failureDateTime = n.getDateValue(); },
        "finalSipCode": n => { directRoutingLogRow.finalSipCode = n.getNumberValue(); },
        "finalSipCodePhrase": n => { directRoutingLogRow.finalSipCodePhrase = n.getStringValue(); },
        "id": n => { directRoutingLogRow.id = n.getStringValue(); },
        "inviteDateTime": n => { directRoutingLogRow.inviteDateTime = n.getDateValue(); },
        "mediaBypassEnabled": n => { directRoutingLogRow.mediaBypassEnabled = n.getBooleanValue(); },
        "mediaPathLocation": n => { directRoutingLogRow.mediaPathLocation = n.getStringValue(); },
        "@odata.type": n => { directRoutingLogRow.odataType = n.getStringValue(); },
        "signalingLocation": n => { directRoutingLogRow.signalingLocation = n.getStringValue(); },
        "startDateTime": n => { directRoutingLogRow.startDateTime = n.getDateValue(); },
        "successfulCall": n => { directRoutingLogRow.successfulCall = n.getBooleanValue(); },
        "trunkFullyQualifiedDomainName": n => { directRoutingLogRow.trunkFullyQualifiedDomainName = n.getStringValue(); },
        "userDisplayName": n => { directRoutingLogRow.userDisplayName = n.getStringValue(); },
        "userId": n => { directRoutingLogRow.userId = n.getStringValue(); },
        "userPrincipalName": n => { directRoutingLogRow.userPrincipalName = n.getStringValue(); },
    }
}
export interface DirectRoutingLogRow extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Number of the user or bot who received the call. E.164 format, but may include other data.
     */
    calleeNumber?: string;
    /**
     * In addition to the SIP codes, Microsoft has own subcodes that indicate the specific issue.
     */
    callEndSubReason?: number;
    /**
     * Number of the user or bot who made the call. E.164 format, but may include other data.
     */
    callerNumber?: string;
    /**
     * Call type and direction.
     */
    callType?: string;
    /**
     * Identifier for the call that you can use when calling Microsoft Support. GUID.
     */
    correlationId?: string;
    /**
     * Duration of the call in seconds.
     */
    duration?: number;
    /**
     * Only exists for successful (fully established) calls. Time when call ended.
     */
    endDateTime?: Date;
    /**
     * Only exists for failed (not fully established) calls.
     */
    failureDateTime?: Date;
    /**
     * The code with which the call ended, see RFC 3261.
     */
    finalSipCode?: number;
    /**
     * Description of the SIP code and Microsoft subcode.
     */
    finalSipCodePhrase?: string;
    /**
     * Unique call identifier. GUID.
     */
    id?: string;
    /**
     * When the initial invite was sent.
     */
    inviteDateTime?: Date;
    /**
     * Indicates if the trunk was enabled for media bypass or not.
     */
    mediaBypassEnabled?: boolean;
    /**
     * The datacenter used for media path in nonbypass call.
     */
    mediaPathLocation?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The datacenter used for signaling for both bypass and nonbypass calls.
     */
    signalingLocation?: string;
    /**
     * Call start time.For failed and unanswered calls, this can be equal to invite or failure time.
     */
    startDateTime?: Date;
    /**
     * Success or attempt.
     */
    successfulCall?: boolean;
    /**
     * Fully qualified domain name of the session border controller.
     */
    trunkFullyQualifiedDomainName?: string;
    /**
     * Display name of the user.
     */
    userDisplayName?: string;
    /**
     * Calling user's ID in Graph. This and other user info will be null/empty for bot call types. GUID.
     */
    userId?: string;
    /**
     * UserPrincipalName (sign-in name) in Azure Active Directory. This is usually the same as user's SIP Address, and can be same as user's e-mail address.
     */
    userPrincipalName?: string;
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function serializeDirectRoutingLogRow(writer: SerializationWriter, directRoutingLogRow: DirectRoutingLogRow | undefined = {} as DirectRoutingLogRow) : void {
        writer.writeStringValue("calleeNumber", directRoutingLogRow.calleeNumber);
        writer.writeNumberValue("callEndSubReason", directRoutingLogRow.callEndSubReason);
        writer.writeStringValue("callerNumber", directRoutingLogRow.callerNumber);
        writer.writeStringValue("callType", directRoutingLogRow.callType);
        writer.writeStringValue("correlationId", directRoutingLogRow.correlationId);
        writer.writeNumberValue("duration", directRoutingLogRow.duration);
        writer.writeDateValue("endDateTime", directRoutingLogRow.endDateTime);
        writer.writeDateValue("failureDateTime", directRoutingLogRow.failureDateTime);
        writer.writeNumberValue("finalSipCode", directRoutingLogRow.finalSipCode);
        writer.writeStringValue("finalSipCodePhrase", directRoutingLogRow.finalSipCodePhrase);
        writer.writeStringValue("id", directRoutingLogRow.id);
        writer.writeDateValue("inviteDateTime", directRoutingLogRow.inviteDateTime);
        writer.writeBooleanValue("mediaBypassEnabled", directRoutingLogRow.mediaBypassEnabled);
        writer.writeStringValue("mediaPathLocation", directRoutingLogRow.mediaPathLocation);
        writer.writeStringValue("@odata.type", directRoutingLogRow.odataType);
        writer.writeStringValue("signalingLocation", directRoutingLogRow.signalingLocation);
        writer.writeDateValue("startDateTime", directRoutingLogRow.startDateTime);
        writer.writeBooleanValue("successfulCall", directRoutingLogRow.successfulCall);
        writer.writeStringValue("trunkFullyQualifiedDomainName", directRoutingLogRow.trunkFullyQualifiedDomainName);
        writer.writeStringValue("userDisplayName", directRoutingLogRow.userDisplayName);
        writer.writeStringValue("userId", directRoutingLogRow.userId);
        writer.writeStringValue("userPrincipalName", directRoutingLogRow.userPrincipalName);
        writer.writeAdditionalData(directRoutingLogRow.additionalData);
}
