// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
import { deserializeIntoAttributeRuleMembers } from './attributeRuleMembers';
import { deserializeIntoConnectedOrganizationMembers } from './connectedOrganizationMembers';
import { deserializeIntoExternalSponsors } from './externalSponsors';
import { deserializeIntoGroupMembers } from './groupMembers';
import { type RuleBasedSubjectSet } from './identityGovernance';
import { deserializeIntoRuleBasedSubjectSet } from './identityGovernance/ruleBasedSubjectSet';
import { type AttributeRuleMembers, type ConnectedOrganizationMembers, type ExternalSponsors, type GroupMembers, type InternalSponsors, type RequestorManager, type SingleServicePrincipal, type SingleUser, type TargetApplicationOwners, type TargetManager } from './index';
import { deserializeIntoInternalSponsors } from './internalSponsors';
import { deserializeIntoRequestorManager } from './requestorManager';
import { deserializeIntoSingleServicePrincipal } from './singleServicePrincipal';
import { deserializeIntoSingleUser } from './singleUser';
import { deserializeIntoTargetApplicationOwners } from './targetApplicationOwners';
import { deserializeIntoTargetManager } from './targetManager';
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export function createSubjectSetFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.attributeRuleMembers":
                    return deserializeIntoAttributeRuleMembers;
                case "#microsoft.graph.connectedOrganizationMembers":
                    return deserializeIntoConnectedOrganizationMembers;
                case "#microsoft.graph.externalSponsors":
                    return deserializeIntoExternalSponsors;
                case "#microsoft.graph.groupMembers":
                    return deserializeIntoGroupMembers;
                case "#microsoft.graph.identityGovernance.ruleBasedSubjectSet":
                    return deserializeIntoRuleBasedSubjectSet;
                case "#microsoft.graph.internalSponsors":
                    return deserializeIntoInternalSponsors;
                case "#microsoft.graph.requestorManager":
                    return deserializeIntoRequestorManager;
                case "#microsoft.graph.singleServicePrincipal":
                    return deserializeIntoSingleServicePrincipal;
                case "#microsoft.graph.singleUser":
                    return deserializeIntoSingleUser;
                case "#microsoft.graph.targetApplicationOwners":
                    return deserializeIntoTargetApplicationOwners;
                case "#microsoft.graph.targetManager":
                    return deserializeIntoTargetManager;
            }
        }
    }
    return deserializeIntoSubjectSet;
}
export function deserializeIntoSubjectSet(subjectSet: SubjectSet | undefined = {} as SubjectSet) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.type": n => { subjectSet.odataType = n.getStringValue(); },
    }
}
export function serializeSubjectSet(writer: SerializationWriter, subjectSet: SubjectSet | undefined = {} as SubjectSet) : void {
    writer.writeStringValue("@odata.type", subjectSet.odataType);
    writer.writeAdditionalData(subjectSet.additionalData);
}
export interface SubjectSet extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataType property
     */
    odataType?: string;
}
// tslint:enable
// eslint-enable
