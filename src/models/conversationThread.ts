import { deserializeIntoEntity, serializeEntity, type Entity } from './entity';
import { createPostFromDiscriminatorValue, serializePost, type Post } from './post';
import { createRecipientFromDiscriminatorValue, serializeRecipient, type Recipient } from './recipient';
import { type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface ConversationThread extends Entity, Parsable {
    /**
     * The Cc: recipients for the thread. Returned only on $select.
     */
    ccRecipients?: Recipient[];
    /**
     * Indicates whether any of the posts within this thread has at least one attachment. Returned by default.
     */
    hasAttachments?: boolean;
    /**
     * Indicates if the thread is locked. Returned by default.
     */
    isLocked?: boolean;
    /**
     * The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.Returned by default.
     */
    lastDeliveredDateTime?: Date;
    /**
     * The posts property
     */
    posts?: Post[];
    /**
     * A short summary from the body of the latest post in this conversation. Returned by default.
     */
    preview?: string;
    /**
     * The topic of the conversation. This property can be set when the conversation is created, but it cannot be updated. Returned by default.
     */
    topic?: string;
    /**
     * The To: recipients for the thread. Returned only on $select.
     */
    toRecipients?: Recipient[];
    /**
     * All the users that sent a message to this thread. Returned by default.
     */
    uniqueSenders?: string[];
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function createConversationThreadFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    return deserializeIntoConversationThread;
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function deserializeIntoConversationThread(conversationThread: ConversationThread | undefined = {} as ConversationThread) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(conversationThread),
        "ccRecipients": n => { conversationThread.ccRecipients = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "hasAttachments": n => { conversationThread.hasAttachments = n.getBooleanValue(); },
        "isLocked": n => { conversationThread.isLocked = n.getBooleanValue(); },
        "lastDeliveredDateTime": n => { conversationThread.lastDeliveredDateTime = n.getDateValue(); },
        "posts": n => { conversationThread.posts = n.getCollectionOfObjectValues<Post>(createPostFromDiscriminatorValue); },
        "preview": n => { conversationThread.preview = n.getStringValue(); },
        "topic": n => { conversationThread.topic = n.getStringValue(); },
        "toRecipients": n => { conversationThread.toRecipients = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "uniqueSenders": n => { conversationThread.uniqueSenders = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
// tslint:disable
// eslint-disable
// Generated by Microsoft Kiota
export function serializeConversationThread(writer: SerializationWriter, conversationThread: ConversationThread | undefined = {} as ConversationThread) : void {
        serializeEntity(writer, conversationThread)
        writer.writeCollectionOfObjectValues<Recipient>("ccRecipients", conversationThread.ccRecipients, );
        writer.writeBooleanValue("hasAttachments", conversationThread.hasAttachments);
        writer.writeBooleanValue("isLocked", conversationThread.isLocked);
        writer.writeDateValue("lastDeliveredDateTime", conversationThread.lastDeliveredDateTime);
        writer.writeCollectionOfObjectValues<Post>("posts", conversationThread.posts, );
        writer.writeStringValue("preview", conversationThread.preview);
        writer.writeStringValue("topic", conversationThread.topic);
        writer.writeCollectionOfObjectValues<Recipient>("toRecipients", conversationThread.toRecipients, );
        writer.writeCollectionOfPrimitiveValues<string>("uniqueSenders", conversationThread.uniqueSenders);
}
