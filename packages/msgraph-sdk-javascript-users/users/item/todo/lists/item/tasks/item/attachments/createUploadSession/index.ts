/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
import { createAttachmentInfoFromDiscriminatorValue, createUploadSessionFromDiscriminatorValue, serializeAttachmentInfo, serializeUploadSession, type AttachmentInfo, type UploadSession } from '@microsoft/msgraph-sdk-javascript/models/';
import { createODataErrorFromDiscriminatorValue, type ODataError } from '@microsoft/msgraph-sdk-javascript/models/oDataErrors/';
import { type AdditionalDataHolder, type BackedModel, type BackingStore, type BaseRequestBuilder, type Parsable, type ParsableFactory, type ParseNode, type RequestConfiguration, type RequestInformation, type RequestsMetadata, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a createUploadSessionPostRequestBody
 */
export function createCreateUploadSessionPostRequestBodyFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoCreateUploadSessionPostRequestBody;
}
export interface CreateUploadSessionPostRequestBody extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The attachmentInfo property
     */
    attachmentInfo?: AttachmentInfo;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
}
/**
 * Provides operations to call the createUploadSession method.
 */
export interface CreateUploadSessionRequestBuilder extends BaseRequestBuilder<CreateUploadSessionRequestBuilder> {
    /**
     * Create an upload session to iteratively upload ranges of a file as an attachment to a todoTask. As part of the response, this action returns an upload URL that you can use in subsequent sequential PUT queries. The request headers for each PUT operation let you specify the exact range of bytes to be uploaded. This allows the transfer to be resumed, in case the network connection is dropped during the upload. The following are the steps to attach a file to a Microsoft To Do task using an upload session: For an example that describes the end-to-end attachment process, see attach files to a To Do task.
     * @param body The request body
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns a Promise of UploadSession
     * @see {@link https://learn.microsoft.com/graph/api/taskfileattachment-createuploadsession?view=graph-rest-1.0|Find more info here}
     */
     post(body: CreateUploadSessionPostRequestBody, requestConfiguration?: RequestConfiguration<object> | undefined) : Promise<UploadSession | undefined>;
    /**
     * Create an upload session to iteratively upload ranges of a file as an attachment to a todoTask. As part of the response, this action returns an upload URL that you can use in subsequent sequential PUT queries. The request headers for each PUT operation let you specify the exact range of bytes to be uploaded. This allows the transfer to be resumed, in case the network connection is dropped during the upload. The following are the steps to attach a file to a Microsoft To Do task using an upload session: For an example that describes the end-to-end attachment process, see attach files to a To Do task.
     * @param body The request body
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns a RequestInformation
     */
     toPostRequestInformation(body: CreateUploadSessionPostRequestBody, requestConfiguration?: RequestConfiguration<object> | undefined) : RequestInformation;
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoCreateUploadSessionPostRequestBody(createUploadSessionPostRequestBody: CreateUploadSessionPostRequestBody | undefined = {} as CreateUploadSessionPostRequestBody) : Record<string, (node: ParseNode) => void> {
    return {
        "attachmentInfo": n => { createUploadSessionPostRequestBody.attachmentInfo = n.getObjectValue<AttachmentInfo>(createAttachmentInfoFromDiscriminatorValue); },
        "backingStoreEnabled": n => { createUploadSessionPostRequestBody.backingStoreEnabled = true; },
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCreateUploadSessionPostRequestBody(writer: SerializationWriter, createUploadSessionPostRequestBody: CreateUploadSessionPostRequestBody | undefined = {} as CreateUploadSessionPostRequestBody) : void {
    writer.writeObjectValue<AttachmentInfo>("attachmentInfo", createUploadSessionPostRequestBody.attachmentInfo, serializeAttachmentInfo);
    writer.writeAdditionalData(createUploadSessionPostRequestBody.additionalData);
}
/**
 * Metadata for all the requests in the request builder.
 */
export const CreateUploadSessionRequestBuilderRequestsMetadata: RequestsMetadata = {
    post: {
        responseBodyContentType: "application/json",
        errorMappings: {
            _4XX: createODataErrorFromDiscriminatorValue as ParsableFactory<Parsable>,
            _5XX: createODataErrorFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "sendAsync",
        responseBodyFactory:  createUploadSessionFromDiscriminatorValue,
        requestBodyContentType: "application/json",
        requestBodySerializer: serializeCreateUploadSessionPostRequestBody,
        requestInformationContentSetMethod: "setContentFromParsable",
    },
};
/**
 * Uri template for the request builder.
 */
export const CreateUploadSessionRequestBuilderUriTemplate = "{+baseurl}/users/{user%2Did}/todo/lists/{todoTaskList%2Did}/tasks/{todoTask%2Did}/attachments/createUploadSession";
/* tslint:enable */
/* eslint-enable */
