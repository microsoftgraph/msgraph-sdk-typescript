/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { BinaryOperator, BinaryOperatorObject, createPublicErrorFromDiscriminatorValue, deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, serializeBaseCollectionPaginationCountResponse, serializeEntity, serializePublicError, type BaseCollectionPaginationCountResponse, type Entity, type PublicError } from '../index.js';
// @ts-ignore
import { createUntypedNodeFromDiscriminatorValue, type AdditionalDataHolder, type BackedModel, type BackingStore, type Parsable, type ParseNode, type SerializationWriter, UntypedNode } from '@microsoft/kiota-abstractions';

export type AccessType = (typeof AccessTypeObject)[keyof typeof AccessTypeObject];
export interface Acl extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The accessType property
     */
    accessType?: AccessType;
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The type property
     */
    type?: AclType;
    /**
     * The unique identifer of the identity. For Microsoft Entra identities, value is set to the object identifier of the user, group or tenant for types user, group and everyone (and everyoneExceptGuests) respectively. For external groups value is set to the ID of the externalGroup
     */
    value?: string;
}
export type AclType = (typeof AclTypeObject)[keyof typeof AclTypeObject];
export interface ActivitySettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Specifies configurations to identify an externalItem based on a shared URL.
     */
    urlToItemResolvers?: UrlToItemResolverBase[];
}
export interface Configuration extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * A collection of application IDs for registered Microsoft Entra apps that are allowed to manage the externalConnection and to index content in the externalConnection.
     */
    authorizedAppIds?: string[];
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface ConnectionOperation extends Entity, Parsable {
    /**
     * If status is failed, provides more information about the error that caused the failure.
     */
    errorEscaped?: PublicError;
    /**
     * Indicates the status of the asynchronous operation. Possible values are: unspecified, inprogress, completed, failed, unknownFutureValue.
     */
    status?: ConnectionOperationStatus;
}
export interface ConnectionOperationCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ConnectionOperation[];
}
export type ConnectionOperationStatus = (typeof ConnectionOperationStatusObject)[keyof typeof ConnectionOperationStatusObject];
export type ConnectionState = (typeof ConnectionStateObject)[keyof typeof ConnectionStateObject];
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Acl}
 */
export function createAclFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAcl;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ActivitySettings}
 */
export function createActivitySettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoActivitySettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Configuration}
 */
export function createConfigurationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoConfiguration;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ConnectionOperationCollectionResponse}
 */
export function createConnectionOperationCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoConnectionOperationCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ConnectionOperation}
 */
export function createConnectionOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoConnectionOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DisplayTemplate}
 */
export function createDisplayTemplateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDisplayTemplate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExternalActivityCollectionResponse}
 */
export function createExternalActivityCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExternalActivityCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExternalActivity}
 */
export function createExternalActivityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.externalConnectors.externalActivityResult":
                    return deserializeIntoExternalActivityResult;
            }
        }
    }
    return deserializeIntoExternalActivity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExternalActivityResult}
 */
export function createExternalActivityResultFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExternalActivityResult;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExternalConnectionCollectionResponse}
 */
export function createExternalConnectionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExternalConnectionCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExternalConnection}
 */
export function createExternalConnectionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExternalConnection;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {External}
 */
export function createExternalFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExternal;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExternalGroupCollectionResponse}
 */
export function createExternalGroupCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExternalGroupCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExternalGroup}
 */
export function createExternalGroupFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExternalGroup;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExternalItemCollectionResponse}
 */
export function createExternalItemCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExternalItemCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExternalItemContent}
 */
export function createExternalItemContentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExternalItemContent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExternalItem}
 */
export function createExternalItemFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExternalItem;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IdentityCollectionResponse}
 */
export function createIdentityCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIdentityCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Identity}
 */
export function createIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ItemIdResolver}
 */
export function createItemIdResolverFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoItemIdResolver;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Properties}
 */
export function createPropertiesFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProperties;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Property}
 */
export function createPropertyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProperty;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PropertyRule}
 */
export function createPropertyRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPropertyRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Schema}
 */
export function createSchemaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSchema;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SearchSettings}
 */
export function createSearchSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSearchSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UrlMatchInfo}
 */
export function createUrlMatchInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUrlMatchInfo;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UrlToItemResolverBase}
 */
export function createUrlToItemResolverBaseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.externalConnectors.itemIdResolver":
                    return deserializeIntoItemIdResolver;
            }
        }
    }
    return deserializeIntoUrlToItemResolverBase;
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAcl(acl: Partial<Acl> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "accessType": n => { acl.accessType = n.getEnumValue<AccessType>(AccessTypeObject); },
        "backingStoreEnabled": n => { acl.backingStoreEnabled = true; },
        "@odata.type": n => { acl.odataType = n.getStringValue(); },
        "type": n => { acl.type = n.getEnumValue<AclType>(AclTypeObject); },
        "value": n => { acl.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoActivitySettings(activitySettings: Partial<ActivitySettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { activitySettings.backingStoreEnabled = true; },
        "@odata.type": n => { activitySettings.odataType = n.getStringValue(); },
        "urlToItemResolvers": n => { activitySettings.urlToItemResolvers = n.getCollectionOfObjectValues<UrlToItemResolverBase>(createUrlToItemResolverBaseFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoConfiguration(configuration: Partial<Configuration> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "authorizedAppIds": n => { configuration.authorizedAppIds = n.getCollectionOfPrimitiveValues<string>(); },
        "backingStoreEnabled": n => { configuration.backingStoreEnabled = true; },
        "@odata.type": n => { configuration.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoConnectionOperation(connectionOperation: Partial<ConnectionOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(connectionOperation),
        "error": n => { connectionOperation.errorEscaped = n.getObjectValue<PublicError>(createPublicErrorFromDiscriminatorValue); },
        "status": n => { connectionOperation.status = n.getEnumValue<ConnectionOperationStatus>(ConnectionOperationStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoConnectionOperationCollectionResponse(connectionOperationCollectionResponse: Partial<ConnectionOperationCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(connectionOperationCollectionResponse),
        "value": n => { connectionOperationCollectionResponse.value = n.getCollectionOfObjectValues<ConnectionOperation>(createConnectionOperationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDisplayTemplate(displayTemplate: Partial<DisplayTemplate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { displayTemplate.backingStoreEnabled = true; },
        "id": n => { displayTemplate.id = n.getStringValue(); },
        "layout": n => { displayTemplate.layout = n.getObjectValue<UntypedNode>(createUntypedNodeFromDiscriminatorValue); },
        "@odata.type": n => { displayTemplate.odataType = n.getStringValue(); },
        "priority": n => { displayTemplate.priority = n.getNumberValue(); },
        "rules": n => { displayTemplate.rules = n.getCollectionOfObjectValues<PropertyRule>(createPropertyRuleFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoExternal(external: Partial<External> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { external.backingStoreEnabled = true; },
        "connections": n => { external.connections = n.getCollectionOfObjectValues<ExternalConnection>(createExternalConnectionFromDiscriminatorValue); },
        "@odata.type": n => { external.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoExternalActivity(externalActivity: Partial<ExternalActivity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(externalActivity),
        "performedBy": n => { externalActivity.performedBy = n.getObjectValue<Identity>(createIdentityFromDiscriminatorValue); },
        "startDateTime": n => { externalActivity.startDateTime = n.getDateValue(); },
        "type": n => { externalActivity.type = n.getEnumValue<ExternalActivityType>(ExternalActivityTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoExternalActivityCollectionResponse(externalActivityCollectionResponse: Partial<ExternalActivityCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(externalActivityCollectionResponse),
        "value": n => { externalActivityCollectionResponse.value = n.getCollectionOfObjectValues<ExternalActivity>(createExternalActivityFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoExternalActivityResult(externalActivityResult: Partial<ExternalActivityResult> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoExternalActivity(externalActivityResult),
        "error": n => { externalActivityResult.errorEscaped = n.getObjectValue<PublicError>(createPublicErrorFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoExternalConnection(externalConnection: Partial<ExternalConnection> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(externalConnection),
        "activitySettings": n => { externalConnection.activitySettings = n.getObjectValue<ActivitySettings>(createActivitySettingsFromDiscriminatorValue); },
        "configuration": n => { externalConnection.configuration = n.getObjectValue<Configuration>(createConfigurationFromDiscriminatorValue); },
        "connectorId": n => { externalConnection.connectorId = n.getStringValue(); },
        "description": n => { externalConnection.description = n.getStringValue(); },
        "groups": n => { externalConnection.groups = n.getCollectionOfObjectValues<ExternalGroup>(createExternalGroupFromDiscriminatorValue); },
        "items": n => { externalConnection.items = n.getCollectionOfObjectValues<ExternalItem>(createExternalItemFromDiscriminatorValue); },
        "name": n => { externalConnection.name = n.getStringValue(); },
        "operations": n => { externalConnection.operations = n.getCollectionOfObjectValues<ConnectionOperation>(createConnectionOperationFromDiscriminatorValue); },
        "schema": n => { externalConnection.schema = n.getObjectValue<Schema>(createSchemaFromDiscriminatorValue); },
        "searchSettings": n => { externalConnection.searchSettings = n.getObjectValue<SearchSettings>(createSearchSettingsFromDiscriminatorValue); },
        "state": n => { externalConnection.state = n.getEnumValue<ConnectionState>(ConnectionStateObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoExternalConnectionCollectionResponse(externalConnectionCollectionResponse: Partial<ExternalConnectionCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(externalConnectionCollectionResponse),
        "value": n => { externalConnectionCollectionResponse.value = n.getCollectionOfObjectValues<ExternalConnection>(createExternalConnectionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoExternalGroup(externalGroup: Partial<ExternalGroup> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(externalGroup),
        "description": n => { externalGroup.description = n.getStringValue(); },
        "displayName": n => { externalGroup.displayName = n.getStringValue(); },
        "members": n => { externalGroup.members = n.getCollectionOfObjectValues<Identity>(createIdentityFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoExternalGroupCollectionResponse(externalGroupCollectionResponse: Partial<ExternalGroupCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(externalGroupCollectionResponse),
        "value": n => { externalGroupCollectionResponse.value = n.getCollectionOfObjectValues<ExternalGroup>(createExternalGroupFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoExternalItem(externalItem: Partial<ExternalItem> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(externalItem),
        "acl": n => { externalItem.acl = n.getCollectionOfObjectValues<Acl>(createAclFromDiscriminatorValue); },
        "activities": n => { externalItem.activities = n.getCollectionOfObjectValues<ExternalActivity>(createExternalActivityFromDiscriminatorValue); },
        "content": n => { externalItem.content = n.getObjectValue<ExternalItemContent>(createExternalItemContentFromDiscriminatorValue); },
        "properties": n => { externalItem.properties = n.getObjectValue<Properties>(createPropertiesFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoExternalItemCollectionResponse(externalItemCollectionResponse: Partial<ExternalItemCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(externalItemCollectionResponse),
        "value": n => { externalItemCollectionResponse.value = n.getCollectionOfObjectValues<ExternalItem>(createExternalItemFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoExternalItemContent(externalItemContent: Partial<ExternalItemContent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { externalItemContent.backingStoreEnabled = true; },
        "@odata.type": n => { externalItemContent.odataType = n.getStringValue(); },
        "type": n => { externalItemContent.type = n.getEnumValue<ExternalItemContentType>(ExternalItemContentTypeObject); },
        "value": n => { externalItemContent.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIdentity(identity: Partial<Identity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(identity),
        "type": n => { identity.type = n.getEnumValue<IdentityType>(IdentityTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIdentityCollectionResponse(identityCollectionResponse: Partial<IdentityCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(identityCollectionResponse),
        "value": n => { identityCollectionResponse.value = n.getCollectionOfObjectValues<Identity>(createIdentityFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoItemIdResolver(itemIdResolver: Partial<ItemIdResolver> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoUrlToItemResolverBase(itemIdResolver),
        "itemId": n => { itemIdResolver.itemId = n.getStringValue(); },
        "urlMatchInfo": n => { itemIdResolver.urlMatchInfo = n.getObjectValue<UrlMatchInfo>(createUrlMatchInfoFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProperties(properties: Partial<Properties> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { properties.backingStoreEnabled = true; },
        "@odata.type": n => { properties.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProperty(property: Partial<Property> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "aliases": n => { property.aliases = n.getCollectionOfPrimitiveValues<string>(); },
        "backingStoreEnabled": n => { property.backingStoreEnabled = true; },
        "isQueryable": n => { property.isQueryable = n.getBooleanValue(); },
        "isRefinable": n => { property.isRefinable = n.getBooleanValue(); },
        "isRetrievable": n => { property.isRetrievable = n.getBooleanValue(); },
        "isSearchable": n => { property.isSearchable = n.getBooleanValue(); },
        "labels": n => { property.labels = n.getCollectionOfEnumValues<Label>(LabelObject); },
        "name": n => { property.name = n.getStringValue(); },
        "@odata.type": n => { property.odataType = n.getStringValue(); },
        "type": n => { property.type = n.getEnumValue<PropertyType>(PropertyTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoPropertyRule(propertyRule: Partial<PropertyRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { propertyRule.backingStoreEnabled = true; },
        "@odata.type": n => { propertyRule.odataType = n.getStringValue(); },
        "operation": n => { propertyRule.operation = n.getEnumValue<RuleOperation>(RuleOperationObject); },
        "property": n => { propertyRule.property = n.getStringValue(); },
        "values": n => { propertyRule.values = n.getCollectionOfPrimitiveValues<string>(); },
        "valuesJoinedBy": n => { propertyRule.valuesJoinedBy = n.getEnumValue<BinaryOperator>(BinaryOperatorObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSchema(schema: Partial<Schema> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(schema),
        "baseType": n => { schema.baseType = n.getStringValue(); },
        "properties": n => { schema.properties = n.getCollectionOfObjectValues<Property>(createPropertyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSearchSettings(searchSettings: Partial<SearchSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { searchSettings.backingStoreEnabled = true; },
        "@odata.type": n => { searchSettings.odataType = n.getStringValue(); },
        "searchResultTemplates": n => { searchSettings.searchResultTemplates = n.getCollectionOfObjectValues<DisplayTemplate>(createDisplayTemplateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUrlMatchInfo(urlMatchInfo: Partial<UrlMatchInfo> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { urlMatchInfo.backingStoreEnabled = true; },
        "baseUrls": n => { urlMatchInfo.baseUrls = n.getCollectionOfPrimitiveValues<string>(); },
        "@odata.type": n => { urlMatchInfo.odataType = n.getStringValue(); },
        "urlPattern": n => { urlMatchInfo.urlPattern = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUrlToItemResolverBase(urlToItemResolverBase: Partial<UrlToItemResolverBase> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { urlToItemResolverBase.backingStoreEnabled = true; },
        "@odata.type": n => { urlToItemResolverBase.odataType = n.getStringValue(); },
        "priority": n => { urlToItemResolverBase.priority = n.getNumberValue(); },
    }
}
export interface DisplayTemplate extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The text identifier for the display template; for example, contosoTickets. Maximum 16 characters. Only alphanumeric characters allowed.
     */
    id?: string;
    /**
     * The definition of the content's appearance, represented by an Adaptive Card, which is a JSON-serialized card object model.
     */
    layout?: UntypedNode;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Defines the priority of a display template. A display template with priority 1 is evaluated before a template with priority 4. Gaps in priority values are supported. Must be positive value.
     */
    priority?: number;
    /**
     * Specifies additional rules for selecting this display template based on the item schema. Optional.
     */
    rules?: PropertyRule[];
}
export interface External extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The connections property
     */
    connections?: ExternalConnection[];
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface ExternalActivity extends Entity, Parsable {
    /**
     * Represents an identity used to identify who is responsible for the activity.
     */
    performedBy?: Identity;
    /**
     * The date and time when the particular activity occurred. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    startDateTime?: Date;
    /**
     * The type property
     */
    type?: ExternalActivityType;
}
export interface ExternalActivityCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ExternalActivity[];
}
export interface ExternalActivityResult extends ExternalActivity, Parsable {
    /**
     * Error information that explains the failure to process an external activity.
     */
    errorEscaped?: PublicError;
}
export type ExternalActivityType = (typeof ExternalActivityTypeObject)[keyof typeof ExternalActivityTypeObject];
export interface ExternalConnection extends Entity, Parsable {
    /**
     * Collects configurable settings related to activities involving connector content.
     */
    activitySettings?: ActivitySettings;
    /**
     * Specifies additional application IDs that are allowed to manage the connection and to index content in the connection. Optional.
     */
    configuration?: Configuration;
    /**
     * The Teams app ID. Optional.
     */
    connectorId?: string;
    /**
     * Description of the connection displayed in the Microsoft 365 admin center. Optional.
     */
    description?: string;
    /**
     * The groups property
     */
    groups?: ExternalGroup[];
    /**
     * The items property
     */
    items?: ExternalItem[];
    /**
     * The display name of the connection to be displayed in the Microsoft 365 admin center. Maximum length of 128 characters. Required.
     */
    name?: string;
    /**
     * The operations property
     */
    operations?: ConnectionOperation[];
    /**
     * The schema property
     */
    schema?: Schema;
    /**
     * The settings configuring the search experience for content in this connection, such as the display templates for search results.
     */
    searchSettings?: SearchSettings;
    /**
     * Indicates the current state of the connection. Possible values are: draft, ready, obsolete, limitExceeded, unknownFutureValue.
     */
    state?: ConnectionState;
}
export interface ExternalConnectionCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ExternalConnection[];
}
export interface ExternalGroup extends Entity, Parsable {
    /**
     * The description of the external group. Optional.
     */
    description?: string;
    /**
     * The friendly name of the external group. Optional.
     */
    displayName?: string;
    /**
     * A member added to an externalGroup. You can add Microsoft Entra users, Microsoft Entra groups, or an externalGroup as members.
     */
    members?: Identity[];
}
export interface ExternalGroupCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ExternalGroup[];
}
export interface ExternalItem extends Entity, Parsable {
    /**
     * An array of access control entries. Each entry specifies the access granted to a user or group. Required.
     */
    acl?: Acl[];
    /**
     * Returns a list of activities performed on the item. Write-only.
     */
    activities?: ExternalActivity[];
    /**
     * A plain-text  representation of the contents of the item. The text in this property is full-text indexed. Optional.
     */
    content?: ExternalItemContent;
    /**
     * A property bag with the properties of the item. The properties MUST conform to the schema defined for the externalConnection. Required.
     */
    properties?: Properties;
}
export interface ExternalItemCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ExternalItem[];
}
export interface ExternalItemContent extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The type property
     */
    type?: ExternalItemContentType;
    /**
     * The content for the externalItem. Required.
     */
    value?: string;
}
export type ExternalItemContentType = (typeof ExternalItemContentTypeObject)[keyof typeof ExternalItemContentTypeObject];
export interface Identity extends Entity, Parsable {
    /**
     * The type of identity. Possible values are: user or group for Microsoft Entra identities and externalgroup for groups in an external system.
     */
    type?: IdentityType;
}
export interface IdentityCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Identity[];
}
export type IdentityType = (typeof IdentityTypeObject)[keyof typeof IdentityTypeObject];
export interface ItemIdResolver extends Parsable, UrlToItemResolverBase {
    /**
     * Pattern that specifies how to form the ID of the external item that the URL represents. The named groups from the regular expression in urlPattern within the urlMatchInfo can be referenced by inserting the group name inside curly brackets.
     */
    itemId?: string;
    /**
     * Configurations to match and resolve URL.
     */
    urlMatchInfo?: UrlMatchInfo;
}
export type Label = (typeof LabelObject)[keyof typeof LabelObject];
export interface Properties extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface Property extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * A set of aliases or a friendly name for the property. Maximum 32 characters. Only alphanumeric characters allowed. For example, each string may not contain control characters, whitespace, or any of the following: :, ;, ,, (, ), [, ], {, }, %, $, +, !, *, =, &, ?, @, #, /, ~, ', ', <, >, `, ^. Optional.
     */
    aliases?: string[];
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Specifies if the property is queryable. Queryable properties can be used in Keyword Query Language (KQL) queries. Optional.
     */
    isQueryable?: boolean;
    /**
     * Specifies if the property is refinable.  Refinable properties can be used to filter search results in the Search API and add a refiner control in the Microsoft Search user experience. Optional.
     */
    isRefinable?: boolean;
    /**
     * Specifies if the property is retrievable. Retrievable properties are returned in the result set when items are returned by the search API. Retrievable properties are also available to add to the display template used to render search results. Optional.
     */
    isRetrievable?: boolean;
    /**
     * Specifies if the property is searchable. Only properties of type String or StringCollection can be searchable. Nonsearchable properties aren't added to the search index. Optional.
     */
    isSearchable?: boolean;
    /**
     * Specifies one or more well-known tags added against a property. Labels help Microsoft Search understand the semantics of the data in the connection. Adding appropriate labels would result in an enhanced search experience (for example, better relevance). Optional.The possible values are: title, url, createdBy, lastModifiedBy, authors, createdDateTime, lastModifiedDateTime, fileName, fileExtension, unknownFutureValue, iconUrl. You must use the Prefer: include-unknown-enum-members request header to get the following value in this evolvable enum: iconUrl.
     */
    labels?: Label[];
    /**
     * The name of the property. Maximum 32 characters. Only alphanumeric characters allowed. For example, each string may not contain control characters, whitespace, or any of the following: :, ;, ,, (, ), [, ], {, }, %, $, +, !, *, =, &, ?, @, #, /, ~, ', ', <, >, `, ^.  Required.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The type property
     */
    type?: PropertyType;
}
export interface PropertyRule extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The operation property
     */
    operation?: RuleOperation;
    /**
     * The property from the externalItem schema. Required.
     */
    property?: string;
    /**
     * A collection with one or many strings. One or more specified strings are matched with the specified property using the specified operation. Required.
     */
    values?: string[];
    /**
     * The valuesJoinedBy property
     */
    valuesJoinedBy?: BinaryOperator;
}
export type PropertyType = (typeof PropertyTypeObject)[keyof typeof PropertyTypeObject];
export type RuleOperation = (typeof RuleOperationObject)[keyof typeof RuleOperationObject];
export interface Schema extends Entity, Parsable {
    /**
     * Must be set to microsoft.graph.externalConnector.externalItem. Required.
     */
    baseType?: string;
    /**
     * The properties defined for the items in the connection. The minimum number of properties is one, the maximum is 128.
     */
    properties?: Property[];
}
export interface SearchSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Enables the developer to define the appearance of the content and configure conditions that dictate when the template should be displayed. Maximum of 2 search result templates per connection.
     */
    searchResultTemplates?: DisplayTemplate[];
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAcl(writer: SerializationWriter, acl: Partial<Acl> | undefined = {}) : void {
    writer.writeEnumValue<AccessType>("accessType", acl.accessType);
    writer.writeStringValue("@odata.type", acl.odataType);
    writer.writeEnumValue<AclType>("type", acl.type);
    writer.writeStringValue("value", acl.value);
    writer.writeAdditionalData(acl.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeActivitySettings(writer: SerializationWriter, activitySettings: Partial<ActivitySettings> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", activitySettings.odataType);
    writer.writeCollectionOfObjectValues<UrlToItemResolverBase>("urlToItemResolvers", activitySettings.urlToItemResolvers, serializeUrlToItemResolverBase);
    writer.writeAdditionalData(activitySettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeConfiguration(writer: SerializationWriter, configuration: Partial<Configuration> | undefined = {}) : void {
    writer.writeCollectionOfPrimitiveValues<string>("authorizedAppIds", configuration.authorizedAppIds);
    writer.writeStringValue("@odata.type", configuration.odataType);
    writer.writeAdditionalData(configuration.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeConnectionOperation(writer: SerializationWriter, connectionOperation: Partial<ConnectionOperation> | undefined = {}) : void {
    serializeEntity(writer, connectionOperation)
    writer.writeObjectValue<PublicError>("error", connectionOperation.errorEscaped, serializePublicError);
    writer.writeEnumValue<ConnectionOperationStatus>("status", connectionOperation.status);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeConnectionOperationCollectionResponse(writer: SerializationWriter, connectionOperationCollectionResponse: Partial<ConnectionOperationCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, connectionOperationCollectionResponse)
    writer.writeCollectionOfObjectValues<ConnectionOperation>("value", connectionOperationCollectionResponse.value, serializeConnectionOperation);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDisplayTemplate(writer: SerializationWriter, displayTemplate: Partial<DisplayTemplate> | undefined = {}) : void {
    writer.writeStringValue("id", displayTemplate.id);
    writer.writeObjectValue("layout", displayTemplate.layout);
    writer.writeStringValue("@odata.type", displayTemplate.odataType);
    writer.writeNumberValue("priority", displayTemplate.priority);
    writer.writeCollectionOfObjectValues<PropertyRule>("rules", displayTemplate.rules, serializePropertyRule);
    writer.writeAdditionalData(displayTemplate.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExternal(writer: SerializationWriter, external: Partial<External> | undefined = {}) : void {
    writer.writeCollectionOfObjectValues<ExternalConnection>("connections", external.connections, serializeExternalConnection);
    writer.writeStringValue("@odata.type", external.odataType);
    writer.writeAdditionalData(external.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExternalActivity(writer: SerializationWriter, externalActivity: Partial<ExternalActivity> | undefined = {}) : void {
    serializeEntity(writer, externalActivity)
    writer.writeObjectValue<Identity>("performedBy", externalActivity.performedBy, serializeIdentity);
    writer.writeDateValue("startDateTime", externalActivity.startDateTime);
    writer.writeEnumValue<ExternalActivityType>("type", externalActivity.type);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExternalActivityCollectionResponse(writer: SerializationWriter, externalActivityCollectionResponse: Partial<ExternalActivityCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, externalActivityCollectionResponse)
    writer.writeCollectionOfObjectValues<ExternalActivity>("value", externalActivityCollectionResponse.value, serializeExternalActivity);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExternalActivityResult(writer: SerializationWriter, externalActivityResult: Partial<ExternalActivityResult> | undefined = {}) : void {
    serializeExternalActivity(writer, externalActivityResult)
    writer.writeObjectValue<PublicError>("error", externalActivityResult.errorEscaped, serializePublicError);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExternalConnection(writer: SerializationWriter, externalConnection: Partial<ExternalConnection> | undefined = {}) : void {
    serializeEntity(writer, externalConnection)
    writer.writeObjectValue<ActivitySettings>("activitySettings", externalConnection.activitySettings, serializeActivitySettings);
    writer.writeObjectValue<Configuration>("configuration", externalConnection.configuration, serializeConfiguration);
    writer.writeStringValue("connectorId", externalConnection.connectorId);
    writer.writeStringValue("description", externalConnection.description);
    writer.writeCollectionOfObjectValues<ExternalGroup>("groups", externalConnection.groups, serializeExternalGroup);
    writer.writeCollectionOfObjectValues<ExternalItem>("items", externalConnection.items, serializeExternalItem);
    writer.writeStringValue("name", externalConnection.name);
    writer.writeCollectionOfObjectValues<ConnectionOperation>("operations", externalConnection.operations, serializeConnectionOperation);
    writer.writeObjectValue<Schema>("schema", externalConnection.schema, serializeSchema);
    writer.writeObjectValue<SearchSettings>("searchSettings", externalConnection.searchSettings, serializeSearchSettings);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExternalConnectionCollectionResponse(writer: SerializationWriter, externalConnectionCollectionResponse: Partial<ExternalConnectionCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, externalConnectionCollectionResponse)
    writer.writeCollectionOfObjectValues<ExternalConnection>("value", externalConnectionCollectionResponse.value, serializeExternalConnection);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExternalGroup(writer: SerializationWriter, externalGroup: Partial<ExternalGroup> | undefined = {}) : void {
    serializeEntity(writer, externalGroup)
    writer.writeStringValue("description", externalGroup.description);
    writer.writeStringValue("displayName", externalGroup.displayName);
    writer.writeCollectionOfObjectValues<Identity>("members", externalGroup.members, serializeIdentity);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExternalGroupCollectionResponse(writer: SerializationWriter, externalGroupCollectionResponse: Partial<ExternalGroupCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, externalGroupCollectionResponse)
    writer.writeCollectionOfObjectValues<ExternalGroup>("value", externalGroupCollectionResponse.value, serializeExternalGroup);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExternalItem(writer: SerializationWriter, externalItem: Partial<ExternalItem> | undefined = {}) : void {
    serializeEntity(writer, externalItem)
    writer.writeCollectionOfObjectValues<Acl>("acl", externalItem.acl, serializeAcl);
    writer.writeCollectionOfObjectValues<ExternalActivity>("activities", externalItem.activities, serializeExternalActivity);
    writer.writeObjectValue<ExternalItemContent>("content", externalItem.content, serializeExternalItemContent);
    writer.writeObjectValue<Properties>("properties", externalItem.properties, serializeProperties);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExternalItemCollectionResponse(writer: SerializationWriter, externalItemCollectionResponse: Partial<ExternalItemCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, externalItemCollectionResponse)
    writer.writeCollectionOfObjectValues<ExternalItem>("value", externalItemCollectionResponse.value, serializeExternalItem);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExternalItemContent(writer: SerializationWriter, externalItemContent: Partial<ExternalItemContent> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", externalItemContent.odataType);
    writer.writeEnumValue<ExternalItemContentType>("type", externalItemContent.type);
    writer.writeStringValue("value", externalItemContent.value);
    writer.writeAdditionalData(externalItemContent.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIdentity(writer: SerializationWriter, identity: Partial<Identity> | undefined = {}) : void {
    serializeEntity(writer, identity)
    writer.writeEnumValue<IdentityType>("type", identity.type);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIdentityCollectionResponse(writer: SerializationWriter, identityCollectionResponse: Partial<IdentityCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, identityCollectionResponse)
    writer.writeCollectionOfObjectValues<Identity>("value", identityCollectionResponse.value, serializeIdentity);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeItemIdResolver(writer: SerializationWriter, itemIdResolver: Partial<ItemIdResolver> | undefined = {}) : void {
    serializeUrlToItemResolverBase(writer, itemIdResolver)
    writer.writeStringValue("itemId", itemIdResolver.itemId);
    writer.writeObjectValue<UrlMatchInfo>("urlMatchInfo", itemIdResolver.urlMatchInfo, serializeUrlMatchInfo);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProperties(writer: SerializationWriter, properties: Partial<Properties> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", properties.odataType);
    writer.writeAdditionalData(properties.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProperty(writer: SerializationWriter, property: Partial<Property> | undefined = {}) : void {
    writer.writeCollectionOfPrimitiveValues<string>("aliases", property.aliases);
    writer.writeBooleanValue("isQueryable", property.isQueryable);
    writer.writeBooleanValue("isRefinable", property.isRefinable);
    writer.writeBooleanValue("isRetrievable", property.isRetrievable);
    writer.writeBooleanValue("isSearchable", property.isSearchable);
    if(property.labels)
    writer.writeEnumValue<Label>("labels", ...property.labels);
    writer.writeStringValue("name", property.name);
    writer.writeStringValue("@odata.type", property.odataType);
    writer.writeEnumValue<PropertyType>("type", property.type);
    writer.writeAdditionalData(property.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializePropertyRule(writer: SerializationWriter, propertyRule: Partial<PropertyRule> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", propertyRule.odataType);
    writer.writeEnumValue<RuleOperation>("operation", propertyRule.operation);
    writer.writeStringValue("property", propertyRule.property);
    writer.writeCollectionOfPrimitiveValues<string>("values", propertyRule.values);
    writer.writeEnumValue<BinaryOperator>("valuesJoinedBy", propertyRule.valuesJoinedBy);
    writer.writeAdditionalData(propertyRule.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSchema(writer: SerializationWriter, schema: Partial<Schema> | undefined = {}) : void {
    serializeEntity(writer, schema)
    writer.writeStringValue("baseType", schema.baseType);
    writer.writeCollectionOfObjectValues<Property>("properties", schema.properties, serializeProperty);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSearchSettings(writer: SerializationWriter, searchSettings: Partial<SearchSettings> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", searchSettings.odataType);
    writer.writeCollectionOfObjectValues<DisplayTemplate>("searchResultTemplates", searchSettings.searchResultTemplates, serializeDisplayTemplate);
    writer.writeAdditionalData(searchSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUrlMatchInfo(writer: SerializationWriter, urlMatchInfo: Partial<UrlMatchInfo> | undefined = {}) : void {
    writer.writeCollectionOfPrimitiveValues<string>("baseUrls", urlMatchInfo.baseUrls);
    writer.writeStringValue("@odata.type", urlMatchInfo.odataType);
    writer.writeStringValue("urlPattern", urlMatchInfo.urlPattern);
    writer.writeAdditionalData(urlMatchInfo.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUrlToItemResolverBase(writer: SerializationWriter, urlToItemResolverBase: Partial<UrlToItemResolverBase> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", urlToItemResolverBase.odataType);
    writer.writeNumberValue("priority", urlToItemResolverBase.priority);
    writer.writeAdditionalData(urlToItemResolverBase.additionalData);
}
export interface UrlMatchInfo extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * A list of the URL prefixes that must match URLs to be processed by this URL-to-item-resolver.
     */
    baseUrls?: string[];
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * A regular expression that will be matched towards the URL that is processed by this URL-to-item-resolver. The ECMAScript specification for regular expressions (ECMA-262) is used for the evaluation. The named groups defined by the regular expression will be used later to extract values from the URL.
     */
    urlPattern?: string;
}
export interface UrlToItemResolverBase extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The priority which defines the sequence in which the urlToItemResolverBase instances are evaluated.
     */
    priority?: number;
}
export const AccessTypeObject = {
    Grant: "grant",
    Deny: "deny",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AclTypeObject = {
    User: "user",
    Group: "group",
    Everyone: "everyone",
    EveryoneExceptGuests: "everyoneExceptGuests",
    ExternalGroup: "externalGroup",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ConnectionOperationStatusObject = {
    Unspecified: "unspecified",
    Inprogress: "inprogress",
    Completed: "completed",
    Failed: "failed",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ConnectionStateObject = {
    Draft: "draft",
    Ready: "ready",
    Obsolete: "obsolete",
    LimitExceeded: "limitExceeded",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ExternalActivityTypeObject = {
    Viewed: "viewed",
    Modified: "modified",
    Created: "created",
    Commented: "commented",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ExternalItemContentTypeObject = {
    Text: "text",
    Html: "html",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const IdentityTypeObject = {
    User: "user",
    Group: "group",
    ExternalGroup: "externalGroup",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const LabelObject = {
    Title: "title",
    Url: "url",
    CreatedBy: "createdBy",
    LastModifiedBy: "lastModifiedBy",
    Authors: "authors",
    CreatedDateTime: "createdDateTime",
    LastModifiedDateTime: "lastModifiedDateTime",
    FileName: "fileName",
    FileExtension: "fileExtension",
    UnknownFutureValue: "unknownFutureValue",
    IconUrl: "iconUrl",
} as const;
export const PropertyTypeObject = {
    String: "string",
    Int64: "int64",
    Double: "double",
    DateTime: "dateTime",
    Boolean: "boolean",
    StringCollection: "stringCollection",
    Int64Collection: "int64Collection",
    DoubleCollection: "doubleCollection",
    DateTimeCollection: "dateTimeCollection",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const RuleOperationObject = {
    Equals: "equals",
    NotEquals: "notEquals",
    Contains: "contains",
    NotContains: "notContains",
    LessThan: "lessThan",
    GreaterThan: "greaterThan",
    StartsWith: "startsWith",
    UnknownFutureValue: "unknownFutureValue",
} as const;
/* tslint:enable */
/* eslint-enable */
