/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
import { createGroupFromDiscriminatorValue, createIdentitySetFromDiscriminatorValue, createPhysicalAddressFromDiscriminatorValue, createPublicErrorFromDiscriminatorValue, createResultInfoFromDiscriminatorValue, createSiteFromDiscriminatorValue, deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, serializeBaseCollectionPaginationCountResponse, serializeEntity, serializeGroup, serializeIdentitySet, serializePhysicalAddress, serializePublicError, serializeResultInfo, serializeSite, type BaseCollectionPaginationCountResponse, type Entity, type Group, type IdentitySet, type PhysicalAddress, type PublicError, type ResultInfo, type Site } from '../';
import { type AdditionalDataHolder, type BackedModel, type BackingStore, type Duration, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export type AdditionalDataOptions = (typeof AdditionalDataOptionsObject)[keyof typeof AdditionalDataOptionsObject];
export interface Alert extends Entity, Parsable {
    /**
     * The adversary or activity group that is associated with this alert.
     */
    actorDisplayName?: string;
    /**
     * The alertPolicyId property
     */
    alertPolicyId?: string;
    /**
     * URL for the alert page in the Microsoft 365 Defender portal.
     */
    alertWebUrl?: string;
    /**
     * Owner of the alert, or null if no owner is assigned.
     */
    assignedTo?: string;
    /**
     * The attack kill-chain category that the alert belongs to. Aligned with the MITRE ATT&CK framework.
     */
    category?: string;
    /**
     * Specifies whether the alert represents a true threat. Possible values are: unknown, falsePositive, truePositive, informationalExpectedActivity, unknownFutureValue.
     */
    classification?: AlertClassification;
    /**
     * Array of comments created by the Security Operations (SecOps) team during the alert management process.
     */
    comments?: AlertComment[];
    /**
     * Time when Microsoft 365 Defender created the alert.
     */
    createdDateTime?: Date;
    /**
     * String value describing each alert.
     */
    description?: string;
    /**
     * Detection technology or sensor that identified the notable component or activity. Possible values are: unknown, microsoftDefenderForEndpoint, antivirus, smartScreen, customTi, microsoftDefenderForOffice365, automatedInvestigation, microsoftThreatExperts, customDetection, microsoftDefenderForIdentity, cloudAppSecurity, microsoft365Defender, azureAdIdentityProtection, manual, microsoftDataLossPrevention, appGovernancePolicy, appGovernanceDetection, unknownFutureValue, microsoftDefenderForCloud, microsoftDefenderForIoT, microsoftDefenderForServers, microsoftDefenderForStorage, microsoftDefenderForDNS, microsoftDefenderForDatabases, microsoftDefenderForContainers, microsoftDefenderForNetwork, microsoftDefenderForAppService, microsoftDefenderForKeyVault, microsoftDefenderForResourceManager, microsoftDefenderForApiManagement. You must use the Prefer: include-unknown-enum-members request header to get the following value(s) in this evolvable enum: microsoftDefenderForCloud, microsoftDefenderForIoT, microsoftDefenderForServers, microsoftDefenderForStorage, microsoftDefenderForDNS, microsoftDefenderForDatabases, microsoftDefenderForContainers, microsoftDefenderForNetwork, microsoftDefenderForAppService, microsoftDefenderForKeyVault, microsoftDefenderForResourceManager, microsoftDefenderForApiManagement.
     */
    detectionSource?: DetectionSource;
    /**
     * The ID of the detector that triggered the alert.
     */
    detectorId?: string;
    /**
     * Specifies the result of the investigation, whether the alert represents a true attack and if so, the nature of the attack. Possible values are: unknown, apt, malware, securityPersonnel, securityTesting, unwantedSoftware, other, multiStagedAttack, compromisedUser, phishing, maliciousUserActivity, clean, insufficientData, confirmedUserActivity, lineOfBusinessApplication, unknownFutureValue.
     */
    determination?: AlertDetermination;
    /**
     * Collection of evidence related to the alert.
     */
    evidence?: AlertEvidence[];
    /**
     * The earliest activity associated with the alert.
     */
    firstActivityDateTime?: Date;
    /**
     * Unique identifier to represent the incident this alert resource is associated with.
     */
    incidentId?: string;
    /**
     * URL for the incident page in the Microsoft 365 Defender portal.
     */
    incidentWebUrl?: string;
    /**
     * The oldest activity associated with the alert.
     */
    lastActivityDateTime?: Date;
    /**
     * Time when the alert was last updated at Microsoft 365 Defender.
     */
    lastUpdateDateTime?: Date;
    /**
     * The attack techniques, as aligned with the MITRE ATT&CK framework.
     */
    mitreTechniques?: string[];
    /**
     * The productName property
     */
    productName?: string;
    /**
     * The ID of the alert as it appears in the security provider product that generated the alert.
     */
    providerAlertId?: string;
    /**
     * Recommended response and remediation actions to take in the event this alert was generated.
     */
    recommendedActions?: string;
    /**
     * Time when the alert was resolved.
     */
    resolvedDateTime?: Date;
    /**
     * The serviceSource property
     */
    serviceSource?: ServiceSource;
    /**
     * The severity property
     */
    severity?: AlertSeverity;
    /**
     * The status property
     */
    status?: AlertStatus;
    /**
     * The Microsoft Entra tenant the alert was created in.
     */
    tenantId?: string;
    /**
     * The threat associated with this alert.
     */
    threatDisplayName?: string;
    /**
     * Threat family associated with this alert.
     */
    threatFamilyName?: string;
    /**
     * Brief identifying string value describing the alert.
     */
    title?: string;
}
export type AlertClassification = (typeof AlertClassificationObject)[keyof typeof AlertClassificationObject];
export interface AlertCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Alert[];
}
export interface AlertComment extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The comment text.
     */
    comment?: string;
    /**
     * The person or app name that submitted the comment.
     */
    createdByDisplayName?: string;
    /**
     * The time when the comment was submitted.
     */
    createdDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export type AlertDetermination = (typeof AlertDeterminationObject)[keyof typeof AlertDeterminationObject];
export interface AlertEvidence extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The date and time when the evidence was created and added to the alert. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    createdDateTime?: Date;
    /**
     * Detailed description of the entity role/s in an alert. Values are free-form.
     */
    detailedRoles?: string[];
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The remediationStatus property
     */
    remediationStatus?: EvidenceRemediationStatus;
    /**
     * Details about the remediation status.
     */
    remediationStatusDetails?: string;
    /**
     * The role/s that an evidence entity represents in an alert, for example, an IP address that is associated with an attacker has the evidence role Attacker.
     */
    roles?: EvidenceRole[];
    /**
     * Array of custom tags associated with an evidence instance, for example, to denote a group of devices, high-value assets, etc.
     */
    tags?: string[];
    /**
     * The verdict property
     */
    verdict?: EvidenceVerdict;
}
export type AlertSeverity = (typeof AlertSeverityObject)[keyof typeof AlertSeverityObject];
export type AlertStatus = (typeof AlertStatusObject)[keyof typeof AlertStatusObject];
export interface AmazonResourceEvidence extends AlertEvidence, Parsable {
    /**
     * The unique identifier for the Amazon account.
     */
    amazonAccountId?: string;
    /**
     * The Amazon resource identifier (ARN) for the cloud resource.
     */
    amazonResourceId?: string;
    /**
     * The name of the resource.
     */
    resourceName?: string;
    /**
     * The type of the resource.
     */
    resourceType?: string;
}
export interface AnalyzedMessageEvidence extends AlertEvidence, Parsable {
    /**
     * Direction of the email relative to your network. The possible values are: inbound, outbound or intraorg.
     */
    antiSpamDirection?: string;
    /**
     * Number of attachments in the email.
     */
    attachmentsCount?: number;
    /**
     * Delivery action of the email. The possible values are: delivered, deliveredAsSpam, junked, blocked, or replaced.
     */
    deliveryAction?: string;
    /**
     * Location where the email was delivered. The possible values are: inbox, external, junkFolder, quarantine, failed, dropped, deletedFolder or forwarded.
     */
    deliveryLocation?: string;
    /**
     * Public-facing identifier for the email that is set by the sending email system.
     */
    internetMessageId?: string;
    /**
     * Detected language of the email content.
     */
    language?: string;
    /**
     * Unique identifier for the email, generated by Microsoft 365.
     */
    networkMessageId?: string;
    /**
     * The P1 sender.
     */
    p1Sender?: EmailSender;
    /**
     * The P2 sender.
     */
    p2Sender?: EmailSender;
    /**
     * Date and time when the email was received.
     */
    receivedDateTime?: Date;
    /**
     * Email address of the recipient, or email address of the recipient after distribution list expansion.
     */
    recipientEmailAddress?: string;
    /**
     * IP address of the last detected mail server that relayed the message.
     */
    senderIp?: string;
    /**
     * Subject of the email.
     */
    subject?: string;
    /**
     * Collection of methods used to detect malware, phishing, or other threats found in the email.
     */
    threatDetectionMethods?: string[];
    /**
     * Collection of detection names for malware or other threats found.
     */
    threats?: string[];
    /**
     * Number of embedded URLs in the email.
     */
    urlCount?: number;
    /**
     * Collection of the URLs contained in this email.
     */
    urls?: string[];
    /**
     * Uniform resource name (URN) of the automated investigation where the cluster was identified.
     */
    urn?: string;
}
export interface Article extends Entity, Parsable {
    /**
     * The body property
     */
    body?: FormattedContent;
    /**
     * The date and time when this article was created. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    createdDateTime?: Date;
    /**
     * URL of the header image for this article, used for display purposes.
     */
    imageUrl?: string;
    /**
     * Indicators related to this article.
     */
    indicators?: ArticleIndicator[];
    /**
     * Indicates whether this article is currently featured by Microsoft.
     */
    isFeatured?: boolean;
    /**
     * The most recent date and time when this article was updated. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastUpdatedDateTime?: Date;
    /**
     * The summary property
     */
    summary?: FormattedContent;
    /**
     * Tags for this article, communicating keywords, or key concepts.
     */
    tags?: string[];
    /**
     * The title of this article.
     */
    title?: string;
}
export interface ArticleCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Article[];
}
export interface ArticleIndicator extends Indicator, Parsable {
}
export interface ArticleIndicatorCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ArticleIndicator[];
}
export interface Artifact extends Entity, Parsable {
}
export interface AutonomousSystem extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The name of the autonomous system.
     */
    name?: string;
    /**
     * The autonomous system number, assigned by IANA.
     */
    number?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The name of the autonomous system organization.
     */
    organization?: string;
    /**
     * A displayable value for these autonomous system details.
     */
    value?: string;
}
export interface AzureResourceEvidence extends AlertEvidence, Parsable {
    /**
     * The unique identifier for the Azure resource.
     */
    resourceId?: string;
    /**
     * The name of the resource.
     */
    resourceName?: string;
    /**
     * The type of the resource.
     */
    resourceType?: string;
}
export type BehaviorDuringRetentionPeriod = (typeof BehaviorDuringRetentionPeriodObject)[keyof typeof BehaviorDuringRetentionPeriodObject];
export interface BlobContainerEvidence extends AlertEvidence, Parsable {
    /**
     * The name of the blob container.
     */
    name?: string;
    /**
     * The storage which the blob container belongs to.
     */
    storageResource?: AzureResourceEvidence;
    /**
     * The full URL representation of the blob container.
     */
    url?: string;
}
export interface BlobEvidence extends AlertEvidence, Parsable {
    /**
     * The container which the blob belongs to.
     */
    blobContainer?: BlobContainerEvidence;
    /**
     * The Etag associated with this blob.
     */
    etag?: string;
    /**
     * The file hashes associated with this blob.
     */
    fileHashes?: FileHash[];
    /**
     * The name of the blob.
     */
    name?: string;
    /**
     * The full URL representation of the blob.
     */
    url?: string;
}
export type CaseAction = (typeof CaseActionObject)[keyof typeof CaseActionObject];
export interface CaseEscaped extends Entity, Parsable {
    /**
     * The createdDateTime property
     */
    createdDateTime?: Date;
    /**
     * The description property
     */
    description?: string;
    /**
     * The displayName property
     */
    displayName?: string;
    /**
     * The lastModifiedBy property
     */
    lastModifiedBy?: IdentitySet;
    /**
     * The lastModifiedDateTime property
     */
    lastModifiedDateTime?: Date;
    /**
     * The status property
     */
    status?: CaseStatus;
}
export interface CaseOperation extends Entity, Parsable {
    /**
     * The type of action the operation represents. Possible values are: addToReviewSet,applyTags,contentExport,convertToPdf,estimateStatistics, purgeData
     */
    action?: CaseAction;
    /**
     * The date and time the operation was completed.
     */
    completedDateTime?: Date;
    /**
     * The user that created the operation.
     */
    createdBy?: IdentitySet;
    /**
     * The date and time the operation was created.
     */
    createdDateTime?: Date;
    /**
     * The progress of the operation.
     */
    percentProgress?: number;
    /**
     * Contains success and failure-specific result information.
     */
    resultInfo?: ResultInfo;
    /**
     * The status of the case operation. Possible values are: notStarted, submissionFailed, running, succeeded, partiallySucceeded, failed.
     */
    status?: CaseOperationStatus;
}
export interface CaseOperationCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: CaseOperation[];
}
export type CaseOperationStatus = (typeof CaseOperationStatusObject)[keyof typeof CaseOperationStatusObject];
export interface CasesRoot extends Entity, Parsable {
    /**
     * The ediscoveryCases property
     */
    ediscoveryCases?: EdiscoveryCase[];
}
export type CaseStatus = (typeof CaseStatusObject)[keyof typeof CaseStatusObject];
export type ChildSelectability = (typeof ChildSelectabilityObject)[keyof typeof ChildSelectabilityObject];
export interface CloudApplicationEvidence extends AlertEvidence, Parsable {
    /**
     * Unique identifier of the application.
     */
    appId?: number;
    /**
     * Name of the application.
     */
    displayName?: string;
    /**
     * Identifier of the instance of the Software as a Service (SaaS) application.
     */
    instanceId?: number;
    /**
     * Name of the instance of the SaaS application.
     */
    instanceName?: string;
    /**
     * The identifier of the SaaS application.
     */
    saasAppId?: number;
}
export interface ContainerEvidence extends AlertEvidence, Parsable {
    /**
     * The list of arguments.
     */
    args?: string[];
    /**
     * The list of commands.
     */
    command?: string[];
    /**
     * The container ID.
     */
    containerId?: string;
    /**
     * The image used to run the container.
     */
    image?: ContainerImageEvidence;
    /**
     * The privileged status.
     */
    isPrivileged?: boolean;
    /**
     * The container name.
     */
    name?: string;
    /**
     * The pod this container belongs to.
     */
    pod?: KubernetesPodEvidence;
}
export interface ContainerImageEvidence extends AlertEvidence, Parsable {
    /**
     * The digest image entity, in case this is a tag image.
     */
    digestImage?: ContainerImageEvidence;
    /**
     * The unique identifier for the container image entity.
     */
    imageId?: string;
    /**
     * The container registry for this image.
     */
    registry?: ContainerRegistryEvidence;
}
export type ContainerPortProtocol = (typeof ContainerPortProtocolObject)[keyof typeof ContainerPortProtocolObject];
export interface ContainerRegistryEvidence extends AlertEvidence, Parsable {
    /**
     * The registry URI.
     */
    registry?: string;
}
export type ContentFormat = (typeof ContentFormatObject)[keyof typeof ContentFormatObject];
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertCollectionResponse}
 */
export function createAlertCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertComment}
 */
export function createAlertCommentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlertComment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AlertEvidence}
 */
export function createAlertEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.amazonResourceEvidence":
                    return deserializeIntoAmazonResourceEvidence;
                case "#microsoft.graph.security.analyzedMessageEvidence":
                    return deserializeIntoAnalyzedMessageEvidence;
                case "#microsoft.graph.security.azureResourceEvidence":
                    return deserializeIntoAzureResourceEvidence;
                case "#microsoft.graph.security.blobContainerEvidence":
                    return deserializeIntoBlobContainerEvidence;
                case "#microsoft.graph.security.blobEvidence":
                    return deserializeIntoBlobEvidence;
                case "#microsoft.graph.security.cloudApplicationEvidence":
                    return deserializeIntoCloudApplicationEvidence;
                case "#microsoft.graph.security.containerEvidence":
                    return deserializeIntoContainerEvidence;
                case "#microsoft.graph.security.containerImageEvidence":
                    return deserializeIntoContainerImageEvidence;
                case "#microsoft.graph.security.containerRegistryEvidence":
                    return deserializeIntoContainerRegistryEvidence;
                case "#microsoft.graph.security.deviceEvidence":
                    return deserializeIntoDeviceEvidence;
                case "#microsoft.graph.security.dnsEvidence":
                    return deserializeIntoDnsEvidence;
                case "#microsoft.graph.security.fileEvidence":
                    return deserializeIntoFileEvidence;
                case "#microsoft.graph.security.fileHashEvidence":
                    return deserializeIntoFileHashEvidence;
                case "#microsoft.graph.security.gitHubOrganizationEvidence":
                    return deserializeIntoGitHubOrganizationEvidence;
                case "#microsoft.graph.security.gitHubRepoEvidence":
                    return deserializeIntoGitHubRepoEvidence;
                case "#microsoft.graph.security.gitHubUserEvidence":
                    return deserializeIntoGitHubUserEvidence;
                case "#microsoft.graph.security.googleCloudResourceEvidence":
                    return deserializeIntoGoogleCloudResourceEvidence;
                case "#microsoft.graph.security.hostLogonSessionEvidence":
                    return deserializeIntoHostLogonSessionEvidence;
                case "#microsoft.graph.security.ioTDeviceEvidence":
                    return deserializeIntoIoTDeviceEvidence;
                case "#microsoft.graph.security.ipEvidence":
                    return deserializeIntoIpEvidence;
                case "#microsoft.graph.security.kubernetesClusterEvidence":
                    return deserializeIntoKubernetesClusterEvidence;
                case "#microsoft.graph.security.kubernetesControllerEvidence":
                    return deserializeIntoKubernetesControllerEvidence;
                case "#microsoft.graph.security.kubernetesNamespaceEvidence":
                    return deserializeIntoKubernetesNamespaceEvidence;
                case "#microsoft.graph.security.kubernetesPodEvidence":
                    return deserializeIntoKubernetesPodEvidence;
                case "#microsoft.graph.security.kubernetesSecretEvidence":
                    return deserializeIntoKubernetesSecretEvidence;
                case "#microsoft.graph.security.kubernetesServiceAccountEvidence":
                    return deserializeIntoKubernetesServiceAccountEvidence;
                case "#microsoft.graph.security.kubernetesServiceEvidence":
                    return deserializeIntoKubernetesServiceEvidence;
                case "#microsoft.graph.security.mailboxEvidence":
                    return deserializeIntoMailboxEvidence;
                case "#microsoft.graph.security.mailClusterEvidence":
                    return deserializeIntoMailClusterEvidence;
                case "#microsoft.graph.security.malwareEvidence":
                    return deserializeIntoMalwareEvidence;
                case "#microsoft.graph.security.networkConnectionEvidence":
                    return deserializeIntoNetworkConnectionEvidence;
                case "#microsoft.graph.security.nicEvidence":
                    return deserializeIntoNicEvidence;
                case "#microsoft.graph.security.oauthApplicationEvidence":
                    return deserializeIntoOauthApplicationEvidence;
                case "#microsoft.graph.security.processEvidence":
                    return deserializeIntoProcessEvidence;
                case "#microsoft.graph.security.registryKeyEvidence":
                    return deserializeIntoRegistryKeyEvidence;
                case "#microsoft.graph.security.registryValueEvidence":
                    return deserializeIntoRegistryValueEvidence;
                case "#microsoft.graph.security.sasTokenEvidence":
                    return deserializeIntoSasTokenEvidence;
                case "#microsoft.graph.security.securityGroupEvidence":
                    return deserializeIntoSecurityGroupEvidence;
                case "#microsoft.graph.security.servicePrincipalEvidence":
                    return deserializeIntoServicePrincipalEvidence;
                case "#microsoft.graph.security.submissionMailEvidence":
                    return deserializeIntoSubmissionMailEvidence;
                case "#microsoft.graph.security.urlEvidence":
                    return deserializeIntoUrlEvidence;
                case "#microsoft.graph.security.userEvidence":
                    return deserializeIntoUserEvidence;
            }
        }
    }
    return deserializeIntoAlertEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Alert}
 */
export function createAlertFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAlert;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AmazonResourceEvidence}
 */
export function createAmazonResourceEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAmazonResourceEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AnalyzedMessageEvidence}
 */
export function createAnalyzedMessageEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAnalyzedMessageEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ArticleCollectionResponse}
 */
export function createArticleCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoArticleCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Article}
 */
export function createArticleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoArticle;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ArticleIndicatorCollectionResponse}
 */
export function createArticleIndicatorCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoArticleIndicatorCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ArticleIndicator}
 */
export function createArticleIndicatorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoArticleIndicator;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Artifact}
 */
export function createArtifactFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.host":
                    return deserializeIntoHost;
                case "#microsoft.graph.security.hostComponent":
                    return deserializeIntoHostComponent;
                case "#microsoft.graph.security.hostCookie":
                    return deserializeIntoHostCookie;
                case "#microsoft.graph.security.hostname":
                    return deserializeIntoHostname;
                case "#microsoft.graph.security.hostSslCertificate":
                    return deserializeIntoHostSslCertificate;
                case "#microsoft.graph.security.hostTracker":
                    return deserializeIntoHostTracker;
                case "#microsoft.graph.security.ipAddress":
                    return deserializeIntoIpAddress;
                case "#microsoft.graph.security.passiveDnsRecord":
                    return deserializeIntoPassiveDnsRecord;
                case "#microsoft.graph.security.sslCertificate":
                    return deserializeIntoSslCertificate;
                case "#microsoft.graph.security.unclassifiedArtifact":
                    return deserializeIntoUnclassifiedArtifact;
            }
        }
    }
    return deserializeIntoArtifact;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AutonomousSystem}
 */
export function createAutonomousSystemFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAutonomousSystem;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AzureResourceEvidence}
 */
export function createAzureResourceEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAzureResourceEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BlobContainerEvidence}
 */
export function createBlobContainerEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBlobContainerEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BlobEvidence}
 */
export function createBlobEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBlobEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CaseEscaped}
 */
export function createCaseEscapedFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.ediscoveryCase":
                    return deserializeIntoEdiscoveryCase;
            }
        }
    }
    return deserializeIntoCaseEscaped;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CaseOperationCollectionResponse}
 */
export function createCaseOperationCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCaseOperationCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CaseOperation}
 */
export function createCaseOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.ediscoveryAddToReviewSetOperation":
                    return deserializeIntoEdiscoveryAddToReviewSetOperation;
                case "#microsoft.graph.security.ediscoveryEstimateOperation":
                    return deserializeIntoEdiscoveryEstimateOperation;
                case "#microsoft.graph.security.ediscoveryExportOperation":
                    return deserializeIntoEdiscoveryExportOperation;
                case "#microsoft.graph.security.ediscoveryHoldOperation":
                    return deserializeIntoEdiscoveryHoldOperation;
                case "#microsoft.graph.security.ediscoveryIndexOperation":
                    return deserializeIntoEdiscoveryIndexOperation;
                case "#microsoft.graph.security.ediscoveryPurgeDataOperation":
                    return deserializeIntoEdiscoveryPurgeDataOperation;
                case "#microsoft.graph.security.ediscoveryTagOperation":
                    return deserializeIntoEdiscoveryTagOperation;
            }
        }
    }
    return deserializeIntoCaseOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CasesRoot}
 */
export function createCasesRootFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCasesRoot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CloudApplicationEvidence}
 */
export function createCloudApplicationEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCloudApplicationEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContainerEvidence}
 */
export function createContainerEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoContainerEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContainerImageEvidence}
 */
export function createContainerImageEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoContainerImageEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ContainerRegistryEvidence}
 */
export function createContainerRegistryEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoContainerRegistryEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CvssSummary}
 */
export function createCvssSummaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCvssSummary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DataSet}
 */
export function createDataSetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.ediscoveryReviewSet":
                    return deserializeIntoEdiscoveryReviewSet;
            }
        }
    }
    return deserializeIntoDataSet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DataSourceCollectionResponse}
 */
export function createDataSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDataSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DataSourceContainer}
 */
export function createDataSourceContainerFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.ediscoveryCustodian":
                    return deserializeIntoEdiscoveryCustodian;
                case "#microsoft.graph.security.ediscoveryNoncustodialDataSource":
                    return deserializeIntoEdiscoveryNoncustodialDataSource;
            }
        }
    }
    return deserializeIntoDataSourceContainer;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DataSource}
 */
export function createDataSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.siteSource":
                    return deserializeIntoSiteSource;
                case "#microsoft.graph.security.unifiedGroupSource":
                    return deserializeIntoUnifiedGroupSource;
                case "#microsoft.graph.security.userSource":
                    return deserializeIntoUserSource;
            }
        }
    }
    return deserializeIntoDataSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeviceEvidence}
 */
export function createDeviceEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeviceEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Dictionary}
 */
export function createDictionaryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDictionary;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DnsEvidence}
 */
export function createDnsEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDnsEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryAddToReviewSetOperation}
 */
export function createEdiscoveryAddToReviewSetOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryAddToReviewSetOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryCaseCollectionResponse}
 */
export function createEdiscoveryCaseCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryCaseCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryCase}
 */
export function createEdiscoveryCaseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryCase;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryCaseSettings}
 */
export function createEdiscoveryCaseSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryCaseSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryCustodianCollectionResponse}
 */
export function createEdiscoveryCustodianCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryCustodianCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryCustodian}
 */
export function createEdiscoveryCustodianFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryCustodian;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryEstimateOperation}
 */
export function createEdiscoveryEstimateOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryEstimateOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryExportOperation}
 */
export function createEdiscoveryExportOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryExportOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryHoldOperation}
 */
export function createEdiscoveryHoldOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryHoldOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryIndexOperation}
 */
export function createEdiscoveryIndexOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryIndexOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryNoncustodialDataSourceCollectionResponse}
 */
export function createEdiscoveryNoncustodialDataSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryNoncustodialDataSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryNoncustodialDataSource}
 */
export function createEdiscoveryNoncustodialDataSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryNoncustodialDataSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryPurgeDataOperation}
 */
export function createEdiscoveryPurgeDataOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryPurgeDataOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryReviewSetCollectionResponse}
 */
export function createEdiscoveryReviewSetCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryReviewSetCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryReviewSet}
 */
export function createEdiscoveryReviewSetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryReviewSet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryReviewSetQueryCollectionResponse}
 */
export function createEdiscoveryReviewSetQueryCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryReviewSetQueryCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryReviewSetQuery}
 */
export function createEdiscoveryReviewSetQueryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryReviewSetQuery;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryReviewTagCollectionResponse}
 */
export function createEdiscoveryReviewTagCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryReviewTagCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryReviewTag}
 */
export function createEdiscoveryReviewTagFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryReviewTag;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoverySearchCollectionResponse}
 */
export function createEdiscoverySearchCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoverySearchCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoverySearch}
 */
export function createEdiscoverySearchFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoverySearch;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EdiscoveryTagOperation}
 */
export function createEdiscoveryTagOperationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEdiscoveryTagOperation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EmailSender}
 */
export function createEmailSenderFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEmailSender;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EventPropagationResult}
 */
export function createEventPropagationResultFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEventPropagationResult;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EventQuery}
 */
export function createEventQueryFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEventQuery;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExportFileMetadata}
 */
export function createExportFileMetadataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExportFileMetadata;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FileDetails}
 */
export function createFileDetailsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFileDetails;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FileEvidence}
 */
export function createFileEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFileEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FileHashEvidence}
 */
export function createFileHashEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFileHashEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FileHash}
 */
export function createFileHashFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFileHash;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FormattedContent}
 */
export function createFormattedContentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFormattedContent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GitHubOrganizationEvidence}
 */
export function createGitHubOrganizationEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGitHubOrganizationEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GitHubRepoEvidence}
 */
export function createGitHubRepoEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGitHubRepoEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GitHubUserEvidence}
 */
export function createGitHubUserEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGitHubUserEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GoogleCloudResourceEvidence}
 */
export function createGoogleCloudResourceEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGoogleCloudResourceEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostCollectionResponse}
 */
export function createHostCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostComponentCollectionResponse}
 */
export function createHostComponentCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostComponentCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostComponent}
 */
export function createHostComponentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostComponent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostCookieCollectionResponse}
 */
export function createHostCookieCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostCookieCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostCookie}
 */
export function createHostCookieFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostCookie;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Host}
 */
export function createHostFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.hostname":
                    return deserializeIntoHostname;
                case "#microsoft.graph.security.ipAddress":
                    return deserializeIntoIpAddress;
            }
        }
    }
    return deserializeIntoHost;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostLogonSessionEvidence}
 */
export function createHostLogonSessionEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostLogonSessionEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Hostname}
 */
export function createHostnameFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostname;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostPairCollectionResponse}
 */
export function createHostPairCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostPairCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostPair}
 */
export function createHostPairFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostPair;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostPortBanner}
 */
export function createHostPortBannerFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostPortBanner;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostPortCollectionResponse}
 */
export function createHostPortCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostPortCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostPortComponent}
 */
export function createHostPortComponentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostPortComponent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostPort}
 */
export function createHostPortFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostPort;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostReputation}
 */
export function createHostReputationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostReputation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostReputationRule}
 */
export function createHostReputationRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostReputationRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostSslCertificateCollectionResponse}
 */
export function createHostSslCertificateCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostSslCertificateCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostSslCertificate}
 */
export function createHostSslCertificateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostSslCertificate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostSslCertificatePort}
 */
export function createHostSslCertificatePortFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostSslCertificatePort;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostTrackerCollectionResponse}
 */
export function createHostTrackerCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostTrackerCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HostTracker}
 */
export function createHostTrackerFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHostTracker;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HuntingQueryResults}
 */
export function createHuntingQueryResultsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHuntingQueryResults;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {HuntingRowResult}
 */
export function createHuntingRowResultFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHuntingRowResult;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Hyperlink}
 */
export function createHyperlinkFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoHyperlink;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IncidentCollectionResponse}
 */
export function createIncidentCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIncidentCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Incident}
 */
export function createIncidentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIncident;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Indicator}
 */
export function createIndicatorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.articleIndicator":
                    return deserializeIntoArticleIndicator;
                case "#microsoft.graph.security.intelligenceProfileIndicator":
                    return deserializeIntoIntelligenceProfileIndicator;
            }
        }
    }
    return deserializeIntoIndicator;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IntelligenceProfileCollectionResponse}
 */
export function createIntelligenceProfileCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIntelligenceProfileCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IntelligenceProfileCountryOrRegionOfOrigin}
 */
export function createIntelligenceProfileCountryOrRegionOfOriginFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIntelligenceProfileCountryOrRegionOfOrigin;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IntelligenceProfile}
 */
export function createIntelligenceProfileFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIntelligenceProfile;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IntelligenceProfileIndicatorCollectionResponse}
 */
export function createIntelligenceProfileIndicatorCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIntelligenceProfileIndicatorCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IntelligenceProfileIndicator}
 */
export function createIntelligenceProfileIndicatorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIntelligenceProfileIndicator;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IoTDeviceEvidence}
 */
export function createIoTDeviceEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIoTDeviceEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IpAddress}
 */
export function createIpAddressFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIpAddress;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IpEvidence}
 */
export function createIpEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIpEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesClusterEvidence}
 */
export function createKubernetesClusterEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesClusterEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesControllerEvidence}
 */
export function createKubernetesControllerEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesControllerEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesNamespaceEvidence}
 */
export function createKubernetesNamespaceEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesNamespaceEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesPodEvidence}
 */
export function createKubernetesPodEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesPodEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesSecretEvidence}
 */
export function createKubernetesSecretEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesSecretEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesServiceAccountEvidence}
 */
export function createKubernetesServiceAccountEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesServiceAccountEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesServiceEvidence}
 */
export function createKubernetesServiceEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesServiceEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {KubernetesServicePort}
 */
export function createKubernetesServicePortFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoKubernetesServicePort;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {LoggedOnUser}
 */
export function createLoggedOnUserFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoLoggedOnUser;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MailboxEvidence}
 */
export function createMailboxEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMailboxEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MailClusterEvidence}
 */
export function createMailClusterEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMailClusterEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MalwareEvidence}
 */
export function createMalwareEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMalwareEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NetworkConnectionEvidence}
 */
export function createNetworkConnectionEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNetworkConnectionEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NicEvidence}
 */
export function createNicEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNicEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OauthApplicationEvidence}
 */
export function createOauthApplicationEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOauthApplicationEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OcrSettings}
 */
export function createOcrSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOcrSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PassiveDnsRecordCollectionResponse}
 */
export function createPassiveDnsRecordCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPassiveDnsRecordCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PassiveDnsRecord}
 */
export function createPassiveDnsRecordFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPassiveDnsRecord;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProcessEvidence}
 */
export function createProcessEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProcessEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RedundancyDetectionSettings}
 */
export function createRedundancyDetectionSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRedundancyDetectionSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RegistryKeyEvidence}
 */
export function createRegistryKeyEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRegistryKeyEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RegistryValueEvidence}
 */
export function createRegistryValueEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRegistryValueEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RetentionEventCollectionResponse}
 */
export function createRetentionEventCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRetentionEventCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RetentionEvent}
 */
export function createRetentionEventFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRetentionEvent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RetentionEventStatus}
 */
export function createRetentionEventStatusFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRetentionEventStatus;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RetentionEventTypeCollectionResponse}
 */
export function createRetentionEventTypeCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRetentionEventTypeCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RetentionEventType}
 */
export function createRetentionEventTypeFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRetentionEventType;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SasTokenEvidence}
 */
export function createSasTokenEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSasTokenEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Search}
 */
export function createSearchFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.ediscoveryReviewSetQuery":
                    return deserializeIntoEdiscoveryReviewSetQuery;
                case "#microsoft.graph.security.ediscoverySearch":
                    return deserializeIntoEdiscoverySearch;
            }
        }
    }
    return deserializeIntoSearch;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SecurityGroupEvidence}
 */
export function createSecurityGroupEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSecurityGroupEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ServicePrincipalEvidence}
 */
export function createServicePrincipalEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoServicePrincipalEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SinglePropertySchema}
 */
export function createSinglePropertySchemaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSinglePropertySchema;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SiteSourceCollectionResponse}
 */
export function createSiteSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSiteSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SiteSource}
 */
export function createSiteSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSiteSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SslCertificateCollectionResponse}
 */
export function createSslCertificateCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSslCertificateCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SslCertificateEntity}
 */
export function createSslCertificateEntityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSslCertificateEntity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SslCertificate}
 */
export function createSslCertificateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSslCertificate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SubdomainCollectionResponse}
 */
export function createSubdomainCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubdomainCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Subdomain}
 */
export function createSubdomainFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubdomain;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SubmissionMailEvidence}
 */
export function createSubmissionMailEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubmissionMailEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Tag}
 */
export function createTagFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.ediscoveryReviewTag":
                    return deserializeIntoEdiscoveryReviewTag;
            }
        }
    }
    return deserializeIntoTag;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ThreatIntelligence}
 */
export function createThreatIntelligenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoThreatIntelligence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TopicModelingSettings}
 */
export function createTopicModelingSettingsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTopicModelingSettings;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TriggersRoot}
 */
export function createTriggersRootFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTriggersRoot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TriggerTypesRoot}
 */
export function createTriggerTypesRootFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTriggerTypesRoot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UnclassifiedArtifact}
 */
export function createUnclassifiedArtifactFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUnclassifiedArtifact;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UnifiedGroupSourceCollectionResponse}
 */
export function createUnifiedGroupSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUnifiedGroupSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UnifiedGroupSource}
 */
export function createUnifiedGroupSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUnifiedGroupSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UrlEvidence}
 */
export function createUrlEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUrlEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserAccount}
 */
export function createUserAccountFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserAccount;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserEvidence}
 */
export function createUserEvidenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserEvidence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserSourceCollectionResponse}
 */
export function createUserSourceCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserSourceCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserSource}
 */
export function createUserSourceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserSource;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {VmMetadata}
 */
export function createVmMetadataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoVmMetadata;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {VulnerabilityCollectionResponse}
 */
export function createVulnerabilityCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoVulnerabilityCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {VulnerabilityComponentCollectionResponse}
 */
export function createVulnerabilityComponentCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoVulnerabilityComponentCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {VulnerabilityComponent}
 */
export function createVulnerabilityComponentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoVulnerabilityComponent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Vulnerability}
 */
export function createVulnerabilityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoVulnerability;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WhoisBaseRecord}
 */
export function createWhoisBaseRecordFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.security.whoisHistoryRecord":
                    return deserializeIntoWhoisHistoryRecord;
                case "#microsoft.graph.security.whoisRecord":
                    return deserializeIntoWhoisRecord;
            }
        }
    }
    return deserializeIntoWhoisBaseRecord;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WhoisContact}
 */
export function createWhoisContactFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWhoisContact;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WhoisHistoryRecordCollectionResponse}
 */
export function createWhoisHistoryRecordCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWhoisHistoryRecordCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WhoisHistoryRecord}
 */
export function createWhoisHistoryRecordFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWhoisHistoryRecord;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WhoisNameserver}
 */
export function createWhoisNameserverFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWhoisNameserver;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WhoisRecordCollectionResponse}
 */
export function createWhoisRecordCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWhoisRecordCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {WhoisRecord}
 */
export function createWhoisRecordFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoWhoisRecord;
}
export interface CvssSummary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The CVSS score about this vulnerability.
     */
    score?: number;
    /**
     * The CVSS severity rating for this vulnerability. The possible values are: none, low, medium, high, critical, unknownFutureValue.
     */
    severity?: VulnerabilitySeverity;
    /**
     * The CVSS vector string for this vulnerability.
     */
    vectorString?: string;
}
export interface DataSet extends Entity, Parsable {
    /**
     * The createdBy property
     */
    createdBy?: IdentitySet;
    /**
     * The createdDateTime property
     */
    createdDateTime?: Date;
    /**
     * The displayName property
     */
    displayName?: string;
}
export interface DataSource extends Entity, Parsable {
    /**
     * The user who created the dataSource.
     */
    createdBy?: IdentitySet;
    /**
     * The date and time the dataSource was created.
     */
    createdDateTime?: Date;
    /**
     * The display name of the dataSource and is the name of the SharePoint site.
     */
    displayName?: string;
    /**
     * The hold status of the dataSource.The possible values are: notApplied, applied, applying, removing, partial
     */
    holdStatus?: DataSourceHoldStatus;
}
export interface DataSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: DataSource[];
}
export interface DataSourceContainer extends Entity, Parsable {
    /**
     * Created date and time of the dataSourceContainer entity.
     */
    createdDateTime?: Date;
    /**
     * Display name of the dataSourceContainer entity.
     */
    displayName?: string;
    /**
     * The hold status of the dataSourceContainer. The possible values are: notApplied, applied, applying, removing, partial
     */
    holdStatus?: DataSourceHoldStatus;
    /**
     * Last modified date and time of the dataSourceContainer.
     */
    lastModifiedDateTime?: Date;
    /**
     * Date and time that the dataSourceContainer was released from the case.
     */
    releasedDateTime?: Date;
    /**
     * Latest status of the dataSourceContainer. Possible values are: Active, Released.
     */
    status?: DataSourceContainerStatus;
}
export type DataSourceContainerStatus = (typeof DataSourceContainerStatusObject)[keyof typeof DataSourceContainerStatusObject];
export type DataSourceHoldStatus = (typeof DataSourceHoldStatusObject)[keyof typeof DataSourceHoldStatusObject];
export type DataSourceScopes = (typeof DataSourceScopesObject)[keyof typeof DataSourceScopesObject];
export type DefenderAvStatus = (typeof DefenderAvStatusObject)[keyof typeof DefenderAvStatusObject];
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAlert(alert: Partial<Alert> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(alert),
        "actorDisplayName": n => { alert.actorDisplayName = n.getStringValue(); },
        "alertPolicyId": n => { alert.alertPolicyId = n.getStringValue(); },
        "alertWebUrl": n => { alert.alertWebUrl = n.getStringValue(); },
        "assignedTo": n => { alert.assignedTo = n.getStringValue(); },
        "category": n => { alert.category = n.getStringValue(); },
        "classification": n => { alert.classification = n.getEnumValue<AlertClassification>(AlertClassificationObject); },
        "comments": n => { alert.comments = n.getCollectionOfObjectValues<AlertComment>(createAlertCommentFromDiscriminatorValue); },
        "createdDateTime": n => { alert.createdDateTime = n.getDateValue(); },
        "description": n => { alert.description = n.getStringValue(); },
        "detectionSource": n => { alert.detectionSource = n.getEnumValue<DetectionSource>(DetectionSourceObject); },
        "detectorId": n => { alert.detectorId = n.getStringValue(); },
        "determination": n => { alert.determination = n.getEnumValue<AlertDetermination>(AlertDeterminationObject); },
        "evidence": n => { alert.evidence = n.getCollectionOfObjectValues<AlertEvidence>(createAlertEvidenceFromDiscriminatorValue); },
        "firstActivityDateTime": n => { alert.firstActivityDateTime = n.getDateValue(); },
        "incidentId": n => { alert.incidentId = n.getStringValue(); },
        "incidentWebUrl": n => { alert.incidentWebUrl = n.getStringValue(); },
        "lastActivityDateTime": n => { alert.lastActivityDateTime = n.getDateValue(); },
        "lastUpdateDateTime": n => { alert.lastUpdateDateTime = n.getDateValue(); },
        "mitreTechniques": n => { alert.mitreTechniques = n.getCollectionOfPrimitiveValues<string>(); },
        "productName": n => { alert.productName = n.getStringValue(); },
        "providerAlertId": n => { alert.providerAlertId = n.getStringValue(); },
        "recommendedActions": n => { alert.recommendedActions = n.getStringValue(); },
        "resolvedDateTime": n => { alert.resolvedDateTime = n.getDateValue(); },
        "serviceSource": n => { alert.serviceSource = n.getEnumValue<ServiceSource>(ServiceSourceObject); },
        "severity": n => { alert.severity = n.getEnumValue<AlertSeverity>(AlertSeverityObject); },
        "status": n => { alert.status = n.getEnumValue<AlertStatus>(AlertStatusObject); },
        "tenantId": n => { alert.tenantId = n.getStringValue(); },
        "threatDisplayName": n => { alert.threatDisplayName = n.getStringValue(); },
        "threatFamilyName": n => { alert.threatFamilyName = n.getStringValue(); },
        "title": n => { alert.title = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAlertCollectionResponse(alertCollectionResponse: Partial<AlertCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(alertCollectionResponse),
        "value": n => { alertCollectionResponse.value = n.getCollectionOfObjectValues<Alert>(createAlertFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAlertComment(alertComment: Partial<AlertComment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { alertComment.backingStoreEnabled = true; },
        "comment": n => { alertComment.comment = n.getStringValue(); },
        "createdByDisplayName": n => { alertComment.createdByDisplayName = n.getStringValue(); },
        "createdDateTime": n => { alertComment.createdDateTime = n.getDateValue(); },
        "@odata.type": n => { alertComment.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAlertEvidence(alertEvidence: Partial<AlertEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { alertEvidence.backingStoreEnabled = true; },
        "createdDateTime": n => { alertEvidence.createdDateTime = n.getDateValue(); },
        "detailedRoles": n => { alertEvidence.detailedRoles = n.getCollectionOfPrimitiveValues<string>(); },
        "@odata.type": n => { alertEvidence.odataType = n.getStringValue(); },
        "remediationStatus": n => { alertEvidence.remediationStatus = n.getEnumValue<EvidenceRemediationStatus>(EvidenceRemediationStatusObject); },
        "remediationStatusDetails": n => { alertEvidence.remediationStatusDetails = n.getStringValue(); },
        "roles": n => { alertEvidence.roles = n.getCollectionOfEnumValues<EvidenceRole>(EvidenceRoleObject); },
        "tags": n => { alertEvidence.tags = n.getCollectionOfPrimitiveValues<string>(); },
        "verdict": n => { alertEvidence.verdict = n.getEnumValue<EvidenceVerdict>(EvidenceVerdictObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAmazonResourceEvidence(amazonResourceEvidence: Partial<AmazonResourceEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(amazonResourceEvidence),
        "amazonAccountId": n => { amazonResourceEvidence.amazonAccountId = n.getStringValue(); },
        "amazonResourceId": n => { amazonResourceEvidence.amazonResourceId = n.getStringValue(); },
        "resourceName": n => { amazonResourceEvidence.resourceName = n.getStringValue(); },
        "resourceType": n => { amazonResourceEvidence.resourceType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAnalyzedMessageEvidence(analyzedMessageEvidence: Partial<AnalyzedMessageEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(analyzedMessageEvidence),
        "antiSpamDirection": n => { analyzedMessageEvidence.antiSpamDirection = n.getStringValue(); },
        "attachmentsCount": n => { analyzedMessageEvidence.attachmentsCount = n.getNumberValue(); },
        "deliveryAction": n => { analyzedMessageEvidence.deliveryAction = n.getStringValue(); },
        "deliveryLocation": n => { analyzedMessageEvidence.deliveryLocation = n.getStringValue(); },
        "internetMessageId": n => { analyzedMessageEvidence.internetMessageId = n.getStringValue(); },
        "language": n => { analyzedMessageEvidence.language = n.getStringValue(); },
        "networkMessageId": n => { analyzedMessageEvidence.networkMessageId = n.getStringValue(); },
        "p1Sender": n => { analyzedMessageEvidence.p1Sender = n.getObjectValue<EmailSender>(createEmailSenderFromDiscriminatorValue); },
        "p2Sender": n => { analyzedMessageEvidence.p2Sender = n.getObjectValue<EmailSender>(createEmailSenderFromDiscriminatorValue); },
        "receivedDateTime": n => { analyzedMessageEvidence.receivedDateTime = n.getDateValue(); },
        "recipientEmailAddress": n => { analyzedMessageEvidence.recipientEmailAddress = n.getStringValue(); },
        "senderIp": n => { analyzedMessageEvidence.senderIp = n.getStringValue(); },
        "subject": n => { analyzedMessageEvidence.subject = n.getStringValue(); },
        "threatDetectionMethods": n => { analyzedMessageEvidence.threatDetectionMethods = n.getCollectionOfPrimitiveValues<string>(); },
        "threats": n => { analyzedMessageEvidence.threats = n.getCollectionOfPrimitiveValues<string>(); },
        "urlCount": n => { analyzedMessageEvidence.urlCount = n.getNumberValue(); },
        "urls": n => { analyzedMessageEvidence.urls = n.getCollectionOfPrimitiveValues<string>(); },
        "urn": n => { analyzedMessageEvidence.urn = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoArticle(article: Partial<Article> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(article),
        "body": n => { article.body = n.getObjectValue<FormattedContent>(createFormattedContentFromDiscriminatorValue); },
        "createdDateTime": n => { article.createdDateTime = n.getDateValue(); },
        "imageUrl": n => { article.imageUrl = n.getStringValue(); },
        "indicators": n => { article.indicators = n.getCollectionOfObjectValues<ArticleIndicator>(createArticleIndicatorFromDiscriminatorValue); },
        "isFeatured": n => { article.isFeatured = n.getBooleanValue(); },
        "lastUpdatedDateTime": n => { article.lastUpdatedDateTime = n.getDateValue(); },
        "summary": n => { article.summary = n.getObjectValue<FormattedContent>(createFormattedContentFromDiscriminatorValue); },
        "tags": n => { article.tags = n.getCollectionOfPrimitiveValues<string>(); },
        "title": n => { article.title = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoArticleCollectionResponse(articleCollectionResponse: Partial<ArticleCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(articleCollectionResponse),
        "value": n => { articleCollectionResponse.value = n.getCollectionOfObjectValues<Article>(createArticleFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoArticleIndicator(articleIndicator: Partial<ArticleIndicator> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIndicator(articleIndicator),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoArticleIndicatorCollectionResponse(articleIndicatorCollectionResponse: Partial<ArticleIndicatorCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(articleIndicatorCollectionResponse),
        "value": n => { articleIndicatorCollectionResponse.value = n.getCollectionOfObjectValues<ArticleIndicator>(createArticleIndicatorFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoArtifact(artifact: Partial<Artifact> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(artifact),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAutonomousSystem(autonomousSystem: Partial<AutonomousSystem> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { autonomousSystem.backingStoreEnabled = true; },
        "name": n => { autonomousSystem.name = n.getStringValue(); },
        "number": n => { autonomousSystem.number = n.getNumberValue(); },
        "@odata.type": n => { autonomousSystem.odataType = n.getStringValue(); },
        "organization": n => { autonomousSystem.organization = n.getStringValue(); },
        "value": n => { autonomousSystem.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAzureResourceEvidence(azureResourceEvidence: Partial<AzureResourceEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(azureResourceEvidence),
        "resourceId": n => { azureResourceEvidence.resourceId = n.getStringValue(); },
        "resourceName": n => { azureResourceEvidence.resourceName = n.getStringValue(); },
        "resourceType": n => { azureResourceEvidence.resourceType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoBlobContainerEvidence(blobContainerEvidence: Partial<BlobContainerEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(blobContainerEvidence),
        "name": n => { blobContainerEvidence.name = n.getStringValue(); },
        "storageResource": n => { blobContainerEvidence.storageResource = n.getObjectValue<AzureResourceEvidence>(createAzureResourceEvidenceFromDiscriminatorValue); },
        "url": n => { blobContainerEvidence.url = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoBlobEvidence(blobEvidence: Partial<BlobEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(blobEvidence),
        "blobContainer": n => { blobEvidence.blobContainer = n.getObjectValue<BlobContainerEvidence>(createBlobContainerEvidenceFromDiscriminatorValue); },
        "etag": n => { blobEvidence.etag = n.getStringValue(); },
        "fileHashes": n => { blobEvidence.fileHashes = n.getCollectionOfObjectValues<FileHash>(createFileHashFromDiscriminatorValue); },
        "name": n => { blobEvidence.name = n.getStringValue(); },
        "url": n => { blobEvidence.url = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCaseEscaped(caseEscaped: Partial<CaseEscaped> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(caseEscaped),
        "createdDateTime": n => { caseEscaped.createdDateTime = n.getDateValue(); },
        "description": n => { caseEscaped.description = n.getStringValue(); },
        "displayName": n => { caseEscaped.displayName = n.getStringValue(); },
        "lastModifiedBy": n => { caseEscaped.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { caseEscaped.lastModifiedDateTime = n.getDateValue(); },
        "status": n => { caseEscaped.status = n.getEnumValue<CaseStatus>(CaseStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCaseOperation(caseOperation: Partial<CaseOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(caseOperation),
        "action": n => { caseOperation.action = n.getEnumValue<CaseAction>(CaseActionObject); },
        "completedDateTime": n => { caseOperation.completedDateTime = n.getDateValue(); },
        "createdBy": n => { caseOperation.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { caseOperation.createdDateTime = n.getDateValue(); },
        "percentProgress": n => { caseOperation.percentProgress = n.getNumberValue(); },
        "resultInfo": n => { caseOperation.resultInfo = n.getObjectValue<ResultInfo>(createResultInfoFromDiscriminatorValue); },
        "status": n => { caseOperation.status = n.getEnumValue<CaseOperationStatus>(CaseOperationStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCaseOperationCollectionResponse(caseOperationCollectionResponse: Partial<CaseOperationCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(caseOperationCollectionResponse),
        "value": n => { caseOperationCollectionResponse.value = n.getCollectionOfObjectValues<CaseOperation>(createCaseOperationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCasesRoot(casesRoot: Partial<CasesRoot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(casesRoot),
        "ediscoveryCases": n => { casesRoot.ediscoveryCases = n.getCollectionOfObjectValues<EdiscoveryCase>(createEdiscoveryCaseFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCloudApplicationEvidence(cloudApplicationEvidence: Partial<CloudApplicationEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(cloudApplicationEvidence),
        "appId": n => { cloudApplicationEvidence.appId = n.getNumberValue(); },
        "displayName": n => { cloudApplicationEvidence.displayName = n.getStringValue(); },
        "instanceId": n => { cloudApplicationEvidence.instanceId = n.getNumberValue(); },
        "instanceName": n => { cloudApplicationEvidence.instanceName = n.getStringValue(); },
        "saasAppId": n => { cloudApplicationEvidence.saasAppId = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoContainerEvidence(containerEvidence: Partial<ContainerEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(containerEvidence),
        "args": n => { containerEvidence.args = n.getCollectionOfPrimitiveValues<string>(); },
        "command": n => { containerEvidence.command = n.getCollectionOfPrimitiveValues<string>(); },
        "containerId": n => { containerEvidence.containerId = n.getStringValue(); },
        "image": n => { containerEvidence.image = n.getObjectValue<ContainerImageEvidence>(createContainerImageEvidenceFromDiscriminatorValue); },
        "isPrivileged": n => { containerEvidence.isPrivileged = n.getBooleanValue(); },
        "name": n => { containerEvidence.name = n.getStringValue(); },
        "pod": n => { containerEvidence.pod = n.getObjectValue<KubernetesPodEvidence>(createKubernetesPodEvidenceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoContainerImageEvidence(containerImageEvidence: Partial<ContainerImageEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(containerImageEvidence),
        "digestImage": n => { containerImageEvidence.digestImage = n.getObjectValue<ContainerImageEvidence>(createContainerImageEvidenceFromDiscriminatorValue); },
        "imageId": n => { containerImageEvidence.imageId = n.getStringValue(); },
        "registry": n => { containerImageEvidence.registry = n.getObjectValue<ContainerRegistryEvidence>(createContainerRegistryEvidenceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoContainerRegistryEvidence(containerRegistryEvidence: Partial<ContainerRegistryEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(containerRegistryEvidence),
        "registry": n => { containerRegistryEvidence.registry = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCvssSummary(cvssSummary: Partial<CvssSummary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { cvssSummary.backingStoreEnabled = true; },
        "@odata.type": n => { cvssSummary.odataType = n.getStringValue(); },
        "score": n => { cvssSummary.score = n.getNumberValue(); },
        "severity": n => { cvssSummary.severity = n.getEnumValue<VulnerabilitySeverity>(VulnerabilitySeverityObject); },
        "vectorString": n => { cvssSummary.vectorString = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDataSet(dataSet: Partial<DataSet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(dataSet),
        "createdBy": n => { dataSet.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { dataSet.createdDateTime = n.getDateValue(); },
        "displayName": n => { dataSet.displayName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDataSource(dataSource: Partial<DataSource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(dataSource),
        "createdBy": n => { dataSource.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { dataSource.createdDateTime = n.getDateValue(); },
        "displayName": n => { dataSource.displayName = n.getStringValue(); },
        "holdStatus": n => { dataSource.holdStatus = n.getEnumValue<DataSourceHoldStatus>(DataSourceHoldStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDataSourceCollectionResponse(dataSourceCollectionResponse: Partial<DataSourceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(dataSourceCollectionResponse),
        "value": n => { dataSourceCollectionResponse.value = n.getCollectionOfObjectValues<DataSource>(createDataSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDataSourceContainer(dataSourceContainer: Partial<DataSourceContainer> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(dataSourceContainer),
        "createdDateTime": n => { dataSourceContainer.createdDateTime = n.getDateValue(); },
        "displayName": n => { dataSourceContainer.displayName = n.getStringValue(); },
        "holdStatus": n => { dataSourceContainer.holdStatus = n.getEnumValue<DataSourceHoldStatus>(DataSourceHoldStatusObject); },
        "lastModifiedDateTime": n => { dataSourceContainer.lastModifiedDateTime = n.getDateValue(); },
        "releasedDateTime": n => { dataSourceContainer.releasedDateTime = n.getDateValue(); },
        "status": n => { dataSourceContainer.status = n.getEnumValue<DataSourceContainerStatus>(DataSourceContainerStatusObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDeviceEvidence(deviceEvidence: Partial<DeviceEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(deviceEvidence),
        "azureAdDeviceId": n => { deviceEvidence.azureAdDeviceId = n.getStringValue(); },
        "defenderAvStatus": n => { deviceEvidence.defenderAvStatus = n.getEnumValue<DefenderAvStatus>(DefenderAvStatusObject); },
        "deviceDnsName": n => { deviceEvidence.deviceDnsName = n.getStringValue(); },
        "firstSeenDateTime": n => { deviceEvidence.firstSeenDateTime = n.getDateValue(); },
        "healthStatus": n => { deviceEvidence.healthStatus = n.getEnumValue<DeviceHealthStatus>(DeviceHealthStatusObject); },
        "ipInterfaces": n => { deviceEvidence.ipInterfaces = n.getCollectionOfPrimitiveValues<string>(); },
        "loggedOnUsers": n => { deviceEvidence.loggedOnUsers = n.getCollectionOfObjectValues<LoggedOnUser>(createLoggedOnUserFromDiscriminatorValue); },
        "mdeDeviceId": n => { deviceEvidence.mdeDeviceId = n.getStringValue(); },
        "onboardingStatus": n => { deviceEvidence.onboardingStatus = n.getEnumValue<OnboardingStatus>(OnboardingStatusObject); },
        "osBuild": n => { deviceEvidence.osBuild = n.getNumberValue(); },
        "osPlatform": n => { deviceEvidence.osPlatform = n.getStringValue(); },
        "rbacGroupId": n => { deviceEvidence.rbacGroupId = n.getNumberValue(); },
        "rbacGroupName": n => { deviceEvidence.rbacGroupName = n.getStringValue(); },
        "riskScore": n => { deviceEvidence.riskScore = n.getEnumValue<DeviceRiskScore>(DeviceRiskScoreObject); },
        "version": n => { deviceEvidence.version = n.getStringValue(); },
        "vmMetadata": n => { deviceEvidence.vmMetadata = n.getObjectValue<VmMetadata>(createVmMetadataFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDictionary(dictionary: Partial<Dictionary> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { dictionary.backingStoreEnabled = true; },
        "@odata.type": n => { dictionary.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDnsEvidence(dnsEvidence: Partial<DnsEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(dnsEvidence),
        "dnsServerIp": n => { dnsEvidence.dnsServerIp = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "domainName": n => { dnsEvidence.domainName = n.getStringValue(); },
        "hostIpAddress": n => { dnsEvidence.hostIpAddress = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "ipAddresses": n => { dnsEvidence.ipAddresses = n.getCollectionOfObjectValues<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryAddToReviewSetOperation(ediscoveryAddToReviewSetOperation: Partial<EdiscoveryAddToReviewSetOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(ediscoveryAddToReviewSetOperation),
        "reviewSet": n => { ediscoveryAddToReviewSetOperation.reviewSet = n.getObjectValue<EdiscoveryReviewSet>(createEdiscoveryReviewSetFromDiscriminatorValue); },
        "search": n => { ediscoveryAddToReviewSetOperation.search = n.getObjectValue<EdiscoverySearch>(createEdiscoverySearchFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryCase(ediscoveryCase: Partial<EdiscoveryCase> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseEscaped(ediscoveryCase),
        "closedBy": n => { ediscoveryCase.closedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "closedDateTime": n => { ediscoveryCase.closedDateTime = n.getDateValue(); },
        "custodians": n => { ediscoveryCase.custodians = n.getCollectionOfObjectValues<EdiscoveryCustodian>(createEdiscoveryCustodianFromDiscriminatorValue); },
        "externalId": n => { ediscoveryCase.externalId = n.getStringValue(); },
        "noncustodialDataSources": n => { ediscoveryCase.noncustodialDataSources = n.getCollectionOfObjectValues<EdiscoveryNoncustodialDataSource>(createEdiscoveryNoncustodialDataSourceFromDiscriminatorValue); },
        "operations": n => { ediscoveryCase.operations = n.getCollectionOfObjectValues<CaseOperation>(createCaseOperationFromDiscriminatorValue); },
        "reviewSets": n => { ediscoveryCase.reviewSets = n.getCollectionOfObjectValues<EdiscoveryReviewSet>(createEdiscoveryReviewSetFromDiscriminatorValue); },
        "searches": n => { ediscoveryCase.searches = n.getCollectionOfObjectValues<EdiscoverySearch>(createEdiscoverySearchFromDiscriminatorValue); },
        "settings": n => { ediscoveryCase.settings = n.getObjectValue<EdiscoveryCaseSettings>(createEdiscoveryCaseSettingsFromDiscriminatorValue); },
        "tags": n => { ediscoveryCase.tags = n.getCollectionOfObjectValues<EdiscoveryReviewTag>(createEdiscoveryReviewTagFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryCaseCollectionResponse(ediscoveryCaseCollectionResponse: Partial<EdiscoveryCaseCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoveryCaseCollectionResponse),
        "value": n => { ediscoveryCaseCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoveryCase>(createEdiscoveryCaseFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryCaseSettings(ediscoveryCaseSettings: Partial<EdiscoveryCaseSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(ediscoveryCaseSettings),
        "ocr": n => { ediscoveryCaseSettings.ocr = n.getObjectValue<OcrSettings>(createOcrSettingsFromDiscriminatorValue); },
        "redundancyDetection": n => { ediscoveryCaseSettings.redundancyDetection = n.getObjectValue<RedundancyDetectionSettings>(createRedundancyDetectionSettingsFromDiscriminatorValue); },
        "topicModeling": n => { ediscoveryCaseSettings.topicModeling = n.getObjectValue<TopicModelingSettings>(createTopicModelingSettingsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryCustodian(ediscoveryCustodian: Partial<EdiscoveryCustodian> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSourceContainer(ediscoveryCustodian),
        "acknowledgedDateTime": n => { ediscoveryCustodian.acknowledgedDateTime = n.getDateValue(); },
        "email": n => { ediscoveryCustodian.email = n.getStringValue(); },
        "lastIndexOperation": n => { ediscoveryCustodian.lastIndexOperation = n.getObjectValue<EdiscoveryIndexOperation>(createEdiscoveryIndexOperationFromDiscriminatorValue); },
        "siteSources": n => { ediscoveryCustodian.siteSources = n.getCollectionOfObjectValues<SiteSource>(createSiteSourceFromDiscriminatorValue); },
        "unifiedGroupSources": n => { ediscoveryCustodian.unifiedGroupSources = n.getCollectionOfObjectValues<UnifiedGroupSource>(createUnifiedGroupSourceFromDiscriminatorValue); },
        "userSources": n => { ediscoveryCustodian.userSources = n.getCollectionOfObjectValues<UserSource>(createUserSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryCustodianCollectionResponse(ediscoveryCustodianCollectionResponse: Partial<EdiscoveryCustodianCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoveryCustodianCollectionResponse),
        "value": n => { ediscoveryCustodianCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoveryCustodian>(createEdiscoveryCustodianFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryEstimateOperation(ediscoveryEstimateOperation: Partial<EdiscoveryEstimateOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(ediscoveryEstimateOperation),
        "indexedItemCount": n => { ediscoveryEstimateOperation.indexedItemCount = n.getNumberValue(); },
        "indexedItemsSize": n => { ediscoveryEstimateOperation.indexedItemsSize = n.getNumberValue(); },
        "mailboxCount": n => { ediscoveryEstimateOperation.mailboxCount = n.getNumberValue(); },
        "search": n => { ediscoveryEstimateOperation.search = n.getObjectValue<EdiscoverySearch>(createEdiscoverySearchFromDiscriminatorValue); },
        "siteCount": n => { ediscoveryEstimateOperation.siteCount = n.getNumberValue(); },
        "unindexedItemCount": n => { ediscoveryEstimateOperation.unindexedItemCount = n.getNumberValue(); },
        "unindexedItemsSize": n => { ediscoveryEstimateOperation.unindexedItemsSize = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryExportOperation(ediscoveryExportOperation: Partial<EdiscoveryExportOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(ediscoveryExportOperation),
        "description": n => { ediscoveryExportOperation.description = n.getStringValue(); },
        "exportFileMetadata": n => { ediscoveryExportOperation.exportFileMetadata = n.getCollectionOfObjectValues<ExportFileMetadata>(createExportFileMetadataFromDiscriminatorValue); },
        "exportOptions": n => { ediscoveryExportOperation.exportOptions = n.getCollectionOfEnumValues<ExportOptions>(ExportOptionsObject); },
        "exportStructure": n => { ediscoveryExportOperation.exportStructure = n.getEnumValue<ExportFileStructure>(ExportFileStructureObject); },
        "outputName": n => { ediscoveryExportOperation.outputName = n.getStringValue(); },
        "reviewSet": n => { ediscoveryExportOperation.reviewSet = n.getObjectValue<EdiscoveryReviewSet>(createEdiscoveryReviewSetFromDiscriminatorValue); },
        "reviewSetQuery": n => { ediscoveryExportOperation.reviewSetQuery = n.getObjectValue<EdiscoveryReviewSetQuery>(createEdiscoveryReviewSetQueryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryHoldOperation(ediscoveryHoldOperation: Partial<EdiscoveryHoldOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(ediscoveryHoldOperation),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryIndexOperation(ediscoveryIndexOperation: Partial<EdiscoveryIndexOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(ediscoveryIndexOperation),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryNoncustodialDataSource(ediscoveryNoncustodialDataSource: Partial<EdiscoveryNoncustodialDataSource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSourceContainer(ediscoveryNoncustodialDataSource),
        "dataSource": n => { ediscoveryNoncustodialDataSource.dataSource = n.getObjectValue<DataSource>(createDataSourceFromDiscriminatorValue); },
        "lastIndexOperation": n => { ediscoveryNoncustodialDataSource.lastIndexOperation = n.getObjectValue<EdiscoveryIndexOperation>(createEdiscoveryIndexOperationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryNoncustodialDataSourceCollectionResponse(ediscoveryNoncustodialDataSourceCollectionResponse: Partial<EdiscoveryNoncustodialDataSourceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoveryNoncustodialDataSourceCollectionResponse),
        "value": n => { ediscoveryNoncustodialDataSourceCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoveryNoncustodialDataSource>(createEdiscoveryNoncustodialDataSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryPurgeDataOperation(ediscoveryPurgeDataOperation: Partial<EdiscoveryPurgeDataOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(ediscoveryPurgeDataOperation),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryReviewSet(ediscoveryReviewSet: Partial<EdiscoveryReviewSet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSet(ediscoveryReviewSet),
        "queries": n => { ediscoveryReviewSet.queries = n.getCollectionOfObjectValues<EdiscoveryReviewSetQuery>(createEdiscoveryReviewSetQueryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryReviewSetCollectionResponse(ediscoveryReviewSetCollectionResponse: Partial<EdiscoveryReviewSetCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoveryReviewSetCollectionResponse),
        "value": n => { ediscoveryReviewSetCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoveryReviewSet>(createEdiscoveryReviewSetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryReviewSetQuery(ediscoveryReviewSetQuery: Partial<EdiscoveryReviewSetQuery> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSearch(ediscoveryReviewSetQuery),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryReviewSetQueryCollectionResponse(ediscoveryReviewSetQueryCollectionResponse: Partial<EdiscoveryReviewSetQueryCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoveryReviewSetQueryCollectionResponse),
        "value": n => { ediscoveryReviewSetQueryCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoveryReviewSetQuery>(createEdiscoveryReviewSetQueryFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryReviewTag(ediscoveryReviewTag: Partial<EdiscoveryReviewTag> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoTag(ediscoveryReviewTag),
        "childSelectability": n => { ediscoveryReviewTag.childSelectability = n.getEnumValue<ChildSelectability>(ChildSelectabilityObject); },
        "childTags": n => { ediscoveryReviewTag.childTags = n.getCollectionOfObjectValues<EdiscoveryReviewTag>(createEdiscoveryReviewTagFromDiscriminatorValue); },
        "parent": n => { ediscoveryReviewTag.parent = n.getObjectValue<EdiscoveryReviewTag>(createEdiscoveryReviewTagFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryReviewTagCollectionResponse(ediscoveryReviewTagCollectionResponse: Partial<EdiscoveryReviewTagCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoveryReviewTagCollectionResponse),
        "value": n => { ediscoveryReviewTagCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoveryReviewTag>(createEdiscoveryReviewTagFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoverySearch(ediscoverySearch: Partial<EdiscoverySearch> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoSearch(ediscoverySearch),
        "additionalSources": n => { ediscoverySearch.additionalSources = n.getCollectionOfObjectValues<DataSource>(createDataSourceFromDiscriminatorValue); },
        "addToReviewSetOperation": n => { ediscoverySearch.addToReviewSetOperation = n.getObjectValue<EdiscoveryAddToReviewSetOperation>(createEdiscoveryAddToReviewSetOperationFromDiscriminatorValue); },
        "custodianSources": n => { ediscoverySearch.custodianSources = n.getCollectionOfObjectValues<DataSource>(createDataSourceFromDiscriminatorValue); },
        "dataSourceScopes": n => { ediscoverySearch.dataSourceScopes = n.getCollectionOfEnumValues<DataSourceScopes>(DataSourceScopesObject); },
        "lastEstimateStatisticsOperation": n => { ediscoverySearch.lastEstimateStatisticsOperation = n.getObjectValue<EdiscoveryEstimateOperation>(createEdiscoveryEstimateOperationFromDiscriminatorValue); },
        "noncustodialSources": n => { ediscoverySearch.noncustodialSources = n.getCollectionOfObjectValues<EdiscoveryNoncustodialDataSource>(createEdiscoveryNoncustodialDataSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoverySearchCollectionResponse(ediscoverySearchCollectionResponse: Partial<EdiscoverySearchCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(ediscoverySearchCollectionResponse),
        "value": n => { ediscoverySearchCollectionResponse.value = n.getCollectionOfObjectValues<EdiscoverySearch>(createEdiscoverySearchFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEdiscoveryTagOperation(ediscoveryTagOperation: Partial<EdiscoveryTagOperation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoCaseOperation(ediscoveryTagOperation),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEmailSender(emailSender: Partial<EmailSender> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { emailSender.backingStoreEnabled = true; },
        "displayName": n => { emailSender.displayName = n.getStringValue(); },
        "domainName": n => { emailSender.domainName = n.getStringValue(); },
        "emailAddress": n => { emailSender.emailAddress = n.getStringValue(); },
        "@odata.type": n => { emailSender.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEventPropagationResult(eventPropagationResult: Partial<EventPropagationResult> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { eventPropagationResult.backingStoreEnabled = true; },
        "location": n => { eventPropagationResult.location = n.getStringValue(); },
        "@odata.type": n => { eventPropagationResult.odataType = n.getStringValue(); },
        "serviceName": n => { eventPropagationResult.serviceName = n.getStringValue(); },
        "status": n => { eventPropagationResult.status = n.getEnumValue<EventPropagationStatus>(EventPropagationStatusObject); },
        "statusInformation": n => { eventPropagationResult.statusInformation = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEventQuery(eventQuery: Partial<EventQuery> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { eventQuery.backingStoreEnabled = true; },
        "@odata.type": n => { eventQuery.odataType = n.getStringValue(); },
        "query": n => { eventQuery.query = n.getStringValue(); },
        "queryType": n => { eventQuery.queryType = n.getEnumValue<QueryType>(QueryTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoExportFileMetadata(exportFileMetadata: Partial<ExportFileMetadata> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { exportFileMetadata.backingStoreEnabled = true; },
        "downloadUrl": n => { exportFileMetadata.downloadUrl = n.getStringValue(); },
        "fileName": n => { exportFileMetadata.fileName = n.getStringValue(); },
        "@odata.type": n => { exportFileMetadata.odataType = n.getStringValue(); },
        "size": n => { exportFileMetadata.size = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFileDetails(fileDetails: Partial<FileDetails> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { fileDetails.backingStoreEnabled = true; },
        "fileName": n => { fileDetails.fileName = n.getStringValue(); },
        "filePath": n => { fileDetails.filePath = n.getStringValue(); },
        "filePublisher": n => { fileDetails.filePublisher = n.getStringValue(); },
        "fileSize": n => { fileDetails.fileSize = n.getNumberValue(); },
        "issuer": n => { fileDetails.issuer = n.getStringValue(); },
        "@odata.type": n => { fileDetails.odataType = n.getStringValue(); },
        "sha1": n => { fileDetails.sha1 = n.getStringValue(); },
        "sha256": n => { fileDetails.sha256 = n.getStringValue(); },
        "signer": n => { fileDetails.signer = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFileEvidence(fileEvidence: Partial<FileEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(fileEvidence),
        "detectionStatus": n => { fileEvidence.detectionStatus = n.getEnumValue<DetectionStatus>(DetectionStatusObject); },
        "fileDetails": n => { fileEvidence.fileDetails = n.getObjectValue<FileDetails>(createFileDetailsFromDiscriminatorValue); },
        "mdeDeviceId": n => { fileEvidence.mdeDeviceId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFileHash(fileHash: Partial<FileHash> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "algorithm": n => { fileHash.algorithm = n.getEnumValue<FileHashAlgorithm>(FileHashAlgorithmObject); },
        "backingStoreEnabled": n => { fileHash.backingStoreEnabled = true; },
        "@odata.type": n => { fileHash.odataType = n.getStringValue(); },
        "value": n => { fileHash.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFileHashEvidence(fileHashEvidence: Partial<FileHashEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(fileHashEvidence),
        "algorithm": n => { fileHashEvidence.algorithm = n.getEnumValue<FileHashAlgorithm>(FileHashAlgorithmObject); },
        "value": n => { fileHashEvidence.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFormattedContent(formattedContent: Partial<FormattedContent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { formattedContent.backingStoreEnabled = true; },
        "content": n => { formattedContent.content = n.getStringValue(); },
        "format": n => { formattedContent.format = n.getEnumValue<ContentFormat>(ContentFormatObject); },
        "@odata.type": n => { formattedContent.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoGitHubOrganizationEvidence(gitHubOrganizationEvidence: Partial<GitHubOrganizationEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(gitHubOrganizationEvidence),
        "company": n => { gitHubOrganizationEvidence.company = n.getStringValue(); },
        "displayName": n => { gitHubOrganizationEvidence.displayName = n.getStringValue(); },
        "email": n => { gitHubOrganizationEvidence.email = n.getStringValue(); },
        "login": n => { gitHubOrganizationEvidence.login = n.getStringValue(); },
        "orgId": n => { gitHubOrganizationEvidence.orgId = n.getStringValue(); },
        "webUrl": n => { gitHubOrganizationEvidence.webUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoGitHubRepoEvidence(gitHubRepoEvidence: Partial<GitHubRepoEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(gitHubRepoEvidence),
        "baseUrl": n => { gitHubRepoEvidence.baseUrl = n.getStringValue(); },
        "login": n => { gitHubRepoEvidence.login = n.getStringValue(); },
        "owner": n => { gitHubRepoEvidence.owner = n.getStringValue(); },
        "ownerType": n => { gitHubRepoEvidence.ownerType = n.getStringValue(); },
        "repoId": n => { gitHubRepoEvidence.repoId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoGitHubUserEvidence(gitHubUserEvidence: Partial<GitHubUserEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(gitHubUserEvidence),
        "email": n => { gitHubUserEvidence.email = n.getStringValue(); },
        "login": n => { gitHubUserEvidence.login = n.getStringValue(); },
        "name": n => { gitHubUserEvidence.name = n.getStringValue(); },
        "userId": n => { gitHubUserEvidence.userId = n.getStringValue(); },
        "webUrl": n => { gitHubUserEvidence.webUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoGoogleCloudResourceEvidence(googleCloudResourceEvidence: Partial<GoogleCloudResourceEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(googleCloudResourceEvidence),
        "location": n => { googleCloudResourceEvidence.location = n.getStringValue(); },
        "locationType": n => { googleCloudResourceEvidence.locationType = n.getEnumValue<GoogleCloudLocationType>(GoogleCloudLocationTypeObject); },
        "projectId": n => { googleCloudResourceEvidence.projectId = n.getStringValue(); },
        "projectNumber": n => { googleCloudResourceEvidence.projectNumber = n.getNumberValue(); },
        "resourceName": n => { googleCloudResourceEvidence.resourceName = n.getStringValue(); },
        "resourceType": n => { googleCloudResourceEvidence.resourceType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHost(host: Partial<Host> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(host),
        "childHostPairs": n => { host.childHostPairs = n.getCollectionOfObjectValues<HostPair>(createHostPairFromDiscriminatorValue); },
        "components": n => { host.components = n.getCollectionOfObjectValues<HostComponent>(createHostComponentFromDiscriminatorValue); },
        "cookies": n => { host.cookies = n.getCollectionOfObjectValues<HostCookie>(createHostCookieFromDiscriminatorValue); },
        "firstSeenDateTime": n => { host.firstSeenDateTime = n.getDateValue(); },
        "hostPairs": n => { host.hostPairs = n.getCollectionOfObjectValues<HostPair>(createHostPairFromDiscriminatorValue); },
        "lastSeenDateTime": n => { host.lastSeenDateTime = n.getDateValue(); },
        "parentHostPairs": n => { host.parentHostPairs = n.getCollectionOfObjectValues<HostPair>(createHostPairFromDiscriminatorValue); },
        "passiveDns": n => { host.passiveDns = n.getCollectionOfObjectValues<PassiveDnsRecord>(createPassiveDnsRecordFromDiscriminatorValue); },
        "passiveDnsReverse": n => { host.passiveDnsReverse = n.getCollectionOfObjectValues<PassiveDnsRecord>(createPassiveDnsRecordFromDiscriminatorValue); },
        "ports": n => { host.ports = n.getCollectionOfObjectValues<HostPort>(createHostPortFromDiscriminatorValue); },
        "reputation": n => { host.reputation = n.getObjectValue<HostReputation>(createHostReputationFromDiscriminatorValue); },
        "sslCertificates": n => { host.sslCertificates = n.getCollectionOfObjectValues<HostSslCertificate>(createHostSslCertificateFromDiscriminatorValue); },
        "subdomains": n => { host.subdomains = n.getCollectionOfObjectValues<Subdomain>(createSubdomainFromDiscriminatorValue); },
        "trackers": n => { host.trackers = n.getCollectionOfObjectValues<HostTracker>(createHostTrackerFromDiscriminatorValue); },
        "whois": n => { host.whois = n.getObjectValue<WhoisRecord>(createWhoisRecordFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostCollectionResponse(hostCollectionResponse: Partial<HostCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(hostCollectionResponse),
        "value": n => { hostCollectionResponse.value = n.getCollectionOfObjectValues<Host>(createHostFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostComponent(hostComponent: Partial<HostComponent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(hostComponent),
        "category": n => { hostComponent.category = n.getStringValue(); },
        "firstSeenDateTime": n => { hostComponent.firstSeenDateTime = n.getDateValue(); },
        "host": n => { hostComponent.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "lastSeenDateTime": n => { hostComponent.lastSeenDateTime = n.getDateValue(); },
        "name": n => { hostComponent.name = n.getStringValue(); },
        "version": n => { hostComponent.version = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostComponentCollectionResponse(hostComponentCollectionResponse: Partial<HostComponentCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(hostComponentCollectionResponse),
        "value": n => { hostComponentCollectionResponse.value = n.getCollectionOfObjectValues<HostComponent>(createHostComponentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostCookie(hostCookie: Partial<HostCookie> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(hostCookie),
        "domain": n => { hostCookie.domain = n.getStringValue(); },
        "firstSeenDateTime": n => { hostCookie.firstSeenDateTime = n.getDateValue(); },
        "host": n => { hostCookie.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "lastSeenDateTime": n => { hostCookie.lastSeenDateTime = n.getDateValue(); },
        "name": n => { hostCookie.name = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostCookieCollectionResponse(hostCookieCollectionResponse: Partial<HostCookieCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(hostCookieCollectionResponse),
        "value": n => { hostCookieCollectionResponse.value = n.getCollectionOfObjectValues<HostCookie>(createHostCookieFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostLogonSessionEvidence(hostLogonSessionEvidence: Partial<HostLogonSessionEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(hostLogonSessionEvidence),
        "account": n => { hostLogonSessionEvidence.account = n.getObjectValue<UserEvidence>(createUserEvidenceFromDiscriminatorValue); },
        "endUtcDateTime": n => { hostLogonSessionEvidence.endUtcDateTime = n.getDateValue(); },
        "host": n => { hostLogonSessionEvidence.host = n.getObjectValue<DeviceEvidence>(createDeviceEvidenceFromDiscriminatorValue); },
        "sessionId": n => { hostLogonSessionEvidence.sessionId = n.getStringValue(); },
        "startUtcDateTime": n => { hostLogonSessionEvidence.startUtcDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostname(hostname: Partial<Hostname> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoHost(hostname),
        "registrant": n => { hostname.registrant = n.getStringValue(); },
        "registrar": n => { hostname.registrar = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostPair(hostPair: Partial<HostPair> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(hostPair),
        "childHost": n => { hostPair.childHost = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "firstSeenDateTime": n => { hostPair.firstSeenDateTime = n.getDateValue(); },
        "lastSeenDateTime": n => { hostPair.lastSeenDateTime = n.getDateValue(); },
        "linkKind": n => { hostPair.linkKind = n.getStringValue(); },
        "parentHost": n => { hostPair.parentHost = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostPairCollectionResponse(hostPairCollectionResponse: Partial<HostPairCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(hostPairCollectionResponse),
        "value": n => { hostPairCollectionResponse.value = n.getCollectionOfObjectValues<HostPair>(createHostPairFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostPort(hostPort: Partial<HostPort> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(hostPort),
        "banners": n => { hostPort.banners = n.getCollectionOfObjectValues<HostPortBanner>(createHostPortBannerFromDiscriminatorValue); },
        "firstSeenDateTime": n => { hostPort.firstSeenDateTime = n.getDateValue(); },
        "host": n => { hostPort.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "lastScanDateTime": n => { hostPort.lastScanDateTime = n.getDateValue(); },
        "lastSeenDateTime": n => { hostPort.lastSeenDateTime = n.getDateValue(); },
        "mostRecentSslCertificate": n => { hostPort.mostRecentSslCertificate = n.getObjectValue<SslCertificate>(createSslCertificateFromDiscriminatorValue); },
        "port": n => { hostPort.port = n.getNumberValue(); },
        "protocol": n => { hostPort.protocol = n.getEnumValue<HostPortProtocol>(HostPortProtocolObject); },
        "services": n => { hostPort.services = n.getCollectionOfObjectValues<HostPortComponent>(createHostPortComponentFromDiscriminatorValue); },
        "status": n => { hostPort.status = n.getEnumValue<HostPortStatus>(HostPortStatusObject); },
        "timesObserved": n => { hostPort.timesObserved = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostPortBanner(hostPortBanner: Partial<HostPortBanner> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { hostPortBanner.backingStoreEnabled = true; },
        "banner": n => { hostPortBanner.banner = n.getStringValue(); },
        "firstSeenDateTime": n => { hostPortBanner.firstSeenDateTime = n.getDateValue(); },
        "lastSeenDateTime": n => { hostPortBanner.lastSeenDateTime = n.getDateValue(); },
        "@odata.type": n => { hostPortBanner.odataType = n.getStringValue(); },
        "scanProtocol": n => { hostPortBanner.scanProtocol = n.getStringValue(); },
        "timesObserved": n => { hostPortBanner.timesObserved = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostPortCollectionResponse(hostPortCollectionResponse: Partial<HostPortCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(hostPortCollectionResponse),
        "value": n => { hostPortCollectionResponse.value = n.getCollectionOfObjectValues<HostPort>(createHostPortFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostPortComponent(hostPortComponent: Partial<HostPortComponent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { hostPortComponent.backingStoreEnabled = true; },
        "component": n => { hostPortComponent.component = n.getObjectValue<HostComponent>(createHostComponentFromDiscriminatorValue); },
        "firstSeenDateTime": n => { hostPortComponent.firstSeenDateTime = n.getDateValue(); },
        "isRecent": n => { hostPortComponent.isRecent = n.getBooleanValue(); },
        "lastSeenDateTime": n => { hostPortComponent.lastSeenDateTime = n.getDateValue(); },
        "@odata.type": n => { hostPortComponent.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostReputation(hostReputation: Partial<HostReputation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(hostReputation),
        "classification": n => { hostReputation.classification = n.getEnumValue<HostReputationClassification>(HostReputationClassificationObject); },
        "rules": n => { hostReputation.rules = n.getCollectionOfObjectValues<HostReputationRule>(createHostReputationRuleFromDiscriminatorValue); },
        "score": n => { hostReputation.score = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostReputationRule(hostReputationRule: Partial<HostReputationRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { hostReputationRule.backingStoreEnabled = true; },
        "description": n => { hostReputationRule.description = n.getStringValue(); },
        "name": n => { hostReputationRule.name = n.getStringValue(); },
        "@odata.type": n => { hostReputationRule.odataType = n.getStringValue(); },
        "relatedDetailsUrl": n => { hostReputationRule.relatedDetailsUrl = n.getStringValue(); },
        "severity": n => { hostReputationRule.severity = n.getEnumValue<HostReputationRuleSeverity>(HostReputationRuleSeverityObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostSslCertificate(hostSslCertificate: Partial<HostSslCertificate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(hostSslCertificate),
        "firstSeenDateTime": n => { hostSslCertificate.firstSeenDateTime = n.getDateValue(); },
        "host": n => { hostSslCertificate.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "lastSeenDateTime": n => { hostSslCertificate.lastSeenDateTime = n.getDateValue(); },
        "ports": n => { hostSslCertificate.ports = n.getCollectionOfObjectValues<HostSslCertificatePort>(createHostSslCertificatePortFromDiscriminatorValue); },
        "sslCertificate": n => { hostSslCertificate.sslCertificate = n.getObjectValue<SslCertificate>(createSslCertificateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostSslCertificateCollectionResponse(hostSslCertificateCollectionResponse: Partial<HostSslCertificateCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(hostSslCertificateCollectionResponse),
        "value": n => { hostSslCertificateCollectionResponse.value = n.getCollectionOfObjectValues<HostSslCertificate>(createHostSslCertificateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostSslCertificatePort(hostSslCertificatePort: Partial<HostSslCertificatePort> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { hostSslCertificatePort.backingStoreEnabled = true; },
        "firstSeenDateTime": n => { hostSslCertificatePort.firstSeenDateTime = n.getDateValue(); },
        "lastSeenDateTime": n => { hostSslCertificatePort.lastSeenDateTime = n.getDateValue(); },
        "@odata.type": n => { hostSslCertificatePort.odataType = n.getStringValue(); },
        "port": n => { hostSslCertificatePort.port = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostTracker(hostTracker: Partial<HostTracker> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(hostTracker),
        "firstSeenDateTime": n => { hostTracker.firstSeenDateTime = n.getDateValue(); },
        "host": n => { hostTracker.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "kind": n => { hostTracker.kind = n.getStringValue(); },
        "lastSeenDateTime": n => { hostTracker.lastSeenDateTime = n.getDateValue(); },
        "value": n => { hostTracker.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHostTrackerCollectionResponse(hostTrackerCollectionResponse: Partial<HostTrackerCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(hostTrackerCollectionResponse),
        "value": n => { hostTrackerCollectionResponse.value = n.getCollectionOfObjectValues<HostTracker>(createHostTrackerFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHuntingQueryResults(huntingQueryResults: Partial<HuntingQueryResults> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { huntingQueryResults.backingStoreEnabled = true; },
        "@odata.type": n => { huntingQueryResults.odataType = n.getStringValue(); },
        "results": n => { huntingQueryResults.results = n.getCollectionOfObjectValues<HuntingRowResult>(createHuntingRowResultFromDiscriminatorValue); },
        "schema": n => { huntingQueryResults.schema = n.getCollectionOfObjectValues<SinglePropertySchema>(createSinglePropertySchemaFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHuntingRowResult(huntingRowResult: Partial<HuntingRowResult> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { huntingRowResult.backingStoreEnabled = true; },
        "@odata.type": n => { huntingRowResult.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoHyperlink(hyperlink: Partial<Hyperlink> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { hyperlink.backingStoreEnabled = true; },
        "name": n => { hyperlink.name = n.getStringValue(); },
        "@odata.type": n => { hyperlink.odataType = n.getStringValue(); },
        "url": n => { hyperlink.url = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIncident(incident: Partial<Incident> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(incident),
        "alerts": n => { incident.alerts = n.getCollectionOfObjectValues<Alert>(createAlertFromDiscriminatorValue); },
        "assignedTo": n => { incident.assignedTo = n.getStringValue(); },
        "classification": n => { incident.classification = n.getEnumValue<AlertClassification>(AlertClassificationObject); },
        "comments": n => { incident.comments = n.getCollectionOfObjectValues<AlertComment>(createAlertCommentFromDiscriminatorValue); },
        "createdDateTime": n => { incident.createdDateTime = n.getDateValue(); },
        "customTags": n => { incident.customTags = n.getCollectionOfPrimitiveValues<string>(); },
        "description": n => { incident.description = n.getStringValue(); },
        "determination": n => { incident.determination = n.getEnumValue<AlertDetermination>(AlertDeterminationObject); },
        "displayName": n => { incident.displayName = n.getStringValue(); },
        "incidentWebUrl": n => { incident.incidentWebUrl = n.getStringValue(); },
        "lastModifiedBy": n => { incident.lastModifiedBy = n.getStringValue(); },
        "lastUpdateDateTime": n => { incident.lastUpdateDateTime = n.getDateValue(); },
        "redirectIncidentId": n => { incident.redirectIncidentId = n.getStringValue(); },
        "severity": n => { incident.severity = n.getEnumValue<AlertSeverity>(AlertSeverityObject); },
        "status": n => { incident.status = n.getEnumValue<IncidentStatus>(IncidentStatusObject); },
        "systemTags": n => { incident.systemTags = n.getCollectionOfPrimitiveValues<string>(); },
        "tenantId": n => { incident.tenantId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIncidentCollectionResponse(incidentCollectionResponse: Partial<IncidentCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(incidentCollectionResponse),
        "value": n => { incidentCollectionResponse.value = n.getCollectionOfObjectValues<Incident>(createIncidentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIndicator(indicator: Partial<Indicator> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(indicator),
        "artifact": n => { indicator.artifact = n.getObjectValue<Artifact>(createArtifactFromDiscriminatorValue); },
        "source": n => { indicator.source = n.getEnumValue<IndicatorSource>(IndicatorSourceObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIntelligenceProfile(intelligenceProfile: Partial<IntelligenceProfile> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(intelligenceProfile),
        "aliases": n => { intelligenceProfile.aliases = n.getCollectionOfPrimitiveValues<string>(); },
        "countriesOrRegionsOfOrigin": n => { intelligenceProfile.countriesOrRegionsOfOrigin = n.getCollectionOfObjectValues<IntelligenceProfileCountryOrRegionOfOrigin>(createIntelligenceProfileCountryOrRegionOfOriginFromDiscriminatorValue); },
        "description": n => { intelligenceProfile.description = n.getObjectValue<FormattedContent>(createFormattedContentFromDiscriminatorValue); },
        "firstActiveDateTime": n => { intelligenceProfile.firstActiveDateTime = n.getDateValue(); },
        "indicators": n => { intelligenceProfile.indicators = n.getCollectionOfObjectValues<IntelligenceProfileIndicator>(createIntelligenceProfileIndicatorFromDiscriminatorValue); },
        "kind": n => { intelligenceProfile.kind = n.getEnumValue<IntelligenceProfileKind>(IntelligenceProfileKindObject); },
        "summary": n => { intelligenceProfile.summary = n.getObjectValue<FormattedContent>(createFormattedContentFromDiscriminatorValue); },
        "targets": n => { intelligenceProfile.targets = n.getCollectionOfPrimitiveValues<string>(); },
        "title": n => { intelligenceProfile.title = n.getStringValue(); },
        "tradecraft": n => { intelligenceProfile.tradecraft = n.getObjectValue<FormattedContent>(createFormattedContentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIntelligenceProfileCollectionResponse(intelligenceProfileCollectionResponse: Partial<IntelligenceProfileCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(intelligenceProfileCollectionResponse),
        "value": n => { intelligenceProfileCollectionResponse.value = n.getCollectionOfObjectValues<IntelligenceProfile>(createIntelligenceProfileFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIntelligenceProfileCountryOrRegionOfOrigin(intelligenceProfileCountryOrRegionOfOrigin: Partial<IntelligenceProfileCountryOrRegionOfOrigin> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { intelligenceProfileCountryOrRegionOfOrigin.backingStoreEnabled = true; },
        "code": n => { intelligenceProfileCountryOrRegionOfOrigin.code = n.getStringValue(); },
        "label": n => { intelligenceProfileCountryOrRegionOfOrigin.label = n.getStringValue(); },
        "@odata.type": n => { intelligenceProfileCountryOrRegionOfOrigin.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIntelligenceProfileIndicator(intelligenceProfileIndicator: Partial<IntelligenceProfileIndicator> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIndicator(intelligenceProfileIndicator),
        "firstSeenDateTime": n => { intelligenceProfileIndicator.firstSeenDateTime = n.getDateValue(); },
        "lastSeenDateTime": n => { intelligenceProfileIndicator.lastSeenDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIntelligenceProfileIndicatorCollectionResponse(intelligenceProfileIndicatorCollectionResponse: Partial<IntelligenceProfileIndicatorCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(intelligenceProfileIndicatorCollectionResponse),
        "value": n => { intelligenceProfileIndicatorCollectionResponse.value = n.getCollectionOfObjectValues<IntelligenceProfileIndicator>(createIntelligenceProfileIndicatorFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIoTDeviceEvidence(ioTDeviceEvidence: Partial<IoTDeviceEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(ioTDeviceEvidence),
        "deviceId": n => { ioTDeviceEvidence.deviceId = n.getStringValue(); },
        "deviceName": n => { ioTDeviceEvidence.deviceName = n.getStringValue(); },
        "devicePageLink": n => { ioTDeviceEvidence.devicePageLink = n.getStringValue(); },
        "deviceSubType": n => { ioTDeviceEvidence.deviceSubType = n.getStringValue(); },
        "deviceType": n => { ioTDeviceEvidence.deviceType = n.getStringValue(); },
        "importance": n => { ioTDeviceEvidence.importance = n.getEnumValue<IoTDeviceImportanceType>(IoTDeviceImportanceTypeObject); },
        "ioTHub": n => { ioTDeviceEvidence.ioTHub = n.getObjectValue<AzureResourceEvidence>(createAzureResourceEvidenceFromDiscriminatorValue); },
        "ioTSecurityAgentId": n => { ioTDeviceEvidence.ioTSecurityAgentId = n.getStringValue(); },
        "ipAddress": n => { ioTDeviceEvidence.ipAddress = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "isAuthorized": n => { ioTDeviceEvidence.isAuthorized = n.getBooleanValue(); },
        "isProgramming": n => { ioTDeviceEvidence.isProgramming = n.getBooleanValue(); },
        "isScanner": n => { ioTDeviceEvidence.isScanner = n.getBooleanValue(); },
        "macAddress": n => { ioTDeviceEvidence.macAddress = n.getStringValue(); },
        "manufacturer": n => { ioTDeviceEvidence.manufacturer = n.getStringValue(); },
        "model": n => { ioTDeviceEvidence.model = n.getStringValue(); },
        "nics": n => { ioTDeviceEvidence.nics = n.getObjectValue<NicEvidence>(createNicEvidenceFromDiscriminatorValue); },
        "operatingSystem": n => { ioTDeviceEvidence.operatingSystem = n.getStringValue(); },
        "owners": n => { ioTDeviceEvidence.owners = n.getCollectionOfPrimitiveValues<string>(); },
        "protocols": n => { ioTDeviceEvidence.protocols = n.getCollectionOfPrimitiveValues<string>(); },
        "purdueLayer": n => { ioTDeviceEvidence.purdueLayer = n.getStringValue(); },
        "sensor": n => { ioTDeviceEvidence.sensor = n.getStringValue(); },
        "serialNumber": n => { ioTDeviceEvidence.serialNumber = n.getStringValue(); },
        "site": n => { ioTDeviceEvidence.site = n.getStringValue(); },
        "source": n => { ioTDeviceEvidence.source = n.getStringValue(); },
        "sourceRef": n => { ioTDeviceEvidence.sourceRef = n.getObjectValue<UrlEvidence>(createUrlEvidenceFromDiscriminatorValue); },
        "zone": n => { ioTDeviceEvidence.zone = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIpAddress(ipAddress: Partial<IpAddress> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoHost(ipAddress),
        "autonomousSystem": n => { ipAddress.autonomousSystem = n.getObjectValue<AutonomousSystem>(createAutonomousSystemFromDiscriminatorValue); },
        "countryOrRegion": n => { ipAddress.countryOrRegion = n.getStringValue(); },
        "hostingProvider": n => { ipAddress.hostingProvider = n.getStringValue(); },
        "netblock": n => { ipAddress.netblock = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIpEvidence(ipEvidence: Partial<IpEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(ipEvidence),
        "countryLetterCode": n => { ipEvidence.countryLetterCode = n.getStringValue(); },
        "ipAddress": n => { ipEvidence.ipAddress = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesClusterEvidence(kubernetesClusterEvidence: Partial<KubernetesClusterEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(kubernetesClusterEvidence),
        "cloudResource": n => { kubernetesClusterEvidence.cloudResource = n.getObjectValue<AlertEvidence>(createAlertEvidenceFromDiscriminatorValue); },
        "distribution": n => { kubernetesClusterEvidence.distribution = n.getStringValue(); },
        "name": n => { kubernetesClusterEvidence.name = n.getStringValue(); },
        "platform": n => { kubernetesClusterEvidence.platform = n.getEnumValue<KubernetesPlatform>(KubernetesPlatformObject); },
        "version": n => { kubernetesClusterEvidence.version = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesControllerEvidence(kubernetesControllerEvidence: Partial<KubernetesControllerEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(kubernetesControllerEvidence),
        "labels": n => { kubernetesControllerEvidence.labels = n.getObjectValue<Dictionary>(createDictionaryFromDiscriminatorValue); },
        "name": n => { kubernetesControllerEvidence.name = n.getStringValue(); },
        "namespace": n => { kubernetesControllerEvidence.namespace = n.getObjectValue<KubernetesNamespaceEvidence>(createKubernetesNamespaceEvidenceFromDiscriminatorValue); },
        "type": n => { kubernetesControllerEvidence.type = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesNamespaceEvidence(kubernetesNamespaceEvidence: Partial<KubernetesNamespaceEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(kubernetesNamespaceEvidence),
        "cluster": n => { kubernetesNamespaceEvidence.cluster = n.getObjectValue<KubernetesClusterEvidence>(createKubernetesClusterEvidenceFromDiscriminatorValue); },
        "labels": n => { kubernetesNamespaceEvidence.labels = n.getObjectValue<Dictionary>(createDictionaryFromDiscriminatorValue); },
        "name": n => { kubernetesNamespaceEvidence.name = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesPodEvidence(kubernetesPodEvidence: Partial<KubernetesPodEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(kubernetesPodEvidence),
        "containers": n => { kubernetesPodEvidence.containers = n.getCollectionOfObjectValues<ContainerEvidence>(createContainerEvidenceFromDiscriminatorValue); },
        "controller": n => { kubernetesPodEvidence.controller = n.getObjectValue<KubernetesControllerEvidence>(createKubernetesControllerEvidenceFromDiscriminatorValue); },
        "ephemeralContainers": n => { kubernetesPodEvidence.ephemeralContainers = n.getCollectionOfObjectValues<ContainerEvidence>(createContainerEvidenceFromDiscriminatorValue); },
        "initContainers": n => { kubernetesPodEvidence.initContainers = n.getCollectionOfObjectValues<ContainerEvidence>(createContainerEvidenceFromDiscriminatorValue); },
        "labels": n => { kubernetesPodEvidence.labels = n.getObjectValue<Dictionary>(createDictionaryFromDiscriminatorValue); },
        "name": n => { kubernetesPodEvidence.name = n.getStringValue(); },
        "namespace": n => { kubernetesPodEvidence.namespace = n.getObjectValue<KubernetesNamespaceEvidence>(createKubernetesNamespaceEvidenceFromDiscriminatorValue); },
        "podIp": n => { kubernetesPodEvidence.podIp = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "serviceAccount": n => { kubernetesPodEvidence.serviceAccount = n.getObjectValue<KubernetesServiceAccountEvidence>(createKubernetesServiceAccountEvidenceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesSecretEvidence(kubernetesSecretEvidence: Partial<KubernetesSecretEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(kubernetesSecretEvidence),
        "name": n => { kubernetesSecretEvidence.name = n.getStringValue(); },
        "namespace": n => { kubernetesSecretEvidence.namespace = n.getObjectValue<KubernetesNamespaceEvidence>(createKubernetesNamespaceEvidenceFromDiscriminatorValue); },
        "secretType": n => { kubernetesSecretEvidence.secretType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesServiceAccountEvidence(kubernetesServiceAccountEvidence: Partial<KubernetesServiceAccountEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(kubernetesServiceAccountEvidence),
        "name": n => { kubernetesServiceAccountEvidence.name = n.getStringValue(); },
        "namespace": n => { kubernetesServiceAccountEvidence.namespace = n.getObjectValue<KubernetesNamespaceEvidence>(createKubernetesNamespaceEvidenceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesServiceEvidence(kubernetesServiceEvidence: Partial<KubernetesServiceEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(kubernetesServiceEvidence),
        "clusterIP": n => { kubernetesServiceEvidence.clusterIP = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "externalIPs": n => { kubernetesServiceEvidence.externalIPs = n.getCollectionOfObjectValues<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "labels": n => { kubernetesServiceEvidence.labels = n.getObjectValue<Dictionary>(createDictionaryFromDiscriminatorValue); },
        "name": n => { kubernetesServiceEvidence.name = n.getStringValue(); },
        "namespace": n => { kubernetesServiceEvidence.namespace = n.getObjectValue<KubernetesNamespaceEvidence>(createKubernetesNamespaceEvidenceFromDiscriminatorValue); },
        "selector": n => { kubernetesServiceEvidence.selector = n.getObjectValue<Dictionary>(createDictionaryFromDiscriminatorValue); },
        "servicePorts": n => { kubernetesServiceEvidence.servicePorts = n.getCollectionOfObjectValues<KubernetesServicePort>(createKubernetesServicePortFromDiscriminatorValue); },
        "serviceType": n => { kubernetesServiceEvidence.serviceType = n.getEnumValue<KubernetesServiceType>(KubernetesServiceTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoKubernetesServicePort(kubernetesServicePort: Partial<KubernetesServicePort> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "appProtocol": n => { kubernetesServicePort.appProtocol = n.getStringValue(); },
        "backingStoreEnabled": n => { kubernetesServicePort.backingStoreEnabled = true; },
        "name": n => { kubernetesServicePort.name = n.getStringValue(); },
        "nodePort": n => { kubernetesServicePort.nodePort = n.getNumberValue(); },
        "@odata.type": n => { kubernetesServicePort.odataType = n.getStringValue(); },
        "port": n => { kubernetesServicePort.port = n.getNumberValue(); },
        "protocol": n => { kubernetesServicePort.protocol = n.getEnumValue<ContainerPortProtocol>(ContainerPortProtocolObject); },
        "targetPort": n => { kubernetesServicePort.targetPort = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoLoggedOnUser(loggedOnUser: Partial<LoggedOnUser> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "accountName": n => { loggedOnUser.accountName = n.getStringValue(); },
        "backingStoreEnabled": n => { loggedOnUser.backingStoreEnabled = true; },
        "domainName": n => { loggedOnUser.domainName = n.getStringValue(); },
        "@odata.type": n => { loggedOnUser.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMailboxEvidence(mailboxEvidence: Partial<MailboxEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(mailboxEvidence),
        "displayName": n => { mailboxEvidence.displayName = n.getStringValue(); },
        "primaryAddress": n => { mailboxEvidence.primaryAddress = n.getStringValue(); },
        "userAccount": n => { mailboxEvidence.userAccount = n.getObjectValue<UserAccount>(createUserAccountFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMailClusterEvidence(mailClusterEvidence: Partial<MailClusterEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(mailClusterEvidence),
        "clusterBy": n => { mailClusterEvidence.clusterBy = n.getStringValue(); },
        "clusterByValue": n => { mailClusterEvidence.clusterByValue = n.getStringValue(); },
        "emailCount": n => { mailClusterEvidence.emailCount = n.getNumberValue(); },
        "networkMessageIds": n => { mailClusterEvidence.networkMessageIds = n.getCollectionOfPrimitiveValues<string>(); },
        "query": n => { mailClusterEvidence.query = n.getStringValue(); },
        "urn": n => { mailClusterEvidence.urn = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMalwareEvidence(malwareEvidence: Partial<MalwareEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(malwareEvidence),
        "category": n => { malwareEvidence.category = n.getStringValue(); },
        "files": n => { malwareEvidence.files = n.getCollectionOfObjectValues<FileEvidence>(createFileEvidenceFromDiscriminatorValue); },
        "name": n => { malwareEvidence.name = n.getStringValue(); },
        "processes": n => { malwareEvidence.processes = n.getCollectionOfObjectValues<ProcessEvidence>(createProcessEvidenceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoNetworkConnectionEvidence(networkConnectionEvidence: Partial<NetworkConnectionEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(networkConnectionEvidence),
        "destinationAddress": n => { networkConnectionEvidence.destinationAddress = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "destinationPort": n => { networkConnectionEvidence.destinationPort = n.getNumberValue(); },
        "protocol": n => { networkConnectionEvidence.protocol = n.getEnumValue<ProtocolType>(ProtocolTypeObject); },
        "sourceAddress": n => { networkConnectionEvidence.sourceAddress = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "sourcePort": n => { networkConnectionEvidence.sourcePort = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoNicEvidence(nicEvidence: Partial<NicEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(nicEvidence),
        "ipAddress": n => { nicEvidence.ipAddress = n.getObjectValue<IpEvidence>(createIpEvidenceFromDiscriminatorValue); },
        "macAddress": n => { nicEvidence.macAddress = n.getStringValue(); },
        "vlans": n => { nicEvidence.vlans = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoOauthApplicationEvidence(oauthApplicationEvidence: Partial<OauthApplicationEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(oauthApplicationEvidence),
        "appId": n => { oauthApplicationEvidence.appId = n.getStringValue(); },
        "displayName": n => { oauthApplicationEvidence.displayName = n.getStringValue(); },
        "objectId": n => { oauthApplicationEvidence.objectId = n.getStringValue(); },
        "publisher": n => { oauthApplicationEvidence.publisher = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoOcrSettings(ocrSettings: Partial<OcrSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { ocrSettings.backingStoreEnabled = true; },
        "isEnabled": n => { ocrSettings.isEnabled = n.getBooleanValue(); },
        "maxImageSize": n => { ocrSettings.maxImageSize = n.getNumberValue(); },
        "@odata.type": n => { ocrSettings.odataType = n.getStringValue(); },
        "timeout": n => { ocrSettings.timeout = n.getDurationValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoPassiveDnsRecord(passiveDnsRecord: Partial<PassiveDnsRecord> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(passiveDnsRecord),
        "artifact": n => { passiveDnsRecord.artifact = n.getObjectValue<Artifact>(createArtifactFromDiscriminatorValue); },
        "collectedDateTime": n => { passiveDnsRecord.collectedDateTime = n.getDateValue(); },
        "firstSeenDateTime": n => { passiveDnsRecord.firstSeenDateTime = n.getDateValue(); },
        "lastSeenDateTime": n => { passiveDnsRecord.lastSeenDateTime = n.getDateValue(); },
        "parentHost": n => { passiveDnsRecord.parentHost = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "recordType": n => { passiveDnsRecord.recordType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoPassiveDnsRecordCollectionResponse(passiveDnsRecordCollectionResponse: Partial<PassiveDnsRecordCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(passiveDnsRecordCollectionResponse),
        "value": n => { passiveDnsRecordCollectionResponse.value = n.getCollectionOfObjectValues<PassiveDnsRecord>(createPassiveDnsRecordFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProcessEvidence(processEvidence: Partial<ProcessEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(processEvidence),
        "detectionStatus": n => { processEvidence.detectionStatus = n.getEnumValue<DetectionStatus>(DetectionStatusObject); },
        "imageFile": n => { processEvidence.imageFile = n.getObjectValue<FileDetails>(createFileDetailsFromDiscriminatorValue); },
        "mdeDeviceId": n => { processEvidence.mdeDeviceId = n.getStringValue(); },
        "parentProcessCreationDateTime": n => { processEvidence.parentProcessCreationDateTime = n.getDateValue(); },
        "parentProcessId": n => { processEvidence.parentProcessId = n.getNumberValue(); },
        "parentProcessImageFile": n => { processEvidence.parentProcessImageFile = n.getObjectValue<FileDetails>(createFileDetailsFromDiscriminatorValue); },
        "processCommandLine": n => { processEvidence.processCommandLine = n.getStringValue(); },
        "processCreationDateTime": n => { processEvidence.processCreationDateTime = n.getDateValue(); },
        "processId": n => { processEvidence.processId = n.getNumberValue(); },
        "userAccount": n => { processEvidence.userAccount = n.getObjectValue<UserAccount>(createUserAccountFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRedundancyDetectionSettings(redundancyDetectionSettings: Partial<RedundancyDetectionSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { redundancyDetectionSettings.backingStoreEnabled = true; },
        "isEnabled": n => { redundancyDetectionSettings.isEnabled = n.getBooleanValue(); },
        "maxWords": n => { redundancyDetectionSettings.maxWords = n.getNumberValue(); },
        "minWords": n => { redundancyDetectionSettings.minWords = n.getNumberValue(); },
        "@odata.type": n => { redundancyDetectionSettings.odataType = n.getStringValue(); },
        "similarityThreshold": n => { redundancyDetectionSettings.similarityThreshold = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRegistryKeyEvidence(registryKeyEvidence: Partial<RegistryKeyEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(registryKeyEvidence),
        "registryHive": n => { registryKeyEvidence.registryHive = n.getStringValue(); },
        "registryKey": n => { registryKeyEvidence.registryKey = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRegistryValueEvidence(registryValueEvidence: Partial<RegistryValueEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(registryValueEvidence),
        "mdeDeviceId": n => { registryValueEvidence.mdeDeviceId = n.getStringValue(); },
        "registryHive": n => { registryValueEvidence.registryHive = n.getStringValue(); },
        "registryKey": n => { registryValueEvidence.registryKey = n.getStringValue(); },
        "registryValue": n => { registryValueEvidence.registryValue = n.getStringValue(); },
        "registryValueName": n => { registryValueEvidence.registryValueName = n.getStringValue(); },
        "registryValueType": n => { registryValueEvidence.registryValueType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRetentionEvent(retentionEvent: Partial<RetentionEvent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(retentionEvent),
        "createdBy": n => { retentionEvent.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { retentionEvent.createdDateTime = n.getDateValue(); },
        "description": n => { retentionEvent.description = n.getStringValue(); },
        "displayName": n => { retentionEvent.displayName = n.getStringValue(); },
        "eventPropagationResults": n => { retentionEvent.eventPropagationResults = n.getCollectionOfObjectValues<EventPropagationResult>(createEventPropagationResultFromDiscriminatorValue); },
        "eventQueries": n => { retentionEvent.eventQueries = n.getCollectionOfObjectValues<EventQuery>(createEventQueryFromDiscriminatorValue); },
        "eventStatus": n => { retentionEvent.eventStatus = n.getObjectValue<RetentionEventStatus>(createRetentionEventStatusFromDiscriminatorValue); },
        "eventTriggerDateTime": n => { retentionEvent.eventTriggerDateTime = n.getDateValue(); },
        "lastModifiedBy": n => { retentionEvent.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { retentionEvent.lastModifiedDateTime = n.getDateValue(); },
        "lastStatusUpdateDateTime": n => { retentionEvent.lastStatusUpdateDateTime = n.getDateValue(); },
        "retentionEventType": n => { retentionEvent.retentionEventType = n.getObjectValue<RetentionEventType>(createRetentionEventTypeFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRetentionEventCollectionResponse(retentionEventCollectionResponse: Partial<RetentionEventCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(retentionEventCollectionResponse),
        "value": n => { retentionEventCollectionResponse.value = n.getCollectionOfObjectValues<RetentionEvent>(createRetentionEventFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRetentionEventStatus(retentionEventStatus: Partial<RetentionEventStatus> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { retentionEventStatus.backingStoreEnabled = true; },
        "error": n => { retentionEventStatus.errorEscaped = n.getObjectValue<PublicError>(createPublicErrorFromDiscriminatorValue); },
        "@odata.type": n => { retentionEventStatus.odataType = n.getStringValue(); },
        "status": n => { retentionEventStatus.status = n.getEnumValue<EventStatusType>(EventStatusTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRetentionEventType(retentionEventType: Partial<RetentionEventType> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(retentionEventType),
        "createdBy": n => { retentionEventType.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { retentionEventType.createdDateTime = n.getDateValue(); },
        "description": n => { retentionEventType.description = n.getStringValue(); },
        "displayName": n => { retentionEventType.displayName = n.getStringValue(); },
        "lastModifiedBy": n => { retentionEventType.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { retentionEventType.lastModifiedDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRetentionEventTypeCollectionResponse(retentionEventTypeCollectionResponse: Partial<RetentionEventTypeCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(retentionEventTypeCollectionResponse),
        "value": n => { retentionEventTypeCollectionResponse.value = n.getCollectionOfObjectValues<RetentionEventType>(createRetentionEventTypeFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSasTokenEvidence(sasTokenEvidence: Partial<SasTokenEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(sasTokenEvidence),
        "allowedIpAddresses": n => { sasTokenEvidence.allowedIpAddresses = n.getStringValue(); },
        "allowedResourceTypes": n => { sasTokenEvidence.allowedResourceTypes = n.getCollectionOfPrimitiveValues<string>(); },
        "allowedServices": n => { sasTokenEvidence.allowedServices = n.getCollectionOfPrimitiveValues<string>(); },
        "expiryDateTime": n => { sasTokenEvidence.expiryDateTime = n.getDateValue(); },
        "permissions": n => { sasTokenEvidence.permissions = n.getCollectionOfPrimitiveValues<string>(); },
        "protocol": n => { sasTokenEvidence.protocol = n.getStringValue(); },
        "signatureHash": n => { sasTokenEvidence.signatureHash = n.getStringValue(); },
        "signedWith": n => { sasTokenEvidence.signedWith = n.getStringValue(); },
        "startDateTime": n => { sasTokenEvidence.startDateTime = n.getDateValue(); },
        "storageResource": n => { sasTokenEvidence.storageResource = n.getObjectValue<AzureResourceEvidence>(createAzureResourceEvidenceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSearch(search: Partial<Search> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(search),
        "contentQuery": n => { search.contentQuery = n.getStringValue(); },
        "createdBy": n => { search.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "createdDateTime": n => { search.createdDateTime = n.getDateValue(); },
        "description": n => { search.description = n.getStringValue(); },
        "displayName": n => { search.displayName = n.getStringValue(); },
        "lastModifiedBy": n => { search.lastModifiedBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { search.lastModifiedDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSecurityGroupEvidence(securityGroupEvidence: Partial<SecurityGroupEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(securityGroupEvidence),
        "displayName": n => { securityGroupEvidence.displayName = n.getStringValue(); },
        "securityGroupId": n => { securityGroupEvidence.securityGroupId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoServicePrincipalEvidence(servicePrincipalEvidence: Partial<ServicePrincipalEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(servicePrincipalEvidence),
        "appId": n => { servicePrincipalEvidence.appId = n.getStringValue(); },
        "appOwnerTenantId": n => { servicePrincipalEvidence.appOwnerTenantId = n.getStringValue(); },
        "servicePrincipalName": n => { servicePrincipalEvidence.servicePrincipalName = n.getStringValue(); },
        "servicePrincipalObjectId": n => { servicePrincipalEvidence.servicePrincipalObjectId = n.getStringValue(); },
        "servicePrincipalType": n => { servicePrincipalEvidence.servicePrincipalType = n.getEnumValue<ServicePrincipalType>(ServicePrincipalTypeObject); },
        "tenantId": n => { servicePrincipalEvidence.tenantId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSinglePropertySchema(singlePropertySchema: Partial<SinglePropertySchema> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { singlePropertySchema.backingStoreEnabled = true; },
        "name": n => { singlePropertySchema.name = n.getStringValue(); },
        "@odata.type": n => { singlePropertySchema.odataType = n.getStringValue(); },
        "type": n => { singlePropertySchema.type = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSiteSource(siteSource: Partial<SiteSource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSource(siteSource),
        "site": n => { siteSource.site = n.getObjectValue<Site>(createSiteFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSiteSourceCollectionResponse(siteSourceCollectionResponse: Partial<SiteSourceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(siteSourceCollectionResponse),
        "value": n => { siteSourceCollectionResponse.value = n.getCollectionOfObjectValues<SiteSource>(createSiteSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSslCertificate(sslCertificate: Partial<SslCertificate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(sslCertificate),
        "expirationDateTime": n => { sslCertificate.expirationDateTime = n.getDateValue(); },
        "fingerprint": n => { sslCertificate.fingerprint = n.getStringValue(); },
        "firstSeenDateTime": n => { sslCertificate.firstSeenDateTime = n.getDateValue(); },
        "issueDateTime": n => { sslCertificate.issueDateTime = n.getDateValue(); },
        "issuer": n => { sslCertificate.issuer = n.getObjectValue<SslCertificateEntity>(createSslCertificateEntityFromDiscriminatorValue); },
        "lastSeenDateTime": n => { sslCertificate.lastSeenDateTime = n.getDateValue(); },
        "relatedHosts": n => { sslCertificate.relatedHosts = n.getCollectionOfObjectValues<Host>(createHostFromDiscriminatorValue); },
        "serialNumber": n => { sslCertificate.serialNumber = n.getStringValue(); },
        "sha1": n => { sslCertificate.sha1 = n.getStringValue(); },
        "subject": n => { sslCertificate.subject = n.getObjectValue<SslCertificateEntity>(createSslCertificateEntityFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSslCertificateCollectionResponse(sslCertificateCollectionResponse: Partial<SslCertificateCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(sslCertificateCollectionResponse),
        "value": n => { sslCertificateCollectionResponse.value = n.getCollectionOfObjectValues<SslCertificate>(createSslCertificateFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSslCertificateEntity(sslCertificateEntity: Partial<SslCertificateEntity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "address": n => { sslCertificateEntity.address = n.getObjectValue<PhysicalAddress>(createPhysicalAddressFromDiscriminatorValue); },
        "alternateNames": n => { sslCertificateEntity.alternateNames = n.getCollectionOfPrimitiveValues<string>(); },
        "backingStoreEnabled": n => { sslCertificateEntity.backingStoreEnabled = true; },
        "commonName": n => { sslCertificateEntity.commonName = n.getStringValue(); },
        "email": n => { sslCertificateEntity.email = n.getStringValue(); },
        "givenName": n => { sslCertificateEntity.givenName = n.getStringValue(); },
        "@odata.type": n => { sslCertificateEntity.odataType = n.getStringValue(); },
        "organizationName": n => { sslCertificateEntity.organizationName = n.getStringValue(); },
        "organizationUnitName": n => { sslCertificateEntity.organizationUnitName = n.getStringValue(); },
        "serialNumber": n => { sslCertificateEntity.serialNumber = n.getStringValue(); },
        "surname": n => { sslCertificateEntity.surname = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSubdomain(subdomain: Partial<Subdomain> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(subdomain),
        "firstSeenDateTime": n => { subdomain.firstSeenDateTime = n.getDateValue(); },
        "host": n => { subdomain.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSubdomainCollectionResponse(subdomainCollectionResponse: Partial<SubdomainCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(subdomainCollectionResponse),
        "value": n => { subdomainCollectionResponse.value = n.getCollectionOfObjectValues<Subdomain>(createSubdomainFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSubmissionMailEvidence(submissionMailEvidence: Partial<SubmissionMailEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(submissionMailEvidence),
        "networkMessageId": n => { submissionMailEvidence.networkMessageId = n.getStringValue(); },
        "recipient": n => { submissionMailEvidence.recipient = n.getStringValue(); },
        "reportType": n => { submissionMailEvidence.reportType = n.getStringValue(); },
        "sender": n => { submissionMailEvidence.sender = n.getStringValue(); },
        "senderIp": n => { submissionMailEvidence.senderIp = n.getStringValue(); },
        "subject": n => { submissionMailEvidence.subject = n.getStringValue(); },
        "submissionDateTime": n => { submissionMailEvidence.submissionDateTime = n.getDateValue(); },
        "submissionId": n => { submissionMailEvidence.submissionId = n.getStringValue(); },
        "submitter": n => { submissionMailEvidence.submitter = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTag(tag: Partial<Tag> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(tag),
        "createdBy": n => { tag.createdBy = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "description": n => { tag.description = n.getStringValue(); },
        "displayName": n => { tag.displayName = n.getStringValue(); },
        "lastModifiedDateTime": n => { tag.lastModifiedDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoThreatIntelligence(threatIntelligence: Partial<ThreatIntelligence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(threatIntelligence),
        "articleIndicators": n => { threatIntelligence.articleIndicators = n.getCollectionOfObjectValues<ArticleIndicator>(createArticleIndicatorFromDiscriminatorValue); },
        "articles": n => { threatIntelligence.articles = n.getCollectionOfObjectValues<Article>(createArticleFromDiscriminatorValue); },
        "hostComponents": n => { threatIntelligence.hostComponents = n.getCollectionOfObjectValues<HostComponent>(createHostComponentFromDiscriminatorValue); },
        "hostCookies": n => { threatIntelligence.hostCookies = n.getCollectionOfObjectValues<HostCookie>(createHostCookieFromDiscriminatorValue); },
        "hostPairs": n => { threatIntelligence.hostPairs = n.getCollectionOfObjectValues<HostPair>(createHostPairFromDiscriminatorValue); },
        "hostPorts": n => { threatIntelligence.hostPorts = n.getCollectionOfObjectValues<HostPort>(createHostPortFromDiscriminatorValue); },
        "hosts": n => { threatIntelligence.hosts = n.getCollectionOfObjectValues<Host>(createHostFromDiscriminatorValue); },
        "hostSslCertificates": n => { threatIntelligence.hostSslCertificates = n.getCollectionOfObjectValues<HostSslCertificate>(createHostSslCertificateFromDiscriminatorValue); },
        "hostTrackers": n => { threatIntelligence.hostTrackers = n.getCollectionOfObjectValues<HostTracker>(createHostTrackerFromDiscriminatorValue); },
        "intelligenceProfileIndicators": n => { threatIntelligence.intelligenceProfileIndicators = n.getCollectionOfObjectValues<IntelligenceProfileIndicator>(createIntelligenceProfileIndicatorFromDiscriminatorValue); },
        "intelProfiles": n => { threatIntelligence.intelProfiles = n.getCollectionOfObjectValues<IntelligenceProfile>(createIntelligenceProfileFromDiscriminatorValue); },
        "passiveDnsRecords": n => { threatIntelligence.passiveDnsRecords = n.getCollectionOfObjectValues<PassiveDnsRecord>(createPassiveDnsRecordFromDiscriminatorValue); },
        "sslCertificates": n => { threatIntelligence.sslCertificates = n.getCollectionOfObjectValues<SslCertificate>(createSslCertificateFromDiscriminatorValue); },
        "subdomains": n => { threatIntelligence.subdomains = n.getCollectionOfObjectValues<Subdomain>(createSubdomainFromDiscriminatorValue); },
        "vulnerabilities": n => { threatIntelligence.vulnerabilities = n.getCollectionOfObjectValues<Vulnerability>(createVulnerabilityFromDiscriminatorValue); },
        "whoisHistoryRecords": n => { threatIntelligence.whoisHistoryRecords = n.getCollectionOfObjectValues<WhoisHistoryRecord>(createWhoisHistoryRecordFromDiscriminatorValue); },
        "whoisRecords": n => { threatIntelligence.whoisRecords = n.getCollectionOfObjectValues<WhoisRecord>(createWhoisRecordFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTopicModelingSettings(topicModelingSettings: Partial<TopicModelingSettings> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { topicModelingSettings.backingStoreEnabled = true; },
        "dynamicallyAdjustTopicCount": n => { topicModelingSettings.dynamicallyAdjustTopicCount = n.getBooleanValue(); },
        "ignoreNumbers": n => { topicModelingSettings.ignoreNumbers = n.getBooleanValue(); },
        "isEnabled": n => { topicModelingSettings.isEnabled = n.getBooleanValue(); },
        "@odata.type": n => { topicModelingSettings.odataType = n.getStringValue(); },
        "topicCount": n => { topicModelingSettings.topicCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTriggersRoot(triggersRoot: Partial<TriggersRoot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(triggersRoot),
        "retentionEvents": n => { triggersRoot.retentionEvents = n.getCollectionOfObjectValues<RetentionEvent>(createRetentionEventFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTriggerTypesRoot(triggerTypesRoot: Partial<TriggerTypesRoot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(triggerTypesRoot),
        "retentionEventTypes": n => { triggerTypesRoot.retentionEventTypes = n.getCollectionOfObjectValues<RetentionEventType>(createRetentionEventTypeFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUnclassifiedArtifact(unclassifiedArtifact: Partial<UnclassifiedArtifact> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoArtifact(unclassifiedArtifact),
        "kind": n => { unclassifiedArtifact.kind = n.getStringValue(); },
        "value": n => { unclassifiedArtifact.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUnifiedGroupSource(unifiedGroupSource: Partial<UnifiedGroupSource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSource(unifiedGroupSource),
        "group": n => { unifiedGroupSource.group = n.getObjectValue<Group>(createGroupFromDiscriminatorValue); },
        "includedSources": n => { unifiedGroupSource.includedSources = n.getCollectionOfEnumValues<SourceType>(SourceTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUnifiedGroupSourceCollectionResponse(unifiedGroupSourceCollectionResponse: Partial<UnifiedGroupSourceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(unifiedGroupSourceCollectionResponse),
        "value": n => { unifiedGroupSourceCollectionResponse.value = n.getCollectionOfObjectValues<UnifiedGroupSource>(createUnifiedGroupSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUrlEvidence(urlEvidence: Partial<UrlEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(urlEvidence),
        "url": n => { urlEvidence.url = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUserAccount(userAccount: Partial<UserAccount> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "accountName": n => { userAccount.accountName = n.getStringValue(); },
        "azureAdUserId": n => { userAccount.azureAdUserId = n.getStringValue(); },
        "backingStoreEnabled": n => { userAccount.backingStoreEnabled = true; },
        "displayName": n => { userAccount.displayName = n.getStringValue(); },
        "domainName": n => { userAccount.domainName = n.getStringValue(); },
        "@odata.type": n => { userAccount.odataType = n.getStringValue(); },
        "userPrincipalName": n => { userAccount.userPrincipalName = n.getStringValue(); },
        "userSid": n => { userAccount.userSid = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUserEvidence(userEvidence: Partial<UserEvidence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAlertEvidence(userEvidence),
        "userAccount": n => { userEvidence.userAccount = n.getObjectValue<UserAccount>(createUserAccountFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUserSource(userSource: Partial<UserSource> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDataSource(userSource),
        "email": n => { userSource.email = n.getStringValue(); },
        "includedSources": n => { userSource.includedSources = n.getCollectionOfEnumValues<SourceType>(SourceTypeObject); },
        "siteWebUrl": n => { userSource.siteWebUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUserSourceCollectionResponse(userSourceCollectionResponse: Partial<UserSourceCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(userSourceCollectionResponse),
        "value": n => { userSourceCollectionResponse.value = n.getCollectionOfObjectValues<UserSource>(createUserSourceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoVmMetadata(vmMetadata: Partial<VmMetadata> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { vmMetadata.backingStoreEnabled = true; },
        "cloudProvider": n => { vmMetadata.cloudProvider = n.getEnumValue<VmCloudProvider>(VmCloudProviderObject); },
        "@odata.type": n => { vmMetadata.odataType = n.getStringValue(); },
        "resourceId": n => { vmMetadata.resourceId = n.getStringValue(); },
        "subscriptionId": n => { vmMetadata.subscriptionId = n.getStringValue(); },
        "vmId": n => { vmMetadata.vmId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoVulnerability(vulnerability: Partial<Vulnerability> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(vulnerability),
        "activeExploitsObserved": n => { vulnerability.activeExploitsObserved = n.getBooleanValue(); },
        "articles": n => { vulnerability.articles = n.getCollectionOfObjectValues<Article>(createArticleFromDiscriminatorValue); },
        "commonWeaknessEnumerationIds": n => { vulnerability.commonWeaknessEnumerationIds = n.getCollectionOfPrimitiveValues<string>(); },
        "components": n => { vulnerability.components = n.getCollectionOfObjectValues<VulnerabilityComponent>(createVulnerabilityComponentFromDiscriminatorValue); },
        "createdDateTime": n => { vulnerability.createdDateTime = n.getDateValue(); },
        "cvss2Summary": n => { vulnerability.cvss2Summary = n.getObjectValue<CvssSummary>(createCvssSummaryFromDiscriminatorValue); },
        "cvss3Summary": n => { vulnerability.cvss3Summary = n.getObjectValue<CvssSummary>(createCvssSummaryFromDiscriminatorValue); },
        "description": n => { vulnerability.description = n.getObjectValue<FormattedContent>(createFormattedContentFromDiscriminatorValue); },
        "exploits": n => { vulnerability.exploits = n.getCollectionOfObjectValues<Hyperlink>(createHyperlinkFromDiscriminatorValue); },
        "exploitsAvailable": n => { vulnerability.exploitsAvailable = n.getBooleanValue(); },
        "hasChatter": n => { vulnerability.hasChatter = n.getBooleanValue(); },
        "lastModifiedDateTime": n => { vulnerability.lastModifiedDateTime = n.getDateValue(); },
        "priorityScore": n => { vulnerability.priorityScore = n.getNumberValue(); },
        "publishedDateTime": n => { vulnerability.publishedDateTime = n.getDateValue(); },
        "references": n => { vulnerability.references = n.getCollectionOfObjectValues<Hyperlink>(createHyperlinkFromDiscriminatorValue); },
        "remediation": n => { vulnerability.remediation = n.getObjectValue<FormattedContent>(createFormattedContentFromDiscriminatorValue); },
        "severity": n => { vulnerability.severity = n.getEnumValue<VulnerabilitySeverity>(VulnerabilitySeverityObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoVulnerabilityCollectionResponse(vulnerabilityCollectionResponse: Partial<VulnerabilityCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(vulnerabilityCollectionResponse),
        "value": n => { vulnerabilityCollectionResponse.value = n.getCollectionOfObjectValues<Vulnerability>(createVulnerabilityFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoVulnerabilityComponent(vulnerabilityComponent: Partial<VulnerabilityComponent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(vulnerabilityComponent),
        "name": n => { vulnerabilityComponent.name = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoVulnerabilityComponentCollectionResponse(vulnerabilityComponentCollectionResponse: Partial<VulnerabilityComponentCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(vulnerabilityComponentCollectionResponse),
        "value": n => { vulnerabilityComponentCollectionResponse.value = n.getCollectionOfObjectValues<VulnerabilityComponent>(createVulnerabilityComponentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoWhoisBaseRecord(whoisBaseRecord: Partial<WhoisBaseRecord> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(whoisBaseRecord),
        "abuse": n => { whoisBaseRecord.abuse = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
        "admin": n => { whoisBaseRecord.admin = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
        "billing": n => { whoisBaseRecord.billing = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
        "domainStatus": n => { whoisBaseRecord.domainStatus = n.getStringValue(); },
        "expirationDateTime": n => { whoisBaseRecord.expirationDateTime = n.getDateValue(); },
        "firstSeenDateTime": n => { whoisBaseRecord.firstSeenDateTime = n.getDateValue(); },
        "host": n => { whoisBaseRecord.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "lastSeenDateTime": n => { whoisBaseRecord.lastSeenDateTime = n.getDateValue(); },
        "lastUpdateDateTime": n => { whoisBaseRecord.lastUpdateDateTime = n.getDateValue(); },
        "nameservers": n => { whoisBaseRecord.nameservers = n.getCollectionOfObjectValues<WhoisNameserver>(createWhoisNameserverFromDiscriminatorValue); },
        "noc": n => { whoisBaseRecord.noc = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
        "rawWhoisText": n => { whoisBaseRecord.rawWhoisText = n.getStringValue(); },
        "registrant": n => { whoisBaseRecord.registrant = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
        "registrar": n => { whoisBaseRecord.registrar = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
        "registrationDateTime": n => { whoisBaseRecord.registrationDateTime = n.getDateValue(); },
        "technical": n => { whoisBaseRecord.technical = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
        "whoisServer": n => { whoisBaseRecord.whoisServer = n.getStringValue(); },
        "zone": n => { whoisBaseRecord.zone = n.getObjectValue<WhoisContact>(createWhoisContactFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoWhoisContact(whoisContact: Partial<WhoisContact> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "address": n => { whoisContact.address = n.getObjectValue<PhysicalAddress>(createPhysicalAddressFromDiscriminatorValue); },
        "backingStoreEnabled": n => { whoisContact.backingStoreEnabled = true; },
        "email": n => { whoisContact.email = n.getStringValue(); },
        "fax": n => { whoisContact.fax = n.getStringValue(); },
        "name": n => { whoisContact.name = n.getStringValue(); },
        "@odata.type": n => { whoisContact.odataType = n.getStringValue(); },
        "organization": n => { whoisContact.organization = n.getStringValue(); },
        "telephone": n => { whoisContact.telephone = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoWhoisHistoryRecord(whoisHistoryRecord: Partial<WhoisHistoryRecord> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWhoisBaseRecord(whoisHistoryRecord),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoWhoisHistoryRecordCollectionResponse(whoisHistoryRecordCollectionResponse: Partial<WhoisHistoryRecordCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(whoisHistoryRecordCollectionResponse),
        "value": n => { whoisHistoryRecordCollectionResponse.value = n.getCollectionOfObjectValues<WhoisHistoryRecord>(createWhoisHistoryRecordFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoWhoisNameserver(whoisNameserver: Partial<WhoisNameserver> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { whoisNameserver.backingStoreEnabled = true; },
        "firstSeenDateTime": n => { whoisNameserver.firstSeenDateTime = n.getDateValue(); },
        "host": n => { whoisNameserver.host = n.getObjectValue<Host>(createHostFromDiscriminatorValue); },
        "lastSeenDateTime": n => { whoisNameserver.lastSeenDateTime = n.getDateValue(); },
        "@odata.type": n => { whoisNameserver.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoWhoisRecord(whoisRecord: Partial<WhoisRecord> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoWhoisBaseRecord(whoisRecord),
        "history": n => { whoisRecord.history = n.getCollectionOfObjectValues<WhoisHistoryRecord>(createWhoisHistoryRecordFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoWhoisRecordCollectionResponse(whoisRecordCollectionResponse: Partial<WhoisRecordCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(whoisRecordCollectionResponse),
        "value": n => { whoisRecordCollectionResponse.value = n.getCollectionOfObjectValues<WhoisRecord>(createWhoisRecordFromDiscriminatorValue); },
    }
}
export type DetectionSource = (typeof DetectionSourceObject)[keyof typeof DetectionSourceObject];
export type DetectionStatus = (typeof DetectionStatusObject)[keyof typeof DetectionStatusObject];
export interface DeviceEvidence extends AlertEvidence, Parsable {
    /**
     * A unique identifier assigned to a device by Microsoft Entra ID when device is Microsoft Entra joined.
     */
    azureAdDeviceId?: string;
    /**
     * State of the Defender AntiMalware engine. The possible values are: notReporting, disabled, notUpdated, updated, unknown, notSupported, unknownFutureValue.
     */
    defenderAvStatus?: DefenderAvStatus;
    /**
     * The fully qualified domain name (FQDN) for the device.
     */
    deviceDnsName?: string;
    /**
     * The date and time when the device was first seen.
     */
    firstSeenDateTime?: Date;
    /**
     * The health state of the device. The possible values are: active, inactive, impairedCommunication, noSensorData, noSensorDataImpairedCommunication, unknown, unknownFutureValue.
     */
    healthStatus?: DeviceHealthStatus;
    /**
     * Ip interfaces of the device during the time of the alert.
     */
    ipInterfaces?: string[];
    /**
     * Users that were logged on the machine during the time of the alert.
     */
    loggedOnUsers?: LoggedOnUser[];
    /**
     * A unique identifier assigned to a device by Microsoft Defender for Endpoint.
     */
    mdeDeviceId?: string;
    /**
     * The status of the machine onboarding to Microsoft Defender for Endpoint. The possible values are: insufficientInfo, onboarded, canBeOnboarded, unsupported, unknownFutureValue.
     */
    onboardingStatus?: OnboardingStatus;
    /**
     * The build version for the operating system the device is running.
     */
    osBuild?: number;
    /**
     * The operating system platform the device is running.
     */
    osPlatform?: string;
    /**
     * The ID of the role-based access control (RBAC) device group.
     */
    rbacGroupId?: number;
    /**
     * The name of the RBAC device group.
     */
    rbacGroupName?: string;
    /**
     * Risk score as evaluated by Microsoft Defender for Endpoint. The possible values are: none, informational, low, medium, high, unknownFutureValue.
     */
    riskScore?: DeviceRiskScore;
    /**
     * The version of the operating system platform.
     */
    version?: string;
    /**
     * Metadata of the virtual machine (VM) on which Microsoft Defender for Endpoint is running.
     */
    vmMetadata?: VmMetadata;
}
export type DeviceHealthStatus = (typeof DeviceHealthStatusObject)[keyof typeof DeviceHealthStatusObject];
export type DeviceRiskScore = (typeof DeviceRiskScoreObject)[keyof typeof DeviceRiskScoreObject];
export interface Dictionary extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface DnsEvidence extends AlertEvidence, Parsable {
    /**
     * The dnsServerIp property
     */
    dnsServerIp?: IpEvidence;
    /**
     * The domainName property
     */
    domainName?: string;
    /**
     * The hostIpAddress property
     */
    hostIpAddress?: IpEvidence;
    /**
     * The ipAddresses property
     */
    ipAddresses?: IpEvidence[];
}
export interface EdiscoveryAddToReviewSetOperation extends CaseOperation, Parsable {
    /**
     * eDiscovery review set to which items matching source collection query gets added.
     */
    reviewSet?: EdiscoveryReviewSet;
    /**
     * eDiscovery search that gets added to review set.
     */
    search?: EdiscoverySearch;
}
export interface EdiscoveryCase extends CaseEscaped, Parsable {
    /**
     * The user who closed the case.
     */
    closedBy?: IdentitySet;
    /**
     * The date and time when the case was closed. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    closedDateTime?: Date;
    /**
     * Returns a list of case ediscoveryCustodian objects for this case.
     */
    custodians?: EdiscoveryCustodian[];
    /**
     * The external case number for customer reference.
     */
    externalId?: string;
    /**
     * Returns a list of case ediscoveryNoncustodialDataSource objects for this case.
     */
    noncustodialDataSources?: EdiscoveryNoncustodialDataSource[];
    /**
     * Returns a list of case caseOperation objects for this case.
     */
    operations?: CaseOperation[];
    /**
     * Returns a list of eDiscoveryReviewSet objects in the case.
     */
    reviewSets?: EdiscoveryReviewSet[];
    /**
     * Returns a list of eDiscoverySearch objects associated with this case.
     */
    searches?: EdiscoverySearch[];
    /**
     * Returns a list of eDIscoverySettings objects in the case.
     */
    settings?: EdiscoveryCaseSettings;
    /**
     * Returns a list of ediscoveryReviewTag objects associated to this case.
     */
    tags?: EdiscoveryReviewTag[];
}
export interface EdiscoveryCaseCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoveryCase[];
}
export interface EdiscoveryCaseSettings extends Entity, Parsable {
    /**
     * The OCR (Optical Character Recognition) settings for the case.
     */
    ocr?: OcrSettings;
    /**
     * The redundancy (near duplicate and email threading) detection settings for the case.
     */
    redundancyDetection?: RedundancyDetectionSettings;
    /**
     * The Topic Modeling (Themes) settings for the case.
     */
    topicModeling?: TopicModelingSettings;
}
export interface EdiscoveryCustodian extends DataSourceContainer, Parsable {
    /**
     * Date and time the custodian acknowledged a hold notification.
     */
    acknowledgedDateTime?: Date;
    /**
     * Email address of the custodian.
     */
    email?: string;
    /**
     * Operation entity that represents the latest indexing for the custodian.
     */
    lastIndexOperation?: EdiscoveryIndexOperation;
    /**
     * Data source entity for SharePoint sites associated with the custodian.
     */
    siteSources?: SiteSource[];
    /**
     * Data source entity for groups associated with the custodian.
     */
    unifiedGroupSources?: UnifiedGroupSource[];
    /**
     * Data source entity for a the custodian. This is the container for a custodian's mailbox and OneDrive for Business site.
     */
    userSources?: UserSource[];
}
export interface EdiscoveryCustodianCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoveryCustodian[];
}
export interface EdiscoveryEstimateOperation extends CaseOperation, Parsable {
    /**
     * The estimated count of items for the search that matched the content query.
     */
    indexedItemCount?: number;
    /**
     * The estimated size of items for the search that matched the content query.
     */
    indexedItemsSize?: number;
    /**
     * The number of mailboxes that had search hits.
     */
    mailboxCount?: number;
    /**
     * eDiscovery search.
     */
    search?: EdiscoverySearch;
    /**
     * The number of mailboxes that had search hits.
     */
    siteCount?: number;
    /**
     * The estimated count of unindexed items for the collection.
     */
    unindexedItemCount?: number;
    /**
     * The estimated size of unindexed items for the collection.
     */
    unindexedItemsSize?: number;
}
export interface EdiscoveryExportOperation extends CaseOperation, Parsable {
    /**
     * The description provided for the export.
     */
    description?: string;
    /**
     * The exportFileMetadata property
     */
    exportFileMetadata?: ExportFileMetadata[];
    /**
     * The options provided for the export. For more information, see reviewSet: export. Possible values are: originalFiles, text, pdfReplacement,  tags.
     */
    exportOptions?: ExportOptions[];
    /**
     * The options that specify the structure of the export. For more information, see reviewSet: export. Possible values are: none, directory, pst.
     */
    exportStructure?: ExportFileStructure;
    /**
     * The name provided for the export.
     */
    outputName?: string;
    /**
     * Review set from where documents are exported.
     */
    reviewSet?: EdiscoveryReviewSet;
    /**
     * The review set query that is used to filter the documents for export.
     */
    reviewSetQuery?: EdiscoveryReviewSetQuery;
}
export interface EdiscoveryHoldOperation extends CaseOperation, Parsable {
}
export interface EdiscoveryIndexOperation extends CaseOperation, Parsable {
}
export interface EdiscoveryNoncustodialDataSource extends DataSourceContainer, Parsable {
    /**
     * User source or SharePoint site data source as noncustodial data source.
     */
    dataSource?: DataSource;
    /**
     * Operation entity that represents the latest indexing for the noncustodial data source.
     */
    lastIndexOperation?: EdiscoveryIndexOperation;
}
export interface EdiscoveryNoncustodialDataSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoveryNoncustodialDataSource[];
}
export interface EdiscoveryPurgeDataOperation extends CaseOperation, Parsable {
}
export interface EdiscoveryReviewSet extends DataSet, Parsable {
    /**
     * Represents queries within the review set.
     */
    queries?: EdiscoveryReviewSetQuery[];
}
export interface EdiscoveryReviewSetCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoveryReviewSet[];
}
export interface EdiscoveryReviewSetQuery extends Parsable, Search {
}
export interface EdiscoveryReviewSetQueryCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoveryReviewSetQuery[];
}
export interface EdiscoveryReviewTag extends Parsable, Tag {
    /**
     * Indicates whether a single or multiple child tags can be associated with a document. Possible values are: One, Many.  This value controls whether the UX presents the tags as checkboxes or a radio button group.
     */
    childSelectability?: ChildSelectability;
    /**
     * Returns the tags that are a child of a tag.
     */
    childTags?: EdiscoveryReviewTag[];
    /**
     * Returns the parent tag of the specified tag.
     */
    parent?: EdiscoveryReviewTag;
}
export interface EdiscoveryReviewTagCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoveryReviewTag[];
}
export interface EdiscoverySearch extends Parsable, Search {
    /**
     * Adds an additional source to the eDiscovery search.
     */
    additionalSources?: DataSource[];
    /**
     * Adds the results of the eDiscovery search to the specified reviewSet.
     */
    addToReviewSetOperation?: EdiscoveryAddToReviewSetOperation;
    /**
     * Custodian sources that are included in the eDiscovery search.
     */
    custodianSources?: DataSource[];
    /**
     * When specified, the collection will span across a service for an entire workload. Possible values are: none, allTenantMailboxes, allTenantSites, allCaseCustodians, allCaseNoncustodialDataSources.
     */
    dataSourceScopes?: DataSourceScopes[];
    /**
     * The last estimate operation associated with the eDiscovery search.
     */
    lastEstimateStatisticsOperation?: EdiscoveryEstimateOperation;
    /**
     * noncustodialDataSource sources that are included in the eDiscovery search
     */
    noncustodialSources?: EdiscoveryNoncustodialDataSource[];
}
export interface EdiscoverySearchCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: EdiscoverySearch[];
}
export interface EdiscoveryTagOperation extends CaseOperation, Parsable {
}
export interface EmailSender extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The name of the sender.
     */
    displayName?: string;
    /**
     * Sender domain.
     */
    domainName?: string;
    /**
     * Sender email address.
     */
    emailAddress?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface EventPropagationResult extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The name of the specific location in the workload associated with the event.
     */
    location?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The name of the workload associated with the event.
     */
    serviceName?: string;
    /**
     * Indicates the status of the event creation request. The possible values are: none, inProcessing, failed, success, unknownFutureValue.
     */
    status?: EventPropagationStatus;
    /**
     * Additional information about the status of the event creation request.
     */
    statusInformation?: string;
}
export type EventPropagationStatus = (typeof EventPropagationStatusObject)[keyof typeof EventPropagationStatusObject];
export interface EventQuery extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Represents unique identification for the  query. 'Asset ID' for SharePoint Online and OneDrive for Business, 'keywords' for Exchange Online.
     */
    query?: string;
    /**
     * Represents the type of query associated with an event. 'files' for SPO and ODB and 'messages' for EXO.The possible values are: files, messages, unknownFutureValue.
     */
    queryType?: QueryType;
}
export type EventStatusType = (typeof EventStatusTypeObject)[keyof typeof EventStatusTypeObject];
export type EvidenceRemediationStatus = (typeof EvidenceRemediationStatusObject)[keyof typeof EvidenceRemediationStatusObject];
export type EvidenceRole = (typeof EvidenceRoleObject)[keyof typeof EvidenceRoleObject];
export type EvidenceVerdict = (typeof EvidenceVerdictObject)[keyof typeof EvidenceVerdictObject];
export interface ExportFileMetadata extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The downloadUrl property
     */
    downloadUrl?: string;
    /**
     * The fileName property
     */
    fileName?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The size property
     */
    size?: number;
}
export type ExportFileStructure = (typeof ExportFileStructureObject)[keyof typeof ExportFileStructureObject];
export type ExportOptions = (typeof ExportOptionsObject)[keyof typeof ExportOptionsObject];
export interface FileDetails extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The name of the file.
     */
    fileName?: string;
    /**
     * The file path (location) of the file instance.
     */
    filePath?: string;
    /**
     * The publisher of the file.
     */
    filePublisher?: string;
    /**
     * The size of the file in bytes.
     */
    fileSize?: number;
    /**
     * The certificate authority (CA) that issued the certificate.
     */
    issuer?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The Sha1 cryptographic hash of the file content.
     */
    sha1?: string;
    /**
     * The Sha256 cryptographic hash of the file content.
     */
    sha256?: string;
    /**
     * The signer of the signed file.
     */
    signer?: string;
}
export interface FileEvidence extends AlertEvidence, Parsable {
    /**
     * The status of the detection.The possible values are: detected, blocked, prevented, unknownFutureValue.
     */
    detectionStatus?: DetectionStatus;
    /**
     * The file details.
     */
    fileDetails?: FileDetails;
    /**
     * A unique identifier assigned to a device by Microsoft Defender for Endpoint.
     */
    mdeDeviceId?: string;
}
export interface FileHash extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The algorithm property
     */
    algorithm?: FileHashAlgorithm;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The hash value.
     */
    value?: string;
}
export type FileHashAlgorithm = (typeof FileHashAlgorithmObject)[keyof typeof FileHashAlgorithmObject];
export interface FileHashEvidence extends AlertEvidence, Parsable {
    /**
     * The algorithm property
     */
    algorithm?: FileHashAlgorithm;
    /**
     * The value property
     */
    value?: string;
}
export interface FormattedContent extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The content of this formattedContent.
     */
    content?: string;
    /**
     * The format of the content. The possible values are: text, html, markdown, unknownFutureValue.
     */
    format?: ContentFormat;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface GitHubOrganizationEvidence extends AlertEvidence, Parsable {
    /**
     * The company property
     */
    company?: string;
    /**
     * The displayName property
     */
    displayName?: string;
    /**
     * The email property
     */
    email?: string;
    /**
     * The login property
     */
    login?: string;
    /**
     * The orgId property
     */
    orgId?: string;
    /**
     * The webUrl property
     */
    webUrl?: string;
}
export interface GitHubRepoEvidence extends AlertEvidence, Parsable {
    /**
     * The baseUrl property
     */
    baseUrl?: string;
    /**
     * The login property
     */
    login?: string;
    /**
     * The owner property
     */
    owner?: string;
    /**
     * The ownerType property
     */
    ownerType?: string;
    /**
     * The repoId property
     */
    repoId?: string;
}
export interface GitHubUserEvidence extends AlertEvidence, Parsable {
    /**
     * The email property
     */
    email?: string;
    /**
     * The login property
     */
    login?: string;
    /**
     * The name property
     */
    name?: string;
    /**
     * The userId property
     */
    userId?: string;
    /**
     * The webUrl property
     */
    webUrl?: string;
}
export type GoogleCloudLocationType = (typeof GoogleCloudLocationTypeObject)[keyof typeof GoogleCloudLocationTypeObject];
export interface GoogleCloudResourceEvidence extends AlertEvidence, Parsable {
    /**
     * The zone or region where the resource is located.
     */
    location?: string;
    /**
     * The type of location. Possible values are: unknown, regional, zonal, global, unknownFutureValue.
     */
    locationType?: GoogleCloudLocationType;
    /**
     * The Google project ID as defined by the user.
     */
    projectId?: string;
    /**
     * The project number assigned by Google.
     */
    projectNumber?: number;
    /**
     * The name of the resource.
     */
    resourceName?: string;
    /**
     * The type of the resource.
     */
    resourceType?: string;
}
export interface Host extends Artifact, Parsable {
    /**
     * The hostPairs that are resources associated with a host, where that host is the parentHost and has an outgoing pairing to a childHost.
     */
    childHostPairs?: HostPair[];
    /**
     * The hostComponents that are associated with this host.
     */
    components?: HostComponent[];
    /**
     * The hostCookies that are associated with this host.
     */
    cookies?: HostCookie[];
    /**
     * The first date and time when this host was observed. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The hostPairs that are associated with this host, where this host is either the parentHost or childHost.
     */
    hostPairs?: HostPair[];
    /**
     * The most recent date and time when this host was observed. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The hostPairs that are associated with a host, where that host is the childHost and has an incoming pairing with a parentHost.
     */
    parentHostPairs?: HostPair[];
    /**
     * Passive DNS retrieval about this host.
     */
    passiveDns?: PassiveDnsRecord[];
    /**
     * Reverse passive DNS retrieval about this host.
     */
    passiveDnsReverse?: PassiveDnsRecord[];
    /**
     * The hostPorts associated with a host.
     */
    ports?: HostPort[];
    /**
     * Represents a calculated reputation of this host.
     */
    reputation?: HostReputation;
    /**
     * The hostSslCertificates that are associated with this host.
     */
    sslCertificates?: HostSslCertificate[];
    /**
     * The subdomains that are associated with this host.
     */
    subdomains?: Subdomain[];
    /**
     * The hostTrackers that are associated with this host.
     */
    trackers?: HostTracker[];
    /**
     * The most recent whoisRecord for this host.
     */
    whois?: WhoisRecord;
}
export interface HostCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Host[];
}
export interface HostComponent extends Artifact, Parsable {
    /**
     * The type of component that was detected (for example, Operating System, Framework, Remote Access, or Server).
     */
    category?: string;
    /**
     * The first date and time when Microsoft Defender Threat Intelligence observed this web component. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host property
     */
    host?: Host;
    /**
     * The most recent date and time when Microsoft Defender Threat Intelligence observed this web component. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * A name running on the artifact, for example, Microsoft IIS.
     */
    name?: string;
    /**
     * The component version running on the artifact, for example, v8.5. This shouldn't be assumed to be strictly numerical.
     */
    version?: string;
}
export interface HostComponentCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: HostComponent[];
}
export interface HostCookie extends Artifact, Parsable {
    /**
     * The URI for which the cookie is valid.
     */
    domain?: string;
    /**
     * The first date and time when this hostCookie was observed by Microsoft Defender Threat Intelligence. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host property
     */
    host?: Host;
    /**
     * The most recent date and time when this hostCookie was observed by Microsoft Defender Threat Intelligence. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The name of the cookie, for example, JSESSIONID or SEARCH_NAMESITE.
     */
    name?: string;
}
export interface HostCookieCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: HostCookie[];
}
export interface HostLogonSessionEvidence extends AlertEvidence, Parsable {
    /**
     * The account property
     */
    account?: UserEvidence;
    /**
     * The endUtcDateTime property
     */
    endUtcDateTime?: Date;
    /**
     * The host property
     */
    host?: DeviceEvidence;
    /**
     * The sessionId property
     */
    sessionId?: string;
    /**
     * The startUtcDateTime property
     */
    startUtcDateTime?: Date;
}
export interface Hostname extends Host, Parsable {
    /**
     * The company or individual who registered this hostname, from WHOIS data.
     */
    registrant?: string;
    /**
     * The registrar for this hostname, from WHOIS data.
     */
    registrar?: string;
}
export interface HostPair extends Entity, Parsable {
    /**
     * The childHost property
     */
    childHost?: Host;
    /**
     * The date and time when Microsoft Defender Threat Intelligence first observed the hostPair. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The date and time when Microsoft Defender Threat Intelligence last observed the hostPair. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The reason that two hosts are identified as hostPair.
     */
    linkKind?: string;
    /**
     * The parentHost property
     */
    parentHost?: Host;
}
export interface HostPairCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: HostPair[];
}
export interface HostPort extends Entity, Parsable {
    /**
     * The hostPortBanners retrieved from scanning the port.
     */
    banners?: HostPortBanner[];
    /**
     * The first date and time when Microsoft Defender Threat Intelligence observed the hostPort. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host property
     */
    host?: Host;
    /**
     * The last date and time when Microsoft Defender Threat Intelligence scanned the hostPort. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    lastScanDateTime?: Date;
    /**
     * The last date and time when Microsoft Defender Threat Intelligence observed the hostPort. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The most recent sslCertificate used to communicate on the port.
     */
    mostRecentSslCertificate?: SslCertificate;
    /**
     * The numerical identifier of the port which is standardized across the internet.
     */
    port?: number;
    /**
     * The general protocol used to scan the port. The possible values are: tcp, udp, unknownFutureValue.
     */
    protocol?: HostPortProtocol;
    /**
     * The hostPortComponents retrieved from scanning the port.
     */
    services?: HostPortComponent[];
    /**
     * The status of the port. The possible values are: open, filtered, closed, unknownFutureValue.
     */
    status?: HostPortStatus;
    /**
     * The total amount of times that Microsoft Defender Threat Intelligence has observed the hostPort in all its scans.
     */
    timesObserved?: number;
}
export interface HostPortBanner extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The text response received from a web component when scanning a hostPort.
     */
    banner?: string;
    /**
     * The first date and time when Microsoft Defender Threat Intelligence observed the hostPortBanner. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The last date and time when Microsoft Defender Threat Intelligence observed the hostPortBanner. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The specific protocol used to scan the hostPort.
     */
    scanProtocol?: string;
    /**
     * The total amount of times that Microsoft Defender Threat Intelligence has observed the hostPortBanner in all its scans.
     */
    timesObserved?: number;
}
export interface HostPortCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: HostPort[];
}
export interface HostPortComponent extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The component property
     */
    component?: HostComponent;
    /**
     * The first date and time when Microsoft Defender Threat Intelligence observed the hostPortComponent. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * Indicates whether this hostPortComponent is recent, which is determined by whether the hostPortComponent was observed either at the same time or after the latest hostPortBanner in the scan history, or within two days of the latest scan of the hostPort when there are no hostPortBanners in the scan history.
     */
    isRecent?: boolean;
    /**
     * The last date and time when Microsoft Defender Threat Intelligence observed the hostPortComponent. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export type HostPortProtocol = (typeof HostPortProtocolObject)[keyof typeof HostPortProtocolObject];
export type HostPortStatus = (typeof HostPortStatusObject)[keyof typeof HostPortStatusObject];
export interface HostReputation extends Entity, Parsable {
    /**
     * The classification property
     */
    classification?: HostReputationClassification;
    /**
     * A collection of rules that have been used to calculate the classification and score.
     */
    rules?: HostReputationRule[];
    /**
     * The calculated score (0-100) of the requested host. A higher value indicates that this host is more likely to be suspicious or malicious.
     */
    score?: number;
}
export type HostReputationClassification = (typeof HostReputationClassificationObject)[keyof typeof HostReputationClassificationObject];
export interface HostReputationRule extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The description of the rule that gives more context.
     */
    description?: string;
    /**
     * The name of the rule.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Link to a web page with details related to this rule.
     */
    relatedDetailsUrl?: string;
    /**
     * The severity property
     */
    severity?: HostReputationRuleSeverity;
}
export type HostReputationRuleSeverity = (typeof HostReputationRuleSeverityObject)[keyof typeof HostReputationRuleSeverityObject];
export interface HostSslCertificate extends Artifact, Parsable {
    /**
     * The first date and time when this hostSslCertificate was observed. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host for this hostSslCertificate.
     */
    host?: Host;
    /**
     * The most recent date and time when this hostSslCertificate was observed. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The ports related with this hostSslCertificate.
     */
    ports?: HostSslCertificatePort[];
    /**
     * The sslCertificate for this hostSslCertificate.
     */
    sslCertificate?: SslCertificate;
}
export interface HostSslCertificateCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: HostSslCertificate[];
}
export interface HostSslCertificatePort extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The first date and time when this port was observed. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The most recent date and time when this port was observed. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The port number.
     */
    port?: number;
}
export interface HostTracker extends Artifact, Parsable {
    /**
     * The first date and time when this hostTracker was observed by Microsoft Defender Threat Intelligence. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host property
     */
    host?: Host;
    /**
     * The kind of hostTracker that was detected. For example, GoogleAnalyticsID or JarmHash.
     */
    kind?: string;
    /**
     * The most recent date and time when this hostTracker was observed by Microsoft Defender Threat Intelligence. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014, is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The identification value for the hostTracker.
     */
    value?: string;
}
export interface HostTrackerCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: HostTracker[];
}
export interface HuntingQueryResults extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The results of the hunting query.
     */
    results?: HuntingRowResult[];
    /**
     * The schema for the response.
     */
    schema?: SinglePropertySchema[];
}
export interface HuntingRowResult extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface Hyperlink extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The name for this hyperlink.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The URL for this hyperlink.
     */
    url?: string;
}
export interface Incident extends Entity, Parsable {
    /**
     * The list of related alerts. Supports $expand.
     */
    alerts?: Alert[];
    /**
     * Owner of the incident, or null if no owner is assigned. Free editable text.
     */
    assignedTo?: string;
    /**
     * The specification for the incident. Possible values are: unknown, falsePositive, truePositive, informationalExpectedActivity, unknownFutureValue.
     */
    classification?: AlertClassification;
    /**
     * Array of comments created by the Security Operations (SecOps) team when the incident is managed.
     */
    comments?: AlertComment[];
    /**
     * Time when the incident was first created.
     */
    createdDateTime?: Date;
    /**
     * Array of custom tags associated with an incident.
     */
    customTags?: string[];
    /**
     * A rich text string describing the incident
     */
    description?: string;
    /**
     * Specifies the determination of the incident. Possible values are: unknown, apt, malware, securityPersonnel, securityTesting, unwantedSoftware, other, multiStagedAttack, compromisedUser, phishing, maliciousUserActivity, clean, insufficientData, confirmedUserActivity, lineOfBusinessApplication, unknownFutureValue.
     */
    determination?: AlertDetermination;
    /**
     * The incident name.
     */
    displayName?: string;
    /**
     * The URL for the incident page in the Microsoft 365 Defender portal.
     */
    incidentWebUrl?: string;
    /**
     * The lastModifiedBy property
     */
    lastModifiedBy?: string;
    /**
     * Time when the incident was last updated.
     */
    lastUpdateDateTime?: Date;
    /**
     * Only populated in case an incident is grouped together with another incident, as part of the logic that processes incidents. In such a case, the status property is redirected.
     */
    redirectIncidentId?: string;
    /**
     * The severity property
     */
    severity?: AlertSeverity;
    /**
     * The status property
     */
    status?: IncidentStatus;
    /**
     * The system tags associated with the incident
     */
    systemTags?: string[];
    /**
     * The Microsoft Entra tenant in which the alert was created.
     */
    tenantId?: string;
}
export interface IncidentCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Incident[];
}
export type IncidentStatus = (typeof IncidentStatusObject)[keyof typeof IncidentStatusObject];
export interface Indicator extends Entity, Parsable {
    /**
     * The artifact property
     */
    artifact?: Artifact;
    /**
     * The source property
     */
    source?: IndicatorSource;
}
export type IndicatorSource = (typeof IndicatorSourceObject)[keyof typeof IndicatorSourceObject];
export interface IntelligenceProfile extends Entity, Parsable {
    /**
     * A list of commonly-known aliases for the threat intelligence included in the intelligenceProfile.
     */
    aliases?: string[];
    /**
     * The country/region of origin for the given actor or threat associated with this intelligenceProfile.
     */
    countriesOrRegionsOfOrigin?: IntelligenceProfileCountryOrRegionOfOrigin[];
    /**
     * The description property
     */
    description?: FormattedContent;
    /**
     * The date and time when this intelligenceProfile was first active. The timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstActiveDateTime?: Date;
    /**
     * Includes an assemblage of high-fidelity network indicators of compromise.
     */
    indicators?: IntelligenceProfileIndicator[];
    /**
     * The kind property
     */
    kind?: IntelligenceProfileKind;
    /**
     * The summary property
     */
    summary?: FormattedContent;
    /**
     * Known targets related to this intelligenceProfile.
     */
    targets?: string[];
    /**
     * The title of this intelligenceProfile.
     */
    title?: string;
    /**
     * Formatted information featuring a description of the distinctive tactics, techniques, and procedures (TTP) of the group, followed by a list of all known custom, commodity, and publicly available implants used by the group.
     */
    tradecraft?: FormattedContent;
}
export interface IntelligenceProfileCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: IntelligenceProfile[];
}
export interface IntelligenceProfileCountryOrRegionOfOrigin extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * A codified representation for this country/region of origin.
     */
    code?: string;
    /**
     * A display label for this ountry/region of origin.
     */
    label?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface IntelligenceProfileIndicator extends Indicator, Parsable {
    /**
     * Designate when an artifact was first used actively in an attack, when a particular sample was compiled, or if neither of those could be ascertained when the file was first seen in public repositories (for example, VirusTotal, ANY.RUN, Hybrid Analysis) or reported publicly.
     */
    firstSeenDateTime?: Date;
    /**
     * Designate when an artifact was most recently used actively in an attack, when a particular sample was compiled, or if neither of those could be ascertained when the file was first seen in public repositories (for example, VirusTotal, ANY.RUN, Hybrid Analysis) or reported publicly.
     */
    lastSeenDateTime?: Date;
}
export interface IntelligenceProfileIndicatorCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: IntelligenceProfileIndicator[];
}
export type IntelligenceProfileKind = (typeof IntelligenceProfileKindObject)[keyof typeof IntelligenceProfileKindObject];
export interface IoTDeviceEvidence extends AlertEvidence, Parsable {
    /**
     * The deviceId property
     */
    deviceId?: string;
    /**
     * The deviceName property
     */
    deviceName?: string;
    /**
     * The devicePageLink property
     */
    devicePageLink?: string;
    /**
     * The deviceSubType property
     */
    deviceSubType?: string;
    /**
     * The deviceType property
     */
    deviceType?: string;
    /**
     * The importance property
     */
    importance?: IoTDeviceImportanceType;
    /**
     * The ioTHub property
     */
    ioTHub?: AzureResourceEvidence;
    /**
     * The ioTSecurityAgentId property
     */
    ioTSecurityAgentId?: string;
    /**
     * The ipAddress property
     */
    ipAddress?: IpEvidence;
    /**
     * The isAuthorized property
     */
    isAuthorized?: boolean;
    /**
     * The isProgramming property
     */
    isProgramming?: boolean;
    /**
     * The isScanner property
     */
    isScanner?: boolean;
    /**
     * The macAddress property
     */
    macAddress?: string;
    /**
     * The manufacturer property
     */
    manufacturer?: string;
    /**
     * The model property
     */
    model?: string;
    /**
     * The nics property
     */
    nics?: NicEvidence;
    /**
     * The operatingSystem property
     */
    operatingSystem?: string;
    /**
     * The owners property
     */
    owners?: string[];
    /**
     * The protocols property
     */
    protocols?: string[];
    /**
     * The purdueLayer property
     */
    purdueLayer?: string;
    /**
     * The sensor property
     */
    sensor?: string;
    /**
     * The serialNumber property
     */
    serialNumber?: string;
    /**
     * The site property
     */
    site?: string;
    /**
     * The source property
     */
    source?: string;
    /**
     * The sourceRef property
     */
    sourceRef?: UrlEvidence;
    /**
     * The zone property
     */
    zone?: string;
}
export type IoTDeviceImportanceType = (typeof IoTDeviceImportanceTypeObject)[keyof typeof IoTDeviceImportanceTypeObject];
export interface IpAddress extends Host, Parsable {
    /**
     * The details about the autonomous system to which this IP address belongs.
     */
    autonomousSystem?: AutonomousSystem;
    /**
     * The country/region for this IP address.
     */
    countryOrRegion?: string;
    /**
     * The hosting company listed for this host.
     */
    hostingProvider?: string;
    /**
     * The block of IP addresses this IP address belongs to.
     */
    netblock?: string;
}
export interface IpEvidence extends AlertEvidence, Parsable {
    /**
     * The two-letter country code according to ISO 3166 format, for example: US, UK, CA, etc.
     */
    countryLetterCode?: string;
    /**
     * The value of the IP Address, can be either in V4 address or V6 address format.
     */
    ipAddress?: string;
}
export interface KubernetesClusterEvidence extends AlertEvidence, Parsable {
    /**
     * The cloud identifier of the cluster. Can be either an amazonResourceEvidence, azureResourceEvidence, or googleCloudResourceEvidence object.
     */
    cloudResource?: AlertEvidence;
    /**
     * The distribution type of the cluster.
     */
    distribution?: string;
    /**
     * The cluster name.
     */
    name?: string;
    /**
     * The platform the cluster runs on. Possible values are: unknown, aks, eks, gke, arc, unknownFutureValue.
     */
    platform?: KubernetesPlatform;
    /**
     * The kubernetes version of the cluster.
     */
    version?: string;
}
export interface KubernetesControllerEvidence extends AlertEvidence, Parsable {
    /**
     * The labels for the Kubernetes pod.
     */
    labels?: Dictionary;
    /**
     * The controller name.
     */
    name?: string;
    /**
     * The service account namespace.
     */
    namespace?: KubernetesNamespaceEvidence;
    /**
     * The controller type.
     */
    type?: string;
}
export interface KubernetesNamespaceEvidence extends AlertEvidence, Parsable {
    /**
     * The namespace cluster.
     */
    cluster?: KubernetesClusterEvidence;
    /**
     * The labels for the Kubernetes pod.
     */
    labels?: Dictionary;
    /**
     * The namespace name.
     */
    name?: string;
}
export type KubernetesPlatform = (typeof KubernetesPlatformObject)[keyof typeof KubernetesPlatformObject];
export interface KubernetesPodEvidence extends AlertEvidence, Parsable {
    /**
     * The list of pod containers which are not init or ephemeral containers.
     */
    containers?: ContainerEvidence[];
    /**
     * The pod controller.
     */
    controller?: KubernetesControllerEvidence;
    /**
     * The list of pod ephemeral containers.
     */
    ephemeralContainers?: ContainerEvidence[];
    /**
     * The list of pod init containers.
     */
    initContainers?: ContainerEvidence[];
    /**
     * The pod labels.
     */
    labels?: Dictionary;
    /**
     * The pod name.
     */
    name?: string;
    /**
     * The pod namespace.
     */
    namespace?: KubernetesNamespaceEvidence;
    /**
     * The pod IP.
     */
    podIp?: IpEvidence;
    /**
     * The pod service account.
     */
    serviceAccount?: KubernetesServiceAccountEvidence;
}
export interface KubernetesSecretEvidence extends AlertEvidence, Parsable {
    /**
     * The secret name.
     */
    name?: string;
    /**
     * The secret namespace.
     */
    namespace?: KubernetesNamespaceEvidence;
    /**
     * The secret type can include both built-in types and custom ones. Examples of built-in types are: Opaque, kubernetes.io/service-account-token, kubernetes.io/dockercfg, kubernetes.io/dockerconfigjson, kubernetes.io/basic-auth, kubernetes.io/ssh-auth, kubernetes.io/tls, bootstrap.kubernetes.io/token.
     */
    secretType?: string;
}
export interface KubernetesServiceAccountEvidence extends AlertEvidence, Parsable {
    /**
     * The service account name.
     */
    name?: string;
    /**
     * The service account namespace.
     */
    namespace?: KubernetesNamespaceEvidence;
}
export interface KubernetesServiceEvidence extends AlertEvidence, Parsable {
    /**
     * The service cluster IP.
     */
    clusterIP?: IpEvidence;
    /**
     * The service external IPs.
     */
    externalIPs?: IpEvidence[];
    /**
     * The service labels.
     */
    labels?: Dictionary;
    /**
     * The service name.
     */
    name?: string;
    /**
     * The service namespace.
     */
    namespace?: KubernetesNamespaceEvidence;
    /**
     * The service selector.
     */
    selector?: Dictionary;
    /**
     * The list of service ports.
     */
    servicePorts?: KubernetesServicePort[];
    /**
     * The serviceType property
     */
    serviceType?: KubernetesServiceType;
}
export interface KubernetesServicePort extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The application protocol for this port.
     */
    appProtocol?: string;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The name of this port within the service.
     */
    name?: string;
    /**
     * The port on each node on which this service is exposed when the type is either NodePort or LoadBalancer.
     */
    nodePort?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The port that this service exposes.
     */
    port?: number;
    /**
     * The protocol name. Possible values are: udp, tcp, sctp, unknownFutureValue.
     */
    protocol?: ContainerPortProtocol;
    /**
     * The name or number of the port to access on the pods targeted by the service. The port number must be in the range 1 to 65535. The name must be an IANASVCNAME.
     */
    targetPort?: string;
}
export type KubernetesServiceType = (typeof KubernetesServiceTypeObject)[keyof typeof KubernetesServiceTypeObject];
export interface LoggedOnUser extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * User account name of the logged-on user.
     */
    accountName?: string;
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * User account domain of the logged-on user.
     */
    domainName?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface MailboxEvidence extends AlertEvidence, Parsable {
    /**
     * The name associated with the mailbox.
     */
    displayName?: string;
    /**
     * The primary email address of the mailbox.
     */
    primaryAddress?: string;
    /**
     * The user account of the mailbox.
     */
    userAccount?: UserAccount;
}
export interface MailClusterEvidence extends AlertEvidence, Parsable {
    /**
     * The clustering logic of the emails inside the cluster.
     */
    clusterBy?: string;
    /**
     * The value utilized to cluster the similar emails.
     */
    clusterByValue?: string;
    /**
     * Count of emails in the email cluster.
     */
    emailCount?: number;
    /**
     * Unique identifiers for the emails in the cluster, generated by Microsoft 365.
     */
    networkMessageIds?: string[];
    /**
     * The query used to identify the email cluster.
     */
    query?: string;
    /**
     * Uniform resource name (URN) of the automated investigation where the cluster was identified.
     */
    urn?: string;
}
export interface MalwareEvidence extends AlertEvidence, Parsable {
    /**
     * The category property
     */
    category?: string;
    /**
     * The files property
     */
    files?: FileEvidence[];
    /**
     * The name property
     */
    name?: string;
    /**
     * The processes property
     */
    processes?: ProcessEvidence[];
}
export interface NetworkConnectionEvidence extends AlertEvidence, Parsable {
    /**
     * The destinationAddress property
     */
    destinationAddress?: IpEvidence;
    /**
     * The destinationPort property
     */
    destinationPort?: number;
    /**
     * The protocol property
     */
    protocol?: ProtocolType;
    /**
     * The sourceAddress property
     */
    sourceAddress?: IpEvidence;
    /**
     * The sourcePort property
     */
    sourcePort?: number;
}
export interface NicEvidence extends AlertEvidence, Parsable {
    /**
     * The ipAddress property
     */
    ipAddress?: IpEvidence;
    /**
     * The macAddress property
     */
    macAddress?: string;
    /**
     * The vlans property
     */
    vlans?: string[];
}
export interface OauthApplicationEvidence extends AlertEvidence, Parsable {
    /**
     * Unique identifier of the application.
     */
    appId?: string;
    /**
     * Name of the application.
     */
    displayName?: string;
    /**
     * The unique identifier of the application object in Azure AD.
     */
    objectId?: string;
    /**
     * The name of the application publisher.
     */
    publisher?: string;
}
export interface OcrSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Indicates whether or not OCR is enabled for the case.
     */
    isEnabled?: boolean;
    /**
     * Maximum image size that will be processed in KB).
     */
    maxImageSize?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The timeout duration for the OCR engine. A longer timeout might increase success of OCR, but might add to the total processing time.
     */
    timeout?: Duration;
}
export type OnboardingStatus = (typeof OnboardingStatusObject)[keyof typeof OnboardingStatusObject];
export interface PassiveDnsRecord extends Artifact, Parsable {
    /**
     * The artifact property
     */
    artifact?: Artifact;
    /**
     * The date and time that this passiveDnsRecord entry was collected by Microsoft. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    collectedDateTime?: Date;
    /**
     * The date and time when this passiveDnsRecord entry was first seen. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The date and time when this passiveDnsRecord entry was most recently seen. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The parentHost property
     */
    parentHost?: Host;
    /**
     * The DNS record type for this passiveDnsRecord entry.
     */
    recordType?: string;
}
export interface PassiveDnsRecordCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: PassiveDnsRecord[];
}
export interface ProcessEvidence extends AlertEvidence, Parsable {
    /**
     * The status of the detection.The possible values are: detected, blocked, prevented, unknownFutureValue.
     */
    detectionStatus?: DetectionStatus;
    /**
     * Image file details.
     */
    imageFile?: FileDetails;
    /**
     * A unique identifier assigned to a device by Microsoft Defender for Endpoint.
     */
    mdeDeviceId?: string;
    /**
     * Date and time when the parent of the process was created. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    parentProcessCreationDateTime?: Date;
    /**
     * Process ID (PID) of the parent process that spawned the process.
     */
    parentProcessId?: number;
    /**
     * Parent process image file details.
     */
    parentProcessImageFile?: FileDetails;
    /**
     * Command line used to create the new process.
     */
    processCommandLine?: string;
    /**
     * Date and time when the process was created. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    processCreationDateTime?: Date;
    /**
     * Process ID (PID) of the newly created process.
     */
    processId?: number;
    /**
     * User details of the user that ran the process.
     */
    userAccount?: UserAccount;
}
export type ProtocolType = (typeof ProtocolTypeObject)[keyof typeof ProtocolTypeObject];
export type PurgeAreas = (typeof PurgeAreasObject)[keyof typeof PurgeAreasObject];
export type PurgeType = (typeof PurgeTypeObject)[keyof typeof PurgeTypeObject];
export type QueryType = (typeof QueryTypeObject)[keyof typeof QueryTypeObject];
export interface RedundancyDetectionSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Indicates whether email threading and near duplicate detection are enabled.
     */
    isEnabled?: boolean;
    /**
     * Specifies the maximum number of words used for email threading and near duplicate detection. To learn more, see Minimum/maximum number of words.
     */
    maxWords?: number;
    /**
     * Specifies the minimum number of words used for email threading and near duplicate detection. To learn more, see Minimum/maximum number of words.
     */
    minWords?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Specifies the similarity level for documents to be put in the same near duplicate set. To learn more, see Document and email similarity threshold.
     */
    similarityThreshold?: number;
}
export interface RegistryKeyEvidence extends AlertEvidence, Parsable {
    /**
     * Registry hive of the key that the recorded action was applied to.
     */
    registryHive?: string;
    /**
     * Registry key that the recorded action was applied to.
     */
    registryKey?: string;
}
export interface RegistryValueEvidence extends AlertEvidence, Parsable {
    /**
     * A unique identifier assigned to a device by Microsoft Defender for Endpoint.
     */
    mdeDeviceId?: string;
    /**
     * Registry hive of the key that the recorded action was applied to.
     */
    registryHive?: string;
    /**
     * Registry key that the recorded action was applied to.
     */
    registryKey?: string;
    /**
     * Data of the registry value that the recorded action was applied to.
     */
    registryValue?: string;
    /**
     * Name of the registry value that the recorded action was applied to.
     */
    registryValueName?: string;
    /**
     * Data type, such as binary or string, of the registry value that the recorded action was applied to.
     */
    registryValueType?: string;
}
export interface RetentionEvent extends Entity, Parsable {
    /**
     * The user who created the retentionEvent.
     */
    createdBy?: IdentitySet;
    /**
     * The date time when the retentionEvent was created.
     */
    createdDateTime?: Date;
    /**
     * Optional information about the event.
     */
    description?: string;
    /**
     * Name of the event.
     */
    displayName?: string;
    /**
     * The eventPropagationResults property
     */
    eventPropagationResults?: EventPropagationResult[];
    /**
     * Represents the workload (SharePoint Online, OneDrive for Business, Exchange Online) and identification information associated with a retention event.
     */
    eventQueries?: EventQuery[];
    /**
     * The eventStatus property
     */
    eventStatus?: RetentionEventStatus;
    /**
     * Optional time when the event should be triggered.
     */
    eventTriggerDateTime?: Date;
    /**
     * The user who last modified the retentionEvent.
     */
    lastModifiedBy?: IdentitySet;
    /**
     * The latest date time when the retentionEvent was modified.
     */
    lastModifiedDateTime?: Date;
    /**
     * Last time the status of the event was updated.
     */
    lastStatusUpdateDateTime?: Date;
    /**
     * Specifies the event that will start the retention period for labels that use this event type when an event is created.
     */
    retentionEventType?: RetentionEventType;
}
export interface RetentionEventCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: RetentionEvent[];
}
export interface RetentionEventStatus extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The error if the status isn't successful.
     */
    errorEscaped?: PublicError;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The status of the distribution. The possible values are: pending, error, success, notAvaliable.
     */
    status?: EventStatusType;
}
export interface RetentionEventType extends Entity, Parsable {
    /**
     * The user who created the retentionEventType.
     */
    createdBy?: IdentitySet;
    /**
     * The date time when the retentionEventType was created.
     */
    createdDateTime?: Date;
    /**
     * Optional information about the event type.
     */
    description?: string;
    /**
     * Name of the event type.
     */
    displayName?: string;
    /**
     * The user who last modified the retentionEventType.
     */
    lastModifiedBy?: IdentitySet;
    /**
     * The latest date time when the retentionEventType was modified.
     */
    lastModifiedDateTime?: Date;
}
export interface RetentionEventTypeCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: RetentionEventType[];
}
export interface SasTokenEvidence extends AlertEvidence, Parsable {
    /**
     * The allowedIpAddresses property
     */
    allowedIpAddresses?: string;
    /**
     * The allowedResourceTypes property
     */
    allowedResourceTypes?: string[];
    /**
     * The allowedServices property
     */
    allowedServices?: string[];
    /**
     * The expiryDateTime property
     */
    expiryDateTime?: Date;
    /**
     * The permissions property
     */
    permissions?: string[];
    /**
     * The protocol property
     */
    protocol?: string;
    /**
     * The signatureHash property
     */
    signatureHash?: string;
    /**
     * The signedWith property
     */
    signedWith?: string;
    /**
     * The startDateTime property
     */
    startDateTime?: Date;
    /**
     * The storageResource property
     */
    storageResource?: AzureResourceEvidence;
}
export interface Search extends Entity, Parsable {
    /**
     * The contentQuery property
     */
    contentQuery?: string;
    /**
     * The createdBy property
     */
    createdBy?: IdentitySet;
    /**
     * The createdDateTime property
     */
    createdDateTime?: Date;
    /**
     * The description property
     */
    description?: string;
    /**
     * The displayName property
     */
    displayName?: string;
    /**
     * The lastModifiedBy property
     */
    lastModifiedBy?: IdentitySet;
    /**
     * The lastModifiedDateTime property
     */
    lastModifiedDateTime?: Date;
}
export interface SecurityGroupEvidence extends AlertEvidence, Parsable {
    /**
     * The name of the security group.
     */
    displayName?: string;
    /**
     * Unique identifier of the security group.
     */
    securityGroupId?: string;
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAlert(writer: SerializationWriter, alert: Partial<Alert> | undefined = {}) : void {
    serializeEntity(writer, alert)
    writer.writeStringValue("actorDisplayName", alert.actorDisplayName);
    writer.writeStringValue("alertPolicyId", alert.alertPolicyId);
    writer.writeStringValue("alertWebUrl", alert.alertWebUrl);
    writer.writeStringValue("assignedTo", alert.assignedTo);
    writer.writeStringValue("category", alert.category);
    writer.writeEnumValue<AlertClassification>("classification", alert.classification);
    writer.writeCollectionOfObjectValues<AlertComment>("comments", alert.comments, serializeAlertComment);
    writer.writeDateValue("createdDateTime", alert.createdDateTime);
    writer.writeStringValue("description", alert.description);
    writer.writeEnumValue<DetectionSource>("detectionSource", alert.detectionSource);
    writer.writeStringValue("detectorId", alert.detectorId);
    writer.writeEnumValue<AlertDetermination>("determination", alert.determination);
    writer.writeCollectionOfObjectValues<AlertEvidence>("evidence", alert.evidence, serializeAlertEvidence);
    writer.writeDateValue("firstActivityDateTime", alert.firstActivityDateTime);
    writer.writeStringValue("incidentId", alert.incidentId);
    writer.writeStringValue("incidentWebUrl", alert.incidentWebUrl);
    writer.writeDateValue("lastActivityDateTime", alert.lastActivityDateTime);
    writer.writeDateValue("lastUpdateDateTime", alert.lastUpdateDateTime);
    writer.writeCollectionOfPrimitiveValues<string>("mitreTechniques", alert.mitreTechniques);
    writer.writeStringValue("productName", alert.productName);
    writer.writeStringValue("providerAlertId", alert.providerAlertId);
    writer.writeStringValue("recommendedActions", alert.recommendedActions);
    writer.writeDateValue("resolvedDateTime", alert.resolvedDateTime);
    writer.writeEnumValue<ServiceSource>("serviceSource", alert.serviceSource);
    writer.writeEnumValue<AlertSeverity>("severity", alert.severity);
    writer.writeEnumValue<AlertStatus>("status", alert.status);
    writer.writeStringValue("tenantId", alert.tenantId);
    writer.writeStringValue("threatDisplayName", alert.threatDisplayName);
    writer.writeStringValue("threatFamilyName", alert.threatFamilyName);
    writer.writeStringValue("title", alert.title);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAlertCollectionResponse(writer: SerializationWriter, alertCollectionResponse: Partial<AlertCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, alertCollectionResponse)
    writer.writeCollectionOfObjectValues<Alert>("value", alertCollectionResponse.value, serializeAlert);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAlertComment(writer: SerializationWriter, alertComment: Partial<AlertComment> | undefined = {}) : void {
    writer.writeStringValue("comment", alertComment.comment);
    writer.writeStringValue("createdByDisplayName", alertComment.createdByDisplayName);
    writer.writeDateValue("createdDateTime", alertComment.createdDateTime);
    writer.writeStringValue("@odata.type", alertComment.odataType);
    writer.writeAdditionalData(alertComment.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAlertEvidence(writer: SerializationWriter, alertEvidence: Partial<AlertEvidence> | undefined = {}) : void {
    writer.writeDateValue("createdDateTime", alertEvidence.createdDateTime);
    writer.writeCollectionOfPrimitiveValues<string>("detailedRoles", alertEvidence.detailedRoles);
    writer.writeStringValue("@odata.type", alertEvidence.odataType);
    writer.writeEnumValue<EvidenceRemediationStatus>("remediationStatus", alertEvidence.remediationStatus);
    writer.writeStringValue("remediationStatusDetails", alertEvidence.remediationStatusDetails);
    if(alertEvidence.roles)
    writer.writeEnumValue<EvidenceRole>("roles", ...alertEvidence.roles);
    writer.writeCollectionOfPrimitiveValues<string>("tags", alertEvidence.tags);
    writer.writeEnumValue<EvidenceVerdict>("verdict", alertEvidence.verdict);
    writer.writeAdditionalData(alertEvidence.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAmazonResourceEvidence(writer: SerializationWriter, amazonResourceEvidence: Partial<AmazonResourceEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, amazonResourceEvidence)
    writer.writeStringValue("amazonAccountId", amazonResourceEvidence.amazonAccountId);
    writer.writeStringValue("amazonResourceId", amazonResourceEvidence.amazonResourceId);
    writer.writeStringValue("resourceName", amazonResourceEvidence.resourceName);
    writer.writeStringValue("resourceType", amazonResourceEvidence.resourceType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAnalyzedMessageEvidence(writer: SerializationWriter, analyzedMessageEvidence: Partial<AnalyzedMessageEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, analyzedMessageEvidence)
    writer.writeStringValue("antiSpamDirection", analyzedMessageEvidence.antiSpamDirection);
    writer.writeNumberValue("attachmentsCount", analyzedMessageEvidence.attachmentsCount);
    writer.writeStringValue("deliveryAction", analyzedMessageEvidence.deliveryAction);
    writer.writeStringValue("deliveryLocation", analyzedMessageEvidence.deliveryLocation);
    writer.writeStringValue("internetMessageId", analyzedMessageEvidence.internetMessageId);
    writer.writeStringValue("language", analyzedMessageEvidence.language);
    writer.writeStringValue("networkMessageId", analyzedMessageEvidence.networkMessageId);
    writer.writeObjectValue<EmailSender>("p1Sender", analyzedMessageEvidence.p1Sender, serializeEmailSender);
    writer.writeObjectValue<EmailSender>("p2Sender", analyzedMessageEvidence.p2Sender, serializeEmailSender);
    writer.writeDateValue("receivedDateTime", analyzedMessageEvidence.receivedDateTime);
    writer.writeStringValue("recipientEmailAddress", analyzedMessageEvidence.recipientEmailAddress);
    writer.writeStringValue("senderIp", analyzedMessageEvidence.senderIp);
    writer.writeStringValue("subject", analyzedMessageEvidence.subject);
    writer.writeCollectionOfPrimitiveValues<string>("threatDetectionMethods", analyzedMessageEvidence.threatDetectionMethods);
    writer.writeCollectionOfPrimitiveValues<string>("threats", analyzedMessageEvidence.threats);
    writer.writeNumberValue("urlCount", analyzedMessageEvidence.urlCount);
    writer.writeCollectionOfPrimitiveValues<string>("urls", analyzedMessageEvidence.urls);
    writer.writeStringValue("urn", analyzedMessageEvidence.urn);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeArticle(writer: SerializationWriter, article: Partial<Article> | undefined = {}) : void {
    serializeEntity(writer, article)
    writer.writeObjectValue<FormattedContent>("body", article.body, serializeFormattedContent);
    writer.writeDateValue("createdDateTime", article.createdDateTime);
    writer.writeStringValue("imageUrl", article.imageUrl);
    writer.writeCollectionOfObjectValues<ArticleIndicator>("indicators", article.indicators, serializeArticleIndicator);
    writer.writeBooleanValue("isFeatured", article.isFeatured);
    writer.writeDateValue("lastUpdatedDateTime", article.lastUpdatedDateTime);
    writer.writeObjectValue<FormattedContent>("summary", article.summary, serializeFormattedContent);
    writer.writeCollectionOfPrimitiveValues<string>("tags", article.tags);
    writer.writeStringValue("title", article.title);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeArticleCollectionResponse(writer: SerializationWriter, articleCollectionResponse: Partial<ArticleCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, articleCollectionResponse)
    writer.writeCollectionOfObjectValues<Article>("value", articleCollectionResponse.value, serializeArticle);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeArticleIndicator(writer: SerializationWriter, articleIndicator: Partial<ArticleIndicator> | undefined = {}) : void {
    serializeIndicator(writer, articleIndicator)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeArticleIndicatorCollectionResponse(writer: SerializationWriter, articleIndicatorCollectionResponse: Partial<ArticleIndicatorCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, articleIndicatorCollectionResponse)
    writer.writeCollectionOfObjectValues<ArticleIndicator>("value", articleIndicatorCollectionResponse.value, serializeArticleIndicator);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeArtifact(writer: SerializationWriter, artifact: Partial<Artifact> | undefined = {}) : void {
    serializeEntity(writer, artifact)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAutonomousSystem(writer: SerializationWriter, autonomousSystem: Partial<AutonomousSystem> | undefined = {}) : void {
    writer.writeStringValue("name", autonomousSystem.name);
    writer.writeNumberValue("number", autonomousSystem.number);
    writer.writeStringValue("@odata.type", autonomousSystem.odataType);
    writer.writeStringValue("organization", autonomousSystem.organization);
    writer.writeStringValue("value", autonomousSystem.value);
    writer.writeAdditionalData(autonomousSystem.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAzureResourceEvidence(writer: SerializationWriter, azureResourceEvidence: Partial<AzureResourceEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, azureResourceEvidence)
    writer.writeStringValue("resourceId", azureResourceEvidence.resourceId);
    writer.writeStringValue("resourceName", azureResourceEvidence.resourceName);
    writer.writeStringValue("resourceType", azureResourceEvidence.resourceType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeBlobContainerEvidence(writer: SerializationWriter, blobContainerEvidence: Partial<BlobContainerEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, blobContainerEvidence)
    writer.writeStringValue("name", blobContainerEvidence.name);
    writer.writeObjectValue<AzureResourceEvidence>("storageResource", blobContainerEvidence.storageResource, serializeAzureResourceEvidence);
    writer.writeStringValue("url", blobContainerEvidence.url);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeBlobEvidence(writer: SerializationWriter, blobEvidence: Partial<BlobEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, blobEvidence)
    writer.writeObjectValue<BlobContainerEvidence>("blobContainer", blobEvidence.blobContainer, serializeBlobContainerEvidence);
    writer.writeStringValue("etag", blobEvidence.etag);
    writer.writeCollectionOfObjectValues<FileHash>("fileHashes", blobEvidence.fileHashes, serializeFileHash);
    writer.writeStringValue("name", blobEvidence.name);
    writer.writeStringValue("url", blobEvidence.url);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCaseEscaped(writer: SerializationWriter, caseEscaped: Partial<CaseEscaped> | undefined = {}) : void {
    serializeEntity(writer, caseEscaped)
    writer.writeDateValue("createdDateTime", caseEscaped.createdDateTime);
    writer.writeStringValue("description", caseEscaped.description);
    writer.writeStringValue("displayName", caseEscaped.displayName);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", caseEscaped.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", caseEscaped.lastModifiedDateTime);
    writer.writeEnumValue<CaseStatus>("status", caseEscaped.status);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCaseOperation(writer: SerializationWriter, caseOperation: Partial<CaseOperation> | undefined = {}) : void {
    serializeEntity(writer, caseOperation)
    writer.writeEnumValue<CaseAction>("action", caseOperation.action);
    writer.writeDateValue("completedDateTime", caseOperation.completedDateTime);
    writer.writeObjectValue<IdentitySet>("createdBy", caseOperation.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", caseOperation.createdDateTime);
    writer.writeNumberValue("percentProgress", caseOperation.percentProgress);
    writer.writeObjectValue<ResultInfo>("resultInfo", caseOperation.resultInfo, serializeResultInfo);
    writer.writeEnumValue<CaseOperationStatus>("status", caseOperation.status);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCaseOperationCollectionResponse(writer: SerializationWriter, caseOperationCollectionResponse: Partial<CaseOperationCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, caseOperationCollectionResponse)
    writer.writeCollectionOfObjectValues<CaseOperation>("value", caseOperationCollectionResponse.value, serializeCaseOperation);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCasesRoot(writer: SerializationWriter, casesRoot: Partial<CasesRoot> | undefined = {}) : void {
    serializeEntity(writer, casesRoot)
    writer.writeCollectionOfObjectValues<EdiscoveryCase>("ediscoveryCases", casesRoot.ediscoveryCases, serializeEdiscoveryCase);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCloudApplicationEvidence(writer: SerializationWriter, cloudApplicationEvidence: Partial<CloudApplicationEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, cloudApplicationEvidence)
    writer.writeNumberValue("appId", cloudApplicationEvidence.appId);
    writer.writeStringValue("displayName", cloudApplicationEvidence.displayName);
    writer.writeNumberValue("instanceId", cloudApplicationEvidence.instanceId);
    writer.writeStringValue("instanceName", cloudApplicationEvidence.instanceName);
    writer.writeNumberValue("saasAppId", cloudApplicationEvidence.saasAppId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeContainerEvidence(writer: SerializationWriter, containerEvidence: Partial<ContainerEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, containerEvidence)
    writer.writeCollectionOfPrimitiveValues<string>("args", containerEvidence.args);
    writer.writeCollectionOfPrimitiveValues<string>("command", containerEvidence.command);
    writer.writeStringValue("containerId", containerEvidence.containerId);
    writer.writeObjectValue<ContainerImageEvidence>("image", containerEvidence.image, serializeContainerImageEvidence);
    writer.writeBooleanValue("isPrivileged", containerEvidence.isPrivileged);
    writer.writeStringValue("name", containerEvidence.name);
    writer.writeObjectValue<KubernetesPodEvidence>("pod", containerEvidence.pod, serializeKubernetesPodEvidence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeContainerImageEvidence(writer: SerializationWriter, containerImageEvidence: Partial<ContainerImageEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, containerImageEvidence)
    writer.writeObjectValue<ContainerImageEvidence>("digestImage", containerImageEvidence.digestImage, serializeContainerImageEvidence);
    writer.writeStringValue("imageId", containerImageEvidence.imageId);
    writer.writeObjectValue<ContainerRegistryEvidence>("registry", containerImageEvidence.registry, serializeContainerRegistryEvidence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeContainerRegistryEvidence(writer: SerializationWriter, containerRegistryEvidence: Partial<ContainerRegistryEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, containerRegistryEvidence)
    writer.writeStringValue("registry", containerRegistryEvidence.registry);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCvssSummary(writer: SerializationWriter, cvssSummary: Partial<CvssSummary> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", cvssSummary.odataType);
    writer.writeNumberValue("score", cvssSummary.score);
    writer.writeEnumValue<VulnerabilitySeverity>("severity", cvssSummary.severity);
    writer.writeStringValue("vectorString", cvssSummary.vectorString);
    writer.writeAdditionalData(cvssSummary.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDataSet(writer: SerializationWriter, dataSet: Partial<DataSet> | undefined = {}) : void {
    serializeEntity(writer, dataSet)
    writer.writeObjectValue<IdentitySet>("createdBy", dataSet.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", dataSet.createdDateTime);
    writer.writeStringValue("displayName", dataSet.displayName);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDataSource(writer: SerializationWriter, dataSource: Partial<DataSource> | undefined = {}) : void {
    serializeEntity(writer, dataSource)
    writer.writeObjectValue<IdentitySet>("createdBy", dataSource.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", dataSource.createdDateTime);
    writer.writeStringValue("displayName", dataSource.displayName);
    writer.writeEnumValue<DataSourceHoldStatus>("holdStatus", dataSource.holdStatus);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDataSourceCollectionResponse(writer: SerializationWriter, dataSourceCollectionResponse: Partial<DataSourceCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, dataSourceCollectionResponse)
    writer.writeCollectionOfObjectValues<DataSource>("value", dataSourceCollectionResponse.value, serializeDataSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDataSourceContainer(writer: SerializationWriter, dataSourceContainer: Partial<DataSourceContainer> | undefined = {}) : void {
    serializeEntity(writer, dataSourceContainer)
    writer.writeDateValue("createdDateTime", dataSourceContainer.createdDateTime);
    writer.writeStringValue("displayName", dataSourceContainer.displayName);
    writer.writeEnumValue<DataSourceHoldStatus>("holdStatus", dataSourceContainer.holdStatus);
    writer.writeDateValue("lastModifiedDateTime", dataSourceContainer.lastModifiedDateTime);
    writer.writeDateValue("releasedDateTime", dataSourceContainer.releasedDateTime);
    writer.writeEnumValue<DataSourceContainerStatus>("status", dataSourceContainer.status);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDeviceEvidence(writer: SerializationWriter, deviceEvidence: Partial<DeviceEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, deviceEvidence)
    writer.writeStringValue("azureAdDeviceId", deviceEvidence.azureAdDeviceId);
    writer.writeEnumValue<DefenderAvStatus>("defenderAvStatus", deviceEvidence.defenderAvStatus);
    writer.writeStringValue("deviceDnsName", deviceEvidence.deviceDnsName);
    writer.writeDateValue("firstSeenDateTime", deviceEvidence.firstSeenDateTime);
    writer.writeEnumValue<DeviceHealthStatus>("healthStatus", deviceEvidence.healthStatus);
    writer.writeCollectionOfPrimitiveValues<string>("ipInterfaces", deviceEvidence.ipInterfaces);
    writer.writeCollectionOfObjectValues<LoggedOnUser>("loggedOnUsers", deviceEvidence.loggedOnUsers, serializeLoggedOnUser);
    writer.writeStringValue("mdeDeviceId", deviceEvidence.mdeDeviceId);
    writer.writeEnumValue<OnboardingStatus>("onboardingStatus", deviceEvidence.onboardingStatus);
    writer.writeNumberValue("osBuild", deviceEvidence.osBuild);
    writer.writeStringValue("osPlatform", deviceEvidence.osPlatform);
    writer.writeNumberValue("rbacGroupId", deviceEvidence.rbacGroupId);
    writer.writeStringValue("rbacGroupName", deviceEvidence.rbacGroupName);
    writer.writeEnumValue<DeviceRiskScore>("riskScore", deviceEvidence.riskScore);
    writer.writeStringValue("version", deviceEvidence.version);
    writer.writeObjectValue<VmMetadata>("vmMetadata", deviceEvidence.vmMetadata, serializeVmMetadata);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDictionary(writer: SerializationWriter, dictionary: Partial<Dictionary> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", dictionary.odataType);
    writer.writeAdditionalData(dictionary.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDnsEvidence(writer: SerializationWriter, dnsEvidence: Partial<DnsEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, dnsEvidence)
    writer.writeObjectValue<IpEvidence>("dnsServerIp", dnsEvidence.dnsServerIp, serializeIpEvidence);
    writer.writeStringValue("domainName", dnsEvidence.domainName);
    writer.writeObjectValue<IpEvidence>("hostIpAddress", dnsEvidence.hostIpAddress, serializeIpEvidence);
    writer.writeCollectionOfObjectValues<IpEvidence>("ipAddresses", dnsEvidence.ipAddresses, serializeIpEvidence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryAddToReviewSetOperation(writer: SerializationWriter, ediscoveryAddToReviewSetOperation: Partial<EdiscoveryAddToReviewSetOperation> | undefined = {}) : void {
    serializeCaseOperation(writer, ediscoveryAddToReviewSetOperation)
    writer.writeObjectValue<EdiscoveryReviewSet>("reviewSet", ediscoveryAddToReviewSetOperation.reviewSet, serializeEdiscoveryReviewSet);
    writer.writeObjectValue<EdiscoverySearch>("search", ediscoveryAddToReviewSetOperation.search, serializeEdiscoverySearch);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryCase(writer: SerializationWriter, ediscoveryCase: Partial<EdiscoveryCase> | undefined = {}) : void {
    serializeCaseEscaped(writer, ediscoveryCase)
    writer.writeObjectValue<IdentitySet>("closedBy", ediscoveryCase.closedBy, serializeIdentitySet);
    writer.writeDateValue("closedDateTime", ediscoveryCase.closedDateTime);
    writer.writeCollectionOfObjectValues<EdiscoveryCustodian>("custodians", ediscoveryCase.custodians, serializeEdiscoveryCustodian);
    writer.writeStringValue("externalId", ediscoveryCase.externalId);
    writer.writeCollectionOfObjectValues<EdiscoveryNoncustodialDataSource>("noncustodialDataSources", ediscoveryCase.noncustodialDataSources, serializeEdiscoveryNoncustodialDataSource);
    writer.writeCollectionOfObjectValues<CaseOperation>("operations", ediscoveryCase.operations, serializeCaseOperation);
    writer.writeCollectionOfObjectValues<EdiscoveryReviewSet>("reviewSets", ediscoveryCase.reviewSets, serializeEdiscoveryReviewSet);
    writer.writeCollectionOfObjectValues<EdiscoverySearch>("searches", ediscoveryCase.searches, serializeEdiscoverySearch);
    writer.writeObjectValue<EdiscoveryCaseSettings>("settings", ediscoveryCase.settings, serializeEdiscoveryCaseSettings);
    writer.writeCollectionOfObjectValues<EdiscoveryReviewTag>("tags", ediscoveryCase.tags, serializeEdiscoveryReviewTag);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryCaseCollectionResponse(writer: SerializationWriter, ediscoveryCaseCollectionResponse: Partial<EdiscoveryCaseCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoveryCaseCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoveryCase>("value", ediscoveryCaseCollectionResponse.value, serializeEdiscoveryCase);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryCaseSettings(writer: SerializationWriter, ediscoveryCaseSettings: Partial<EdiscoveryCaseSettings> | undefined = {}) : void {
    serializeEntity(writer, ediscoveryCaseSettings)
    writer.writeObjectValue<OcrSettings>("ocr", ediscoveryCaseSettings.ocr, serializeOcrSettings);
    writer.writeObjectValue<RedundancyDetectionSettings>("redundancyDetection", ediscoveryCaseSettings.redundancyDetection, serializeRedundancyDetectionSettings);
    writer.writeObjectValue<TopicModelingSettings>("topicModeling", ediscoveryCaseSettings.topicModeling, serializeTopicModelingSettings);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryCustodian(writer: SerializationWriter, ediscoveryCustodian: Partial<EdiscoveryCustodian> | undefined = {}) : void {
    serializeDataSourceContainer(writer, ediscoveryCustodian)
    writer.writeDateValue("acknowledgedDateTime", ediscoveryCustodian.acknowledgedDateTime);
    writer.writeStringValue("email", ediscoveryCustodian.email);
    writer.writeObjectValue<EdiscoveryIndexOperation>("lastIndexOperation", ediscoveryCustodian.lastIndexOperation, serializeEdiscoveryIndexOperation);
    writer.writeCollectionOfObjectValues<SiteSource>("siteSources", ediscoveryCustodian.siteSources, serializeSiteSource);
    writer.writeCollectionOfObjectValues<UnifiedGroupSource>("unifiedGroupSources", ediscoveryCustodian.unifiedGroupSources, serializeUnifiedGroupSource);
    writer.writeCollectionOfObjectValues<UserSource>("userSources", ediscoveryCustodian.userSources, serializeUserSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryCustodianCollectionResponse(writer: SerializationWriter, ediscoveryCustodianCollectionResponse: Partial<EdiscoveryCustodianCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoveryCustodianCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoveryCustodian>("value", ediscoveryCustodianCollectionResponse.value, serializeEdiscoveryCustodian);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryEstimateOperation(writer: SerializationWriter, ediscoveryEstimateOperation: Partial<EdiscoveryEstimateOperation> | undefined = {}) : void {
    serializeCaseOperation(writer, ediscoveryEstimateOperation)
    writer.writeNumberValue("indexedItemCount", ediscoveryEstimateOperation.indexedItemCount);
    writer.writeNumberValue("indexedItemsSize", ediscoveryEstimateOperation.indexedItemsSize);
    writer.writeNumberValue("mailboxCount", ediscoveryEstimateOperation.mailboxCount);
    writer.writeObjectValue<EdiscoverySearch>("search", ediscoveryEstimateOperation.search, serializeEdiscoverySearch);
    writer.writeNumberValue("siteCount", ediscoveryEstimateOperation.siteCount);
    writer.writeNumberValue("unindexedItemCount", ediscoveryEstimateOperation.unindexedItemCount);
    writer.writeNumberValue("unindexedItemsSize", ediscoveryEstimateOperation.unindexedItemsSize);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryExportOperation(writer: SerializationWriter, ediscoveryExportOperation: Partial<EdiscoveryExportOperation> | undefined = {}) : void {
    serializeCaseOperation(writer, ediscoveryExportOperation)
    writer.writeStringValue("description", ediscoveryExportOperation.description);
    writer.writeCollectionOfObjectValues<ExportFileMetadata>("exportFileMetadata", ediscoveryExportOperation.exportFileMetadata, serializeExportFileMetadata);
    writer.writeEnumValue<ExportOptions[]>("exportOptions", ediscoveryExportOperation.exportOptions);
    writer.writeEnumValue<ExportFileStructure>("exportStructure", ediscoveryExportOperation.exportStructure);
    writer.writeStringValue("outputName", ediscoveryExportOperation.outputName);
    writer.writeObjectValue<EdiscoveryReviewSet>("reviewSet", ediscoveryExportOperation.reviewSet, serializeEdiscoveryReviewSet);
    writer.writeObjectValue<EdiscoveryReviewSetQuery>("reviewSetQuery", ediscoveryExportOperation.reviewSetQuery, serializeEdiscoveryReviewSetQuery);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryHoldOperation(writer: SerializationWriter, ediscoveryHoldOperation: Partial<EdiscoveryHoldOperation> | undefined = {}) : void {
    serializeCaseOperation(writer, ediscoveryHoldOperation)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryIndexOperation(writer: SerializationWriter, ediscoveryIndexOperation: Partial<EdiscoveryIndexOperation> | undefined = {}) : void {
    serializeCaseOperation(writer, ediscoveryIndexOperation)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryNoncustodialDataSource(writer: SerializationWriter, ediscoveryNoncustodialDataSource: Partial<EdiscoveryNoncustodialDataSource> | undefined = {}) : void {
    serializeDataSourceContainer(writer, ediscoveryNoncustodialDataSource)
    writer.writeObjectValue<DataSource>("dataSource", ediscoveryNoncustodialDataSource.dataSource, serializeDataSource);
    writer.writeObjectValue<EdiscoveryIndexOperation>("lastIndexOperation", ediscoveryNoncustodialDataSource.lastIndexOperation, serializeEdiscoveryIndexOperation);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryNoncustodialDataSourceCollectionResponse(writer: SerializationWriter, ediscoveryNoncustodialDataSourceCollectionResponse: Partial<EdiscoveryNoncustodialDataSourceCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoveryNoncustodialDataSourceCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoveryNoncustodialDataSource>("value", ediscoveryNoncustodialDataSourceCollectionResponse.value, serializeEdiscoveryNoncustodialDataSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryPurgeDataOperation(writer: SerializationWriter, ediscoveryPurgeDataOperation: Partial<EdiscoveryPurgeDataOperation> | undefined = {}) : void {
    serializeCaseOperation(writer, ediscoveryPurgeDataOperation)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryReviewSet(writer: SerializationWriter, ediscoveryReviewSet: Partial<EdiscoveryReviewSet> | undefined = {}) : void {
    serializeDataSet(writer, ediscoveryReviewSet)
    writer.writeCollectionOfObjectValues<EdiscoveryReviewSetQuery>("queries", ediscoveryReviewSet.queries, serializeEdiscoveryReviewSetQuery);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryReviewSetCollectionResponse(writer: SerializationWriter, ediscoveryReviewSetCollectionResponse: Partial<EdiscoveryReviewSetCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoveryReviewSetCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoveryReviewSet>("value", ediscoveryReviewSetCollectionResponse.value, serializeEdiscoveryReviewSet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryReviewSetQuery(writer: SerializationWriter, ediscoveryReviewSetQuery: Partial<EdiscoveryReviewSetQuery> | undefined = {}) : void {
    serializeSearch(writer, ediscoveryReviewSetQuery)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryReviewSetQueryCollectionResponse(writer: SerializationWriter, ediscoveryReviewSetQueryCollectionResponse: Partial<EdiscoveryReviewSetQueryCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoveryReviewSetQueryCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoveryReviewSetQuery>("value", ediscoveryReviewSetQueryCollectionResponse.value, serializeEdiscoveryReviewSetQuery);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryReviewTag(writer: SerializationWriter, ediscoveryReviewTag: Partial<EdiscoveryReviewTag> | undefined = {}) : void {
    serializeTag(writer, ediscoveryReviewTag)
    writer.writeEnumValue<ChildSelectability>("childSelectability", ediscoveryReviewTag.childSelectability);
    writer.writeCollectionOfObjectValues<EdiscoveryReviewTag>("childTags", ediscoveryReviewTag.childTags, serializeEdiscoveryReviewTag);
    writer.writeObjectValue<EdiscoveryReviewTag>("parent", ediscoveryReviewTag.parent, serializeEdiscoveryReviewTag);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryReviewTagCollectionResponse(writer: SerializationWriter, ediscoveryReviewTagCollectionResponse: Partial<EdiscoveryReviewTagCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoveryReviewTagCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoveryReviewTag>("value", ediscoveryReviewTagCollectionResponse.value, serializeEdiscoveryReviewTag);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoverySearch(writer: SerializationWriter, ediscoverySearch: Partial<EdiscoverySearch> | undefined = {}) : void {
    serializeSearch(writer, ediscoverySearch)
    writer.writeCollectionOfObjectValues<DataSource>("additionalSources", ediscoverySearch.additionalSources, serializeDataSource);
    writer.writeObjectValue<EdiscoveryAddToReviewSetOperation>("addToReviewSetOperation", ediscoverySearch.addToReviewSetOperation, serializeEdiscoveryAddToReviewSetOperation);
    writer.writeCollectionOfObjectValues<DataSource>("custodianSources", ediscoverySearch.custodianSources, serializeDataSource);
    writer.writeEnumValue<DataSourceScopes[]>("dataSourceScopes", ediscoverySearch.dataSourceScopes);
    writer.writeObjectValue<EdiscoveryEstimateOperation>("lastEstimateStatisticsOperation", ediscoverySearch.lastEstimateStatisticsOperation, serializeEdiscoveryEstimateOperation);
    writer.writeCollectionOfObjectValues<EdiscoveryNoncustodialDataSource>("noncustodialSources", ediscoverySearch.noncustodialSources, serializeEdiscoveryNoncustodialDataSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoverySearchCollectionResponse(writer: SerializationWriter, ediscoverySearchCollectionResponse: Partial<EdiscoverySearchCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, ediscoverySearchCollectionResponse)
    writer.writeCollectionOfObjectValues<EdiscoverySearch>("value", ediscoverySearchCollectionResponse.value, serializeEdiscoverySearch);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEdiscoveryTagOperation(writer: SerializationWriter, ediscoveryTagOperation: Partial<EdiscoveryTagOperation> | undefined = {}) : void {
    serializeCaseOperation(writer, ediscoveryTagOperation)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEmailSender(writer: SerializationWriter, emailSender: Partial<EmailSender> | undefined = {}) : void {
    writer.writeStringValue("displayName", emailSender.displayName);
    writer.writeStringValue("domainName", emailSender.domainName);
    writer.writeStringValue("emailAddress", emailSender.emailAddress);
    writer.writeStringValue("@odata.type", emailSender.odataType);
    writer.writeAdditionalData(emailSender.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEventPropagationResult(writer: SerializationWriter, eventPropagationResult: Partial<EventPropagationResult> | undefined = {}) : void {
    writer.writeStringValue("location", eventPropagationResult.location);
    writer.writeStringValue("@odata.type", eventPropagationResult.odataType);
    writer.writeStringValue("serviceName", eventPropagationResult.serviceName);
    writer.writeEnumValue<EventPropagationStatus>("status", eventPropagationResult.status);
    writer.writeStringValue("statusInformation", eventPropagationResult.statusInformation);
    writer.writeAdditionalData(eventPropagationResult.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEventQuery(writer: SerializationWriter, eventQuery: Partial<EventQuery> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", eventQuery.odataType);
    writer.writeStringValue("query", eventQuery.query);
    writer.writeEnumValue<QueryType>("queryType", eventQuery.queryType);
    writer.writeAdditionalData(eventQuery.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExportFileMetadata(writer: SerializationWriter, exportFileMetadata: Partial<ExportFileMetadata> | undefined = {}) : void {
    writer.writeStringValue("downloadUrl", exportFileMetadata.downloadUrl);
    writer.writeStringValue("fileName", exportFileMetadata.fileName);
    writer.writeStringValue("@odata.type", exportFileMetadata.odataType);
    writer.writeNumberValue("size", exportFileMetadata.size);
    writer.writeAdditionalData(exportFileMetadata.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFileDetails(writer: SerializationWriter, fileDetails: Partial<FileDetails> | undefined = {}) : void {
    writer.writeStringValue("fileName", fileDetails.fileName);
    writer.writeStringValue("filePath", fileDetails.filePath);
    writer.writeStringValue("filePublisher", fileDetails.filePublisher);
    writer.writeNumberValue("fileSize", fileDetails.fileSize);
    writer.writeStringValue("issuer", fileDetails.issuer);
    writer.writeStringValue("@odata.type", fileDetails.odataType);
    writer.writeStringValue("sha1", fileDetails.sha1);
    writer.writeStringValue("sha256", fileDetails.sha256);
    writer.writeStringValue("signer", fileDetails.signer);
    writer.writeAdditionalData(fileDetails.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFileEvidence(writer: SerializationWriter, fileEvidence: Partial<FileEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, fileEvidence)
    writer.writeEnumValue<DetectionStatus>("detectionStatus", fileEvidence.detectionStatus);
    writer.writeObjectValue<FileDetails>("fileDetails", fileEvidence.fileDetails, serializeFileDetails);
    writer.writeStringValue("mdeDeviceId", fileEvidence.mdeDeviceId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFileHash(writer: SerializationWriter, fileHash: Partial<FileHash> | undefined = {}) : void {
    writer.writeEnumValue<FileHashAlgorithm>("algorithm", fileHash.algorithm);
    writer.writeStringValue("@odata.type", fileHash.odataType);
    writer.writeStringValue("value", fileHash.value);
    writer.writeAdditionalData(fileHash.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFileHashEvidence(writer: SerializationWriter, fileHashEvidence: Partial<FileHashEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, fileHashEvidence)
    writer.writeEnumValue<FileHashAlgorithm>("algorithm", fileHashEvidence.algorithm);
    writer.writeStringValue("value", fileHashEvidence.value);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFormattedContent(writer: SerializationWriter, formattedContent: Partial<FormattedContent> | undefined = {}) : void {
    writer.writeStringValue("content", formattedContent.content);
    writer.writeEnumValue<ContentFormat>("format", formattedContent.format);
    writer.writeStringValue("@odata.type", formattedContent.odataType);
    writer.writeAdditionalData(formattedContent.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeGitHubOrganizationEvidence(writer: SerializationWriter, gitHubOrganizationEvidence: Partial<GitHubOrganizationEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, gitHubOrganizationEvidence)
    writer.writeStringValue("company", gitHubOrganizationEvidence.company);
    writer.writeStringValue("displayName", gitHubOrganizationEvidence.displayName);
    writer.writeStringValue("email", gitHubOrganizationEvidence.email);
    writer.writeStringValue("login", gitHubOrganizationEvidence.login);
    writer.writeStringValue("orgId", gitHubOrganizationEvidence.orgId);
    writer.writeStringValue("webUrl", gitHubOrganizationEvidence.webUrl);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeGitHubRepoEvidence(writer: SerializationWriter, gitHubRepoEvidence: Partial<GitHubRepoEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, gitHubRepoEvidence)
    writer.writeStringValue("baseUrl", gitHubRepoEvidence.baseUrl);
    writer.writeStringValue("login", gitHubRepoEvidence.login);
    writer.writeStringValue("owner", gitHubRepoEvidence.owner);
    writer.writeStringValue("ownerType", gitHubRepoEvidence.ownerType);
    writer.writeStringValue("repoId", gitHubRepoEvidence.repoId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeGitHubUserEvidence(writer: SerializationWriter, gitHubUserEvidence: Partial<GitHubUserEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, gitHubUserEvidence)
    writer.writeStringValue("email", gitHubUserEvidence.email);
    writer.writeStringValue("login", gitHubUserEvidence.login);
    writer.writeStringValue("name", gitHubUserEvidence.name);
    writer.writeStringValue("userId", gitHubUserEvidence.userId);
    writer.writeStringValue("webUrl", gitHubUserEvidence.webUrl);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeGoogleCloudResourceEvidence(writer: SerializationWriter, googleCloudResourceEvidence: Partial<GoogleCloudResourceEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, googleCloudResourceEvidence)
    writer.writeStringValue("location", googleCloudResourceEvidence.location);
    writer.writeEnumValue<GoogleCloudLocationType>("locationType", googleCloudResourceEvidence.locationType);
    writer.writeStringValue("projectId", googleCloudResourceEvidence.projectId);
    writer.writeNumberValue("projectNumber", googleCloudResourceEvidence.projectNumber);
    writer.writeStringValue("resourceName", googleCloudResourceEvidence.resourceName);
    writer.writeStringValue("resourceType", googleCloudResourceEvidence.resourceType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHost(writer: SerializationWriter, host: Partial<Host> | undefined = {}) : void {
    serializeArtifact(writer, host)
    writer.writeCollectionOfObjectValues<HostPair>("childHostPairs", host.childHostPairs, serializeHostPair);
    writer.writeCollectionOfObjectValues<HostComponent>("components", host.components, serializeHostComponent);
    writer.writeCollectionOfObjectValues<HostCookie>("cookies", host.cookies, serializeHostCookie);
    writer.writeDateValue("firstSeenDateTime", host.firstSeenDateTime);
    writer.writeCollectionOfObjectValues<HostPair>("hostPairs", host.hostPairs, serializeHostPair);
    writer.writeDateValue("lastSeenDateTime", host.lastSeenDateTime);
    writer.writeCollectionOfObjectValues<HostPair>("parentHostPairs", host.parentHostPairs, serializeHostPair);
    writer.writeCollectionOfObjectValues<PassiveDnsRecord>("passiveDns", host.passiveDns, serializePassiveDnsRecord);
    writer.writeCollectionOfObjectValues<PassiveDnsRecord>("passiveDnsReverse", host.passiveDnsReverse, serializePassiveDnsRecord);
    writer.writeCollectionOfObjectValues<HostPort>("ports", host.ports, serializeHostPort);
    writer.writeObjectValue<HostReputation>("reputation", host.reputation, serializeHostReputation);
    writer.writeCollectionOfObjectValues<HostSslCertificate>("sslCertificates", host.sslCertificates, serializeHostSslCertificate);
    writer.writeCollectionOfObjectValues<Subdomain>("subdomains", host.subdomains, serializeSubdomain);
    writer.writeCollectionOfObjectValues<HostTracker>("trackers", host.trackers, serializeHostTracker);
    writer.writeObjectValue<WhoisRecord>("whois", host.whois, serializeWhoisRecord);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostCollectionResponse(writer: SerializationWriter, hostCollectionResponse: Partial<HostCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, hostCollectionResponse)
    writer.writeCollectionOfObjectValues<Host>("value", hostCollectionResponse.value, serializeHost);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostComponent(writer: SerializationWriter, hostComponent: Partial<HostComponent> | undefined = {}) : void {
    serializeArtifact(writer, hostComponent)
    writer.writeStringValue("category", hostComponent.category);
    writer.writeDateValue("firstSeenDateTime", hostComponent.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", hostComponent.host, serializeHost);
    writer.writeDateValue("lastSeenDateTime", hostComponent.lastSeenDateTime);
    writer.writeStringValue("name", hostComponent.name);
    writer.writeStringValue("version", hostComponent.version);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostComponentCollectionResponse(writer: SerializationWriter, hostComponentCollectionResponse: Partial<HostComponentCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, hostComponentCollectionResponse)
    writer.writeCollectionOfObjectValues<HostComponent>("value", hostComponentCollectionResponse.value, serializeHostComponent);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostCookie(writer: SerializationWriter, hostCookie: Partial<HostCookie> | undefined = {}) : void {
    serializeArtifact(writer, hostCookie)
    writer.writeStringValue("domain", hostCookie.domain);
    writer.writeDateValue("firstSeenDateTime", hostCookie.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", hostCookie.host, serializeHost);
    writer.writeDateValue("lastSeenDateTime", hostCookie.lastSeenDateTime);
    writer.writeStringValue("name", hostCookie.name);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostCookieCollectionResponse(writer: SerializationWriter, hostCookieCollectionResponse: Partial<HostCookieCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, hostCookieCollectionResponse)
    writer.writeCollectionOfObjectValues<HostCookie>("value", hostCookieCollectionResponse.value, serializeHostCookie);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostLogonSessionEvidence(writer: SerializationWriter, hostLogonSessionEvidence: Partial<HostLogonSessionEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, hostLogonSessionEvidence)
    writer.writeObjectValue<UserEvidence>("account", hostLogonSessionEvidence.account, serializeUserEvidence);
    writer.writeDateValue("endUtcDateTime", hostLogonSessionEvidence.endUtcDateTime);
    writer.writeObjectValue<DeviceEvidence>("host", hostLogonSessionEvidence.host, serializeDeviceEvidence);
    writer.writeStringValue("sessionId", hostLogonSessionEvidence.sessionId);
    writer.writeDateValue("startUtcDateTime", hostLogonSessionEvidence.startUtcDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostname(writer: SerializationWriter, hostname: Partial<Hostname> | undefined = {}) : void {
    serializeHost(writer, hostname)
    writer.writeStringValue("registrant", hostname.registrant);
    writer.writeStringValue("registrar", hostname.registrar);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostPair(writer: SerializationWriter, hostPair: Partial<HostPair> | undefined = {}) : void {
    serializeEntity(writer, hostPair)
    writer.writeObjectValue<Host>("childHost", hostPair.childHost, serializeHost);
    writer.writeDateValue("firstSeenDateTime", hostPair.firstSeenDateTime);
    writer.writeDateValue("lastSeenDateTime", hostPair.lastSeenDateTime);
    writer.writeStringValue("linkKind", hostPair.linkKind);
    writer.writeObjectValue<Host>("parentHost", hostPair.parentHost, serializeHost);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostPairCollectionResponse(writer: SerializationWriter, hostPairCollectionResponse: Partial<HostPairCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, hostPairCollectionResponse)
    writer.writeCollectionOfObjectValues<HostPair>("value", hostPairCollectionResponse.value, serializeHostPair);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostPort(writer: SerializationWriter, hostPort: Partial<HostPort> | undefined = {}) : void {
    serializeEntity(writer, hostPort)
    writer.writeCollectionOfObjectValues<HostPortBanner>("banners", hostPort.banners, serializeHostPortBanner);
    writer.writeDateValue("firstSeenDateTime", hostPort.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", hostPort.host, serializeHost);
    writer.writeDateValue("lastScanDateTime", hostPort.lastScanDateTime);
    writer.writeDateValue("lastSeenDateTime", hostPort.lastSeenDateTime);
    writer.writeObjectValue<SslCertificate>("mostRecentSslCertificate", hostPort.mostRecentSslCertificate, serializeSslCertificate);
    writer.writeNumberValue("port", hostPort.port);
    writer.writeEnumValue<HostPortProtocol>("protocol", hostPort.protocol);
    writer.writeCollectionOfObjectValues<HostPortComponent>("services", hostPort.services, serializeHostPortComponent);
    writer.writeEnumValue<HostPortStatus>("status", hostPort.status);
    writer.writeNumberValue("timesObserved", hostPort.timesObserved);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostPortBanner(writer: SerializationWriter, hostPortBanner: Partial<HostPortBanner> | undefined = {}) : void {
    writer.writeStringValue("banner", hostPortBanner.banner);
    writer.writeDateValue("firstSeenDateTime", hostPortBanner.firstSeenDateTime);
    writer.writeDateValue("lastSeenDateTime", hostPortBanner.lastSeenDateTime);
    writer.writeStringValue("@odata.type", hostPortBanner.odataType);
    writer.writeStringValue("scanProtocol", hostPortBanner.scanProtocol);
    writer.writeNumberValue("timesObserved", hostPortBanner.timesObserved);
    writer.writeAdditionalData(hostPortBanner.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostPortCollectionResponse(writer: SerializationWriter, hostPortCollectionResponse: Partial<HostPortCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, hostPortCollectionResponse)
    writer.writeCollectionOfObjectValues<HostPort>("value", hostPortCollectionResponse.value, serializeHostPort);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostPortComponent(writer: SerializationWriter, hostPortComponent: Partial<HostPortComponent> | undefined = {}) : void {
    writer.writeObjectValue<HostComponent>("component", hostPortComponent.component, serializeHostComponent);
    writer.writeDateValue("firstSeenDateTime", hostPortComponent.firstSeenDateTime);
    writer.writeBooleanValue("isRecent", hostPortComponent.isRecent);
    writer.writeDateValue("lastSeenDateTime", hostPortComponent.lastSeenDateTime);
    writer.writeStringValue("@odata.type", hostPortComponent.odataType);
    writer.writeAdditionalData(hostPortComponent.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostReputation(writer: SerializationWriter, hostReputation: Partial<HostReputation> | undefined = {}) : void {
    serializeEntity(writer, hostReputation)
    writer.writeEnumValue<HostReputationClassification>("classification", hostReputation.classification);
    writer.writeCollectionOfObjectValues<HostReputationRule>("rules", hostReputation.rules, serializeHostReputationRule);
    writer.writeNumberValue("score", hostReputation.score);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostReputationRule(writer: SerializationWriter, hostReputationRule: Partial<HostReputationRule> | undefined = {}) : void {
    writer.writeStringValue("description", hostReputationRule.description);
    writer.writeStringValue("name", hostReputationRule.name);
    writer.writeStringValue("@odata.type", hostReputationRule.odataType);
    writer.writeStringValue("relatedDetailsUrl", hostReputationRule.relatedDetailsUrl);
    writer.writeEnumValue<HostReputationRuleSeverity>("severity", hostReputationRule.severity);
    writer.writeAdditionalData(hostReputationRule.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostSslCertificate(writer: SerializationWriter, hostSslCertificate: Partial<HostSslCertificate> | undefined = {}) : void {
    serializeArtifact(writer, hostSslCertificate)
    writer.writeDateValue("firstSeenDateTime", hostSslCertificate.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", hostSslCertificate.host, serializeHost);
    writer.writeDateValue("lastSeenDateTime", hostSslCertificate.lastSeenDateTime);
    writer.writeCollectionOfObjectValues<HostSslCertificatePort>("ports", hostSslCertificate.ports, serializeHostSslCertificatePort);
    writer.writeObjectValue<SslCertificate>("sslCertificate", hostSslCertificate.sslCertificate, serializeSslCertificate);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostSslCertificateCollectionResponse(writer: SerializationWriter, hostSslCertificateCollectionResponse: Partial<HostSslCertificateCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, hostSslCertificateCollectionResponse)
    writer.writeCollectionOfObjectValues<HostSslCertificate>("value", hostSslCertificateCollectionResponse.value, serializeHostSslCertificate);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostSslCertificatePort(writer: SerializationWriter, hostSslCertificatePort: Partial<HostSslCertificatePort> | undefined = {}) : void {
    writer.writeDateValue("firstSeenDateTime", hostSslCertificatePort.firstSeenDateTime);
    writer.writeDateValue("lastSeenDateTime", hostSslCertificatePort.lastSeenDateTime);
    writer.writeStringValue("@odata.type", hostSslCertificatePort.odataType);
    writer.writeNumberValue("port", hostSslCertificatePort.port);
    writer.writeAdditionalData(hostSslCertificatePort.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostTracker(writer: SerializationWriter, hostTracker: Partial<HostTracker> | undefined = {}) : void {
    serializeArtifact(writer, hostTracker)
    writer.writeDateValue("firstSeenDateTime", hostTracker.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", hostTracker.host, serializeHost);
    writer.writeStringValue("kind", hostTracker.kind);
    writer.writeDateValue("lastSeenDateTime", hostTracker.lastSeenDateTime);
    writer.writeStringValue("value", hostTracker.value);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHostTrackerCollectionResponse(writer: SerializationWriter, hostTrackerCollectionResponse: Partial<HostTrackerCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, hostTrackerCollectionResponse)
    writer.writeCollectionOfObjectValues<HostTracker>("value", hostTrackerCollectionResponse.value, serializeHostTracker);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHuntingQueryResults(writer: SerializationWriter, huntingQueryResults: Partial<HuntingQueryResults> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", huntingQueryResults.odataType);
    writer.writeCollectionOfObjectValues<HuntingRowResult>("results", huntingQueryResults.results, serializeHuntingRowResult);
    writer.writeCollectionOfObjectValues<SinglePropertySchema>("schema", huntingQueryResults.schema, serializeSinglePropertySchema);
    writer.writeAdditionalData(huntingQueryResults.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHuntingRowResult(writer: SerializationWriter, huntingRowResult: Partial<HuntingRowResult> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", huntingRowResult.odataType);
    writer.writeAdditionalData(huntingRowResult.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeHyperlink(writer: SerializationWriter, hyperlink: Partial<Hyperlink> | undefined = {}) : void {
    writer.writeStringValue("name", hyperlink.name);
    writer.writeStringValue("@odata.type", hyperlink.odataType);
    writer.writeStringValue("url", hyperlink.url);
    writer.writeAdditionalData(hyperlink.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIncident(writer: SerializationWriter, incident: Partial<Incident> | undefined = {}) : void {
    serializeEntity(writer, incident)
    writer.writeCollectionOfObjectValues<Alert>("alerts", incident.alerts, serializeAlert);
    writer.writeStringValue("assignedTo", incident.assignedTo);
    writer.writeEnumValue<AlertClassification>("classification", incident.classification);
    writer.writeCollectionOfObjectValues<AlertComment>("comments", incident.comments, serializeAlertComment);
    writer.writeDateValue("createdDateTime", incident.createdDateTime);
    writer.writeCollectionOfPrimitiveValues<string>("customTags", incident.customTags);
    writer.writeStringValue("description", incident.description);
    writer.writeEnumValue<AlertDetermination>("determination", incident.determination);
    writer.writeStringValue("displayName", incident.displayName);
    writer.writeStringValue("incidentWebUrl", incident.incidentWebUrl);
    writer.writeStringValue("lastModifiedBy", incident.lastModifiedBy);
    writer.writeDateValue("lastUpdateDateTime", incident.lastUpdateDateTime);
    writer.writeStringValue("redirectIncidentId", incident.redirectIncidentId);
    writer.writeEnumValue<AlertSeverity>("severity", incident.severity);
    writer.writeEnumValue<IncidentStatus>("status", incident.status);
    writer.writeCollectionOfPrimitiveValues<string>("systemTags", incident.systemTags);
    writer.writeStringValue("tenantId", incident.tenantId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIncidentCollectionResponse(writer: SerializationWriter, incidentCollectionResponse: Partial<IncidentCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, incidentCollectionResponse)
    writer.writeCollectionOfObjectValues<Incident>("value", incidentCollectionResponse.value, serializeIncident);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIndicator(writer: SerializationWriter, indicator: Partial<Indicator> | undefined = {}) : void {
    serializeEntity(writer, indicator)
    writer.writeObjectValue<Artifact>("artifact", indicator.artifact, serializeArtifact);
    writer.writeEnumValue<IndicatorSource>("source", indicator.source);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIntelligenceProfile(writer: SerializationWriter, intelligenceProfile: Partial<IntelligenceProfile> | undefined = {}) : void {
    serializeEntity(writer, intelligenceProfile)
    writer.writeCollectionOfPrimitiveValues<string>("aliases", intelligenceProfile.aliases);
    writer.writeCollectionOfObjectValues<IntelligenceProfileCountryOrRegionOfOrigin>("countriesOrRegionsOfOrigin", intelligenceProfile.countriesOrRegionsOfOrigin, serializeIntelligenceProfileCountryOrRegionOfOrigin);
    writer.writeObjectValue<FormattedContent>("description", intelligenceProfile.description, serializeFormattedContent);
    writer.writeDateValue("firstActiveDateTime", intelligenceProfile.firstActiveDateTime);
    writer.writeCollectionOfObjectValues<IntelligenceProfileIndicator>("indicators", intelligenceProfile.indicators, serializeIntelligenceProfileIndicator);
    writer.writeEnumValue<IntelligenceProfileKind>("kind", intelligenceProfile.kind);
    writer.writeObjectValue<FormattedContent>("summary", intelligenceProfile.summary, serializeFormattedContent);
    writer.writeCollectionOfPrimitiveValues<string>("targets", intelligenceProfile.targets);
    writer.writeStringValue("title", intelligenceProfile.title);
    writer.writeObjectValue<FormattedContent>("tradecraft", intelligenceProfile.tradecraft, serializeFormattedContent);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIntelligenceProfileCollectionResponse(writer: SerializationWriter, intelligenceProfileCollectionResponse: Partial<IntelligenceProfileCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, intelligenceProfileCollectionResponse)
    writer.writeCollectionOfObjectValues<IntelligenceProfile>("value", intelligenceProfileCollectionResponse.value, serializeIntelligenceProfile);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIntelligenceProfileCountryOrRegionOfOrigin(writer: SerializationWriter, intelligenceProfileCountryOrRegionOfOrigin: Partial<IntelligenceProfileCountryOrRegionOfOrigin> | undefined = {}) : void {
    writer.writeStringValue("code", intelligenceProfileCountryOrRegionOfOrigin.code);
    writer.writeStringValue("label", intelligenceProfileCountryOrRegionOfOrigin.label);
    writer.writeStringValue("@odata.type", intelligenceProfileCountryOrRegionOfOrigin.odataType);
    writer.writeAdditionalData(intelligenceProfileCountryOrRegionOfOrigin.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIntelligenceProfileIndicator(writer: SerializationWriter, intelligenceProfileIndicator: Partial<IntelligenceProfileIndicator> | undefined = {}) : void {
    serializeIndicator(writer, intelligenceProfileIndicator)
    writer.writeDateValue("firstSeenDateTime", intelligenceProfileIndicator.firstSeenDateTime);
    writer.writeDateValue("lastSeenDateTime", intelligenceProfileIndicator.lastSeenDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIntelligenceProfileIndicatorCollectionResponse(writer: SerializationWriter, intelligenceProfileIndicatorCollectionResponse: Partial<IntelligenceProfileIndicatorCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, intelligenceProfileIndicatorCollectionResponse)
    writer.writeCollectionOfObjectValues<IntelligenceProfileIndicator>("value", intelligenceProfileIndicatorCollectionResponse.value, serializeIntelligenceProfileIndicator);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIoTDeviceEvidence(writer: SerializationWriter, ioTDeviceEvidence: Partial<IoTDeviceEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, ioTDeviceEvidence)
    writer.writeStringValue("deviceId", ioTDeviceEvidence.deviceId);
    writer.writeStringValue("deviceName", ioTDeviceEvidence.deviceName);
    writer.writeStringValue("devicePageLink", ioTDeviceEvidence.devicePageLink);
    writer.writeStringValue("deviceSubType", ioTDeviceEvidence.deviceSubType);
    writer.writeStringValue("deviceType", ioTDeviceEvidence.deviceType);
    writer.writeEnumValue<IoTDeviceImportanceType>("importance", ioTDeviceEvidence.importance);
    writer.writeObjectValue<AzureResourceEvidence>("ioTHub", ioTDeviceEvidence.ioTHub, serializeAzureResourceEvidence);
    writer.writeStringValue("ioTSecurityAgentId", ioTDeviceEvidence.ioTSecurityAgentId);
    writer.writeObjectValue<IpEvidence>("ipAddress", ioTDeviceEvidence.ipAddress, serializeIpEvidence);
    writer.writeBooleanValue("isAuthorized", ioTDeviceEvidence.isAuthorized);
    writer.writeBooleanValue("isProgramming", ioTDeviceEvidence.isProgramming);
    writer.writeBooleanValue("isScanner", ioTDeviceEvidence.isScanner);
    writer.writeStringValue("macAddress", ioTDeviceEvidence.macAddress);
    writer.writeStringValue("manufacturer", ioTDeviceEvidence.manufacturer);
    writer.writeStringValue("model", ioTDeviceEvidence.model);
    writer.writeObjectValue<NicEvidence>("nics", ioTDeviceEvidence.nics, serializeNicEvidence);
    writer.writeStringValue("operatingSystem", ioTDeviceEvidence.operatingSystem);
    writer.writeCollectionOfPrimitiveValues<string>("owners", ioTDeviceEvidence.owners);
    writer.writeCollectionOfPrimitiveValues<string>("protocols", ioTDeviceEvidence.protocols);
    writer.writeStringValue("purdueLayer", ioTDeviceEvidence.purdueLayer);
    writer.writeStringValue("sensor", ioTDeviceEvidence.sensor);
    writer.writeStringValue("serialNumber", ioTDeviceEvidence.serialNumber);
    writer.writeStringValue("site", ioTDeviceEvidence.site);
    writer.writeStringValue("source", ioTDeviceEvidence.source);
    writer.writeObjectValue<UrlEvidence>("sourceRef", ioTDeviceEvidence.sourceRef, serializeUrlEvidence);
    writer.writeStringValue("zone", ioTDeviceEvidence.zone);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIpAddress(writer: SerializationWriter, ipAddress: Partial<IpAddress> | undefined = {}) : void {
    serializeHost(writer, ipAddress)
    writer.writeObjectValue<AutonomousSystem>("autonomousSystem", ipAddress.autonomousSystem, serializeAutonomousSystem);
    writer.writeStringValue("countryOrRegion", ipAddress.countryOrRegion);
    writer.writeStringValue("hostingProvider", ipAddress.hostingProvider);
    writer.writeStringValue("netblock", ipAddress.netblock);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIpEvidence(writer: SerializationWriter, ipEvidence: Partial<IpEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, ipEvidence)
    writer.writeStringValue("countryLetterCode", ipEvidence.countryLetterCode);
    writer.writeStringValue("ipAddress", ipEvidence.ipAddress);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesClusterEvidence(writer: SerializationWriter, kubernetesClusterEvidence: Partial<KubernetesClusterEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, kubernetesClusterEvidence)
    writer.writeObjectValue<AlertEvidence>("cloudResource", kubernetesClusterEvidence.cloudResource, serializeAlertEvidence);
    writer.writeStringValue("distribution", kubernetesClusterEvidence.distribution);
    writer.writeStringValue("name", kubernetesClusterEvidence.name);
    writer.writeEnumValue<KubernetesPlatform>("platform", kubernetesClusterEvidence.platform);
    writer.writeStringValue("version", kubernetesClusterEvidence.version);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesControllerEvidence(writer: SerializationWriter, kubernetesControllerEvidence: Partial<KubernetesControllerEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, kubernetesControllerEvidence)
    writer.writeObjectValue<Dictionary>("labels", kubernetesControllerEvidence.labels, serializeDictionary);
    writer.writeStringValue("name", kubernetesControllerEvidence.name);
    writer.writeObjectValue<KubernetesNamespaceEvidence>("namespace", kubernetesControllerEvidence.namespace, serializeKubernetesNamespaceEvidence);
    writer.writeStringValue("type", kubernetesControllerEvidence.type);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesNamespaceEvidence(writer: SerializationWriter, kubernetesNamespaceEvidence: Partial<KubernetesNamespaceEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, kubernetesNamespaceEvidence)
    writer.writeObjectValue<KubernetesClusterEvidence>("cluster", kubernetesNamespaceEvidence.cluster, serializeKubernetesClusterEvidence);
    writer.writeObjectValue<Dictionary>("labels", kubernetesNamespaceEvidence.labels, serializeDictionary);
    writer.writeStringValue("name", kubernetesNamespaceEvidence.name);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesPodEvidence(writer: SerializationWriter, kubernetesPodEvidence: Partial<KubernetesPodEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, kubernetesPodEvidence)
    writer.writeCollectionOfObjectValues<ContainerEvidence>("containers", kubernetesPodEvidence.containers, serializeContainerEvidence);
    writer.writeObjectValue<KubernetesControllerEvidence>("controller", kubernetesPodEvidence.controller, serializeKubernetesControllerEvidence);
    writer.writeCollectionOfObjectValues<ContainerEvidence>("ephemeralContainers", kubernetesPodEvidence.ephemeralContainers, serializeContainerEvidence);
    writer.writeCollectionOfObjectValues<ContainerEvidence>("initContainers", kubernetesPodEvidence.initContainers, serializeContainerEvidence);
    writer.writeObjectValue<Dictionary>("labels", kubernetesPodEvidence.labels, serializeDictionary);
    writer.writeStringValue("name", kubernetesPodEvidence.name);
    writer.writeObjectValue<KubernetesNamespaceEvidence>("namespace", kubernetesPodEvidence.namespace, serializeKubernetesNamespaceEvidence);
    writer.writeObjectValue<IpEvidence>("podIp", kubernetesPodEvidence.podIp, serializeIpEvidence);
    writer.writeObjectValue<KubernetesServiceAccountEvidence>("serviceAccount", kubernetesPodEvidence.serviceAccount, serializeKubernetesServiceAccountEvidence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesSecretEvidence(writer: SerializationWriter, kubernetesSecretEvidence: Partial<KubernetesSecretEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, kubernetesSecretEvidence)
    writer.writeStringValue("name", kubernetesSecretEvidence.name);
    writer.writeObjectValue<KubernetesNamespaceEvidence>("namespace", kubernetesSecretEvidence.namespace, serializeKubernetesNamespaceEvidence);
    writer.writeStringValue("secretType", kubernetesSecretEvidence.secretType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesServiceAccountEvidence(writer: SerializationWriter, kubernetesServiceAccountEvidence: Partial<KubernetesServiceAccountEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, kubernetesServiceAccountEvidence)
    writer.writeStringValue("name", kubernetesServiceAccountEvidence.name);
    writer.writeObjectValue<KubernetesNamespaceEvidence>("namespace", kubernetesServiceAccountEvidence.namespace, serializeKubernetesNamespaceEvidence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesServiceEvidence(writer: SerializationWriter, kubernetesServiceEvidence: Partial<KubernetesServiceEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, kubernetesServiceEvidence)
    writer.writeObjectValue<IpEvidence>("clusterIP", kubernetesServiceEvidence.clusterIP, serializeIpEvidence);
    writer.writeCollectionOfObjectValues<IpEvidence>("externalIPs", kubernetesServiceEvidence.externalIPs, serializeIpEvidence);
    writer.writeObjectValue<Dictionary>("labels", kubernetesServiceEvidence.labels, serializeDictionary);
    writer.writeStringValue("name", kubernetesServiceEvidence.name);
    writer.writeObjectValue<KubernetesNamespaceEvidence>("namespace", kubernetesServiceEvidence.namespace, serializeKubernetesNamespaceEvidence);
    writer.writeObjectValue<Dictionary>("selector", kubernetesServiceEvidence.selector, serializeDictionary);
    writer.writeCollectionOfObjectValues<KubernetesServicePort>("servicePorts", kubernetesServiceEvidence.servicePorts, serializeKubernetesServicePort);
    writer.writeEnumValue<KubernetesServiceType>("serviceType", kubernetesServiceEvidence.serviceType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeKubernetesServicePort(writer: SerializationWriter, kubernetesServicePort: Partial<KubernetesServicePort> | undefined = {}) : void {
    writer.writeStringValue("appProtocol", kubernetesServicePort.appProtocol);
    writer.writeStringValue("name", kubernetesServicePort.name);
    writer.writeNumberValue("nodePort", kubernetesServicePort.nodePort);
    writer.writeStringValue("@odata.type", kubernetesServicePort.odataType);
    writer.writeNumberValue("port", kubernetesServicePort.port);
    writer.writeEnumValue<ContainerPortProtocol>("protocol", kubernetesServicePort.protocol);
    writer.writeStringValue("targetPort", kubernetesServicePort.targetPort);
    writer.writeAdditionalData(kubernetesServicePort.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeLoggedOnUser(writer: SerializationWriter, loggedOnUser: Partial<LoggedOnUser> | undefined = {}) : void {
    writer.writeStringValue("accountName", loggedOnUser.accountName);
    writer.writeStringValue("domainName", loggedOnUser.domainName);
    writer.writeStringValue("@odata.type", loggedOnUser.odataType);
    writer.writeAdditionalData(loggedOnUser.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMailboxEvidence(writer: SerializationWriter, mailboxEvidence: Partial<MailboxEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, mailboxEvidence)
    writer.writeStringValue("displayName", mailboxEvidence.displayName);
    writer.writeStringValue("primaryAddress", mailboxEvidence.primaryAddress);
    writer.writeObjectValue<UserAccount>("userAccount", mailboxEvidence.userAccount, serializeUserAccount);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMailClusterEvidence(writer: SerializationWriter, mailClusterEvidence: Partial<MailClusterEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, mailClusterEvidence)
    writer.writeStringValue("clusterBy", mailClusterEvidence.clusterBy);
    writer.writeStringValue("clusterByValue", mailClusterEvidence.clusterByValue);
    writer.writeNumberValue("emailCount", mailClusterEvidence.emailCount);
    writer.writeCollectionOfPrimitiveValues<string>("networkMessageIds", mailClusterEvidence.networkMessageIds);
    writer.writeStringValue("query", mailClusterEvidence.query);
    writer.writeStringValue("urn", mailClusterEvidence.urn);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMalwareEvidence(writer: SerializationWriter, malwareEvidence: Partial<MalwareEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, malwareEvidence)
    writer.writeStringValue("category", malwareEvidence.category);
    writer.writeCollectionOfObjectValues<FileEvidence>("files", malwareEvidence.files, serializeFileEvidence);
    writer.writeStringValue("name", malwareEvidence.name);
    writer.writeCollectionOfObjectValues<ProcessEvidence>("processes", malwareEvidence.processes, serializeProcessEvidence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeNetworkConnectionEvidence(writer: SerializationWriter, networkConnectionEvidence: Partial<NetworkConnectionEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, networkConnectionEvidence)
    writer.writeObjectValue<IpEvidence>("destinationAddress", networkConnectionEvidence.destinationAddress, serializeIpEvidence);
    writer.writeNumberValue("destinationPort", networkConnectionEvidence.destinationPort);
    writer.writeEnumValue<ProtocolType>("protocol", networkConnectionEvidence.protocol);
    writer.writeObjectValue<IpEvidence>("sourceAddress", networkConnectionEvidence.sourceAddress, serializeIpEvidence);
    writer.writeNumberValue("sourcePort", networkConnectionEvidence.sourcePort);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeNicEvidence(writer: SerializationWriter, nicEvidence: Partial<NicEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, nicEvidence)
    writer.writeObjectValue<IpEvidence>("ipAddress", nicEvidence.ipAddress, serializeIpEvidence);
    writer.writeStringValue("macAddress", nicEvidence.macAddress);
    writer.writeCollectionOfPrimitiveValues<string>("vlans", nicEvidence.vlans);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeOauthApplicationEvidence(writer: SerializationWriter, oauthApplicationEvidence: Partial<OauthApplicationEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, oauthApplicationEvidence)
    writer.writeStringValue("appId", oauthApplicationEvidence.appId);
    writer.writeStringValue("displayName", oauthApplicationEvidence.displayName);
    writer.writeStringValue("objectId", oauthApplicationEvidence.objectId);
    writer.writeStringValue("publisher", oauthApplicationEvidence.publisher);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeOcrSettings(writer: SerializationWriter, ocrSettings: Partial<OcrSettings> | undefined = {}) : void {
    writer.writeBooleanValue("isEnabled", ocrSettings.isEnabled);
    writer.writeNumberValue("maxImageSize", ocrSettings.maxImageSize);
    writer.writeStringValue("@odata.type", ocrSettings.odataType);
    writer.writeDurationValue("timeout", ocrSettings.timeout);
    writer.writeAdditionalData(ocrSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializePassiveDnsRecord(writer: SerializationWriter, passiveDnsRecord: Partial<PassiveDnsRecord> | undefined = {}) : void {
    serializeArtifact(writer, passiveDnsRecord)
    writer.writeObjectValue<Artifact>("artifact", passiveDnsRecord.artifact, serializeArtifact);
    writer.writeDateValue("collectedDateTime", passiveDnsRecord.collectedDateTime);
    writer.writeDateValue("firstSeenDateTime", passiveDnsRecord.firstSeenDateTime);
    writer.writeDateValue("lastSeenDateTime", passiveDnsRecord.lastSeenDateTime);
    writer.writeObjectValue<Host>("parentHost", passiveDnsRecord.parentHost, serializeHost);
    writer.writeStringValue("recordType", passiveDnsRecord.recordType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializePassiveDnsRecordCollectionResponse(writer: SerializationWriter, passiveDnsRecordCollectionResponse: Partial<PassiveDnsRecordCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, passiveDnsRecordCollectionResponse)
    writer.writeCollectionOfObjectValues<PassiveDnsRecord>("value", passiveDnsRecordCollectionResponse.value, serializePassiveDnsRecord);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProcessEvidence(writer: SerializationWriter, processEvidence: Partial<ProcessEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, processEvidence)
    writer.writeEnumValue<DetectionStatus>("detectionStatus", processEvidence.detectionStatus);
    writer.writeObjectValue<FileDetails>("imageFile", processEvidence.imageFile, serializeFileDetails);
    writer.writeStringValue("mdeDeviceId", processEvidence.mdeDeviceId);
    writer.writeDateValue("parentProcessCreationDateTime", processEvidence.parentProcessCreationDateTime);
    writer.writeNumberValue("parentProcessId", processEvidence.parentProcessId);
    writer.writeObjectValue<FileDetails>("parentProcessImageFile", processEvidence.parentProcessImageFile, serializeFileDetails);
    writer.writeStringValue("processCommandLine", processEvidence.processCommandLine);
    writer.writeDateValue("processCreationDateTime", processEvidence.processCreationDateTime);
    writer.writeNumberValue("processId", processEvidence.processId);
    writer.writeObjectValue<UserAccount>("userAccount", processEvidence.userAccount, serializeUserAccount);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRedundancyDetectionSettings(writer: SerializationWriter, redundancyDetectionSettings: Partial<RedundancyDetectionSettings> | undefined = {}) : void {
    writer.writeBooleanValue("isEnabled", redundancyDetectionSettings.isEnabled);
    writer.writeNumberValue("maxWords", redundancyDetectionSettings.maxWords);
    writer.writeNumberValue("minWords", redundancyDetectionSettings.minWords);
    writer.writeStringValue("@odata.type", redundancyDetectionSettings.odataType);
    writer.writeNumberValue("similarityThreshold", redundancyDetectionSettings.similarityThreshold);
    writer.writeAdditionalData(redundancyDetectionSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRegistryKeyEvidence(writer: SerializationWriter, registryKeyEvidence: Partial<RegistryKeyEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, registryKeyEvidence)
    writer.writeStringValue("registryHive", registryKeyEvidence.registryHive);
    writer.writeStringValue("registryKey", registryKeyEvidence.registryKey);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRegistryValueEvidence(writer: SerializationWriter, registryValueEvidence: Partial<RegistryValueEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, registryValueEvidence)
    writer.writeStringValue("mdeDeviceId", registryValueEvidence.mdeDeviceId);
    writer.writeStringValue("registryHive", registryValueEvidence.registryHive);
    writer.writeStringValue("registryKey", registryValueEvidence.registryKey);
    writer.writeStringValue("registryValue", registryValueEvidence.registryValue);
    writer.writeStringValue("registryValueName", registryValueEvidence.registryValueName);
    writer.writeStringValue("registryValueType", registryValueEvidence.registryValueType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRetentionEvent(writer: SerializationWriter, retentionEvent: Partial<RetentionEvent> | undefined = {}) : void {
    serializeEntity(writer, retentionEvent)
    writer.writeObjectValue<IdentitySet>("createdBy", retentionEvent.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", retentionEvent.createdDateTime);
    writer.writeStringValue("description", retentionEvent.description);
    writer.writeStringValue("displayName", retentionEvent.displayName);
    writer.writeCollectionOfObjectValues<EventPropagationResult>("eventPropagationResults", retentionEvent.eventPropagationResults, serializeEventPropagationResult);
    writer.writeCollectionOfObjectValues<EventQuery>("eventQueries", retentionEvent.eventQueries, serializeEventQuery);
    writer.writeObjectValue<RetentionEventStatus>("eventStatus", retentionEvent.eventStatus, serializeRetentionEventStatus);
    writer.writeDateValue("eventTriggerDateTime", retentionEvent.eventTriggerDateTime);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", retentionEvent.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", retentionEvent.lastModifiedDateTime);
    writer.writeDateValue("lastStatusUpdateDateTime", retentionEvent.lastStatusUpdateDateTime);
    writer.writeObjectValue<RetentionEventType>("retentionEventType", retentionEvent.retentionEventType, serializeRetentionEventType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRetentionEventCollectionResponse(writer: SerializationWriter, retentionEventCollectionResponse: Partial<RetentionEventCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, retentionEventCollectionResponse)
    writer.writeCollectionOfObjectValues<RetentionEvent>("value", retentionEventCollectionResponse.value, serializeRetentionEvent);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRetentionEventStatus(writer: SerializationWriter, retentionEventStatus: Partial<RetentionEventStatus> | undefined = {}) : void {
    writer.writeObjectValue<PublicError>("error", retentionEventStatus.errorEscaped, serializePublicError);
    writer.writeStringValue("@odata.type", retentionEventStatus.odataType);
    writer.writeEnumValue<EventStatusType>("status", retentionEventStatus.status);
    writer.writeAdditionalData(retentionEventStatus.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRetentionEventType(writer: SerializationWriter, retentionEventType: Partial<RetentionEventType> | undefined = {}) : void {
    serializeEntity(writer, retentionEventType)
    writer.writeObjectValue<IdentitySet>("createdBy", retentionEventType.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", retentionEventType.createdDateTime);
    writer.writeStringValue("description", retentionEventType.description);
    writer.writeStringValue("displayName", retentionEventType.displayName);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", retentionEventType.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", retentionEventType.lastModifiedDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRetentionEventTypeCollectionResponse(writer: SerializationWriter, retentionEventTypeCollectionResponse: Partial<RetentionEventTypeCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, retentionEventTypeCollectionResponse)
    writer.writeCollectionOfObjectValues<RetentionEventType>("value", retentionEventTypeCollectionResponse.value, serializeRetentionEventType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSasTokenEvidence(writer: SerializationWriter, sasTokenEvidence: Partial<SasTokenEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, sasTokenEvidence)
    writer.writeStringValue("allowedIpAddresses", sasTokenEvidence.allowedIpAddresses);
    writer.writeCollectionOfPrimitiveValues<string>("allowedResourceTypes", sasTokenEvidence.allowedResourceTypes);
    writer.writeCollectionOfPrimitiveValues<string>("allowedServices", sasTokenEvidence.allowedServices);
    writer.writeDateValue("expiryDateTime", sasTokenEvidence.expiryDateTime);
    writer.writeCollectionOfPrimitiveValues<string>("permissions", sasTokenEvidence.permissions);
    writer.writeStringValue("protocol", sasTokenEvidence.protocol);
    writer.writeStringValue("signatureHash", sasTokenEvidence.signatureHash);
    writer.writeStringValue("signedWith", sasTokenEvidence.signedWith);
    writer.writeDateValue("startDateTime", sasTokenEvidence.startDateTime);
    writer.writeObjectValue<AzureResourceEvidence>("storageResource", sasTokenEvidence.storageResource, serializeAzureResourceEvidence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSearch(writer: SerializationWriter, search: Partial<Search> | undefined = {}) : void {
    serializeEntity(writer, search)
    writer.writeStringValue("contentQuery", search.contentQuery);
    writer.writeObjectValue<IdentitySet>("createdBy", search.createdBy, serializeIdentitySet);
    writer.writeDateValue("createdDateTime", search.createdDateTime);
    writer.writeStringValue("description", search.description);
    writer.writeStringValue("displayName", search.displayName);
    writer.writeObjectValue<IdentitySet>("lastModifiedBy", search.lastModifiedBy, serializeIdentitySet);
    writer.writeDateValue("lastModifiedDateTime", search.lastModifiedDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSecurityGroupEvidence(writer: SerializationWriter, securityGroupEvidence: Partial<SecurityGroupEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, securityGroupEvidence)
    writer.writeStringValue("displayName", securityGroupEvidence.displayName);
    writer.writeStringValue("securityGroupId", securityGroupEvidence.securityGroupId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeServicePrincipalEvidence(writer: SerializationWriter, servicePrincipalEvidence: Partial<ServicePrincipalEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, servicePrincipalEvidence)
    writer.writeStringValue("appId", servicePrincipalEvidence.appId);
    writer.writeStringValue("appOwnerTenantId", servicePrincipalEvidence.appOwnerTenantId);
    writer.writeStringValue("servicePrincipalName", servicePrincipalEvidence.servicePrincipalName);
    writer.writeStringValue("servicePrincipalObjectId", servicePrincipalEvidence.servicePrincipalObjectId);
    writer.writeEnumValue<ServicePrincipalType>("servicePrincipalType", servicePrincipalEvidence.servicePrincipalType);
    writer.writeStringValue("tenantId", servicePrincipalEvidence.tenantId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSinglePropertySchema(writer: SerializationWriter, singlePropertySchema: Partial<SinglePropertySchema> | undefined = {}) : void {
    writer.writeStringValue("name", singlePropertySchema.name);
    writer.writeStringValue("@odata.type", singlePropertySchema.odataType);
    writer.writeStringValue("type", singlePropertySchema.type);
    writer.writeAdditionalData(singlePropertySchema.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSiteSource(writer: SerializationWriter, siteSource: Partial<SiteSource> | undefined = {}) : void {
    serializeDataSource(writer, siteSource)
    writer.writeObjectValue<Site>("site", siteSource.site, serializeSite);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSiteSourceCollectionResponse(writer: SerializationWriter, siteSourceCollectionResponse: Partial<SiteSourceCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, siteSourceCollectionResponse)
    writer.writeCollectionOfObjectValues<SiteSource>("value", siteSourceCollectionResponse.value, serializeSiteSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSslCertificate(writer: SerializationWriter, sslCertificate: Partial<SslCertificate> | undefined = {}) : void {
    serializeArtifact(writer, sslCertificate)
    writer.writeDateValue("expirationDateTime", sslCertificate.expirationDateTime);
    writer.writeStringValue("fingerprint", sslCertificate.fingerprint);
    writer.writeDateValue("firstSeenDateTime", sslCertificate.firstSeenDateTime);
    writer.writeDateValue("issueDateTime", sslCertificate.issueDateTime);
    writer.writeObjectValue<SslCertificateEntity>("issuer", sslCertificate.issuer, serializeSslCertificateEntity);
    writer.writeDateValue("lastSeenDateTime", sslCertificate.lastSeenDateTime);
    writer.writeCollectionOfObjectValues<Host>("relatedHosts", sslCertificate.relatedHosts, serializeHost);
    writer.writeStringValue("serialNumber", sslCertificate.serialNumber);
    writer.writeStringValue("sha1", sslCertificate.sha1);
    writer.writeObjectValue<SslCertificateEntity>("subject", sslCertificate.subject, serializeSslCertificateEntity);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSslCertificateCollectionResponse(writer: SerializationWriter, sslCertificateCollectionResponse: Partial<SslCertificateCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, sslCertificateCollectionResponse)
    writer.writeCollectionOfObjectValues<SslCertificate>("value", sslCertificateCollectionResponse.value, serializeSslCertificate);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSslCertificateEntity(writer: SerializationWriter, sslCertificateEntity: Partial<SslCertificateEntity> | undefined = {}) : void {
    writer.writeObjectValue<PhysicalAddress>("address", sslCertificateEntity.address, serializePhysicalAddress);
    writer.writeCollectionOfPrimitiveValues<string>("alternateNames", sslCertificateEntity.alternateNames);
    writer.writeStringValue("commonName", sslCertificateEntity.commonName);
    writer.writeStringValue("email", sslCertificateEntity.email);
    writer.writeStringValue("givenName", sslCertificateEntity.givenName);
    writer.writeStringValue("@odata.type", sslCertificateEntity.odataType);
    writer.writeStringValue("organizationName", sslCertificateEntity.organizationName);
    writer.writeStringValue("organizationUnitName", sslCertificateEntity.organizationUnitName);
    writer.writeStringValue("serialNumber", sslCertificateEntity.serialNumber);
    writer.writeStringValue("surname", sslCertificateEntity.surname);
    writer.writeAdditionalData(sslCertificateEntity.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSubdomain(writer: SerializationWriter, subdomain: Partial<Subdomain> | undefined = {}) : void {
    serializeEntity(writer, subdomain)
    writer.writeDateValue("firstSeenDateTime", subdomain.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", subdomain.host, serializeHost);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSubdomainCollectionResponse(writer: SerializationWriter, subdomainCollectionResponse: Partial<SubdomainCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, subdomainCollectionResponse)
    writer.writeCollectionOfObjectValues<Subdomain>("value", subdomainCollectionResponse.value, serializeSubdomain);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSubmissionMailEvidence(writer: SerializationWriter, submissionMailEvidence: Partial<SubmissionMailEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, submissionMailEvidence)
    writer.writeStringValue("networkMessageId", submissionMailEvidence.networkMessageId);
    writer.writeStringValue("recipient", submissionMailEvidence.recipient);
    writer.writeStringValue("reportType", submissionMailEvidence.reportType);
    writer.writeStringValue("sender", submissionMailEvidence.sender);
    writer.writeStringValue("senderIp", submissionMailEvidence.senderIp);
    writer.writeStringValue("subject", submissionMailEvidence.subject);
    writer.writeDateValue("submissionDateTime", submissionMailEvidence.submissionDateTime);
    writer.writeStringValue("submissionId", submissionMailEvidence.submissionId);
    writer.writeStringValue("submitter", submissionMailEvidence.submitter);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTag(writer: SerializationWriter, tag: Partial<Tag> | undefined = {}) : void {
    serializeEntity(writer, tag)
    writer.writeObjectValue<IdentitySet>("createdBy", tag.createdBy, serializeIdentitySet);
    writer.writeStringValue("description", tag.description);
    writer.writeStringValue("displayName", tag.displayName);
    writer.writeDateValue("lastModifiedDateTime", tag.lastModifiedDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeThreatIntelligence(writer: SerializationWriter, threatIntelligence: Partial<ThreatIntelligence> | undefined = {}) : void {
    serializeEntity(writer, threatIntelligence)
    writer.writeCollectionOfObjectValues<ArticleIndicator>("articleIndicators", threatIntelligence.articleIndicators, serializeArticleIndicator);
    writer.writeCollectionOfObjectValues<Article>("articles", threatIntelligence.articles, serializeArticle);
    writer.writeCollectionOfObjectValues<HostComponent>("hostComponents", threatIntelligence.hostComponents, serializeHostComponent);
    writer.writeCollectionOfObjectValues<HostCookie>("hostCookies", threatIntelligence.hostCookies, serializeHostCookie);
    writer.writeCollectionOfObjectValues<HostPair>("hostPairs", threatIntelligence.hostPairs, serializeHostPair);
    writer.writeCollectionOfObjectValues<HostPort>("hostPorts", threatIntelligence.hostPorts, serializeHostPort);
    writer.writeCollectionOfObjectValues<Host>("hosts", threatIntelligence.hosts, serializeHost);
    writer.writeCollectionOfObjectValues<HostSslCertificate>("hostSslCertificates", threatIntelligence.hostSslCertificates, serializeHostSslCertificate);
    writer.writeCollectionOfObjectValues<HostTracker>("hostTrackers", threatIntelligence.hostTrackers, serializeHostTracker);
    writer.writeCollectionOfObjectValues<IntelligenceProfileIndicator>("intelligenceProfileIndicators", threatIntelligence.intelligenceProfileIndicators, serializeIntelligenceProfileIndicator);
    writer.writeCollectionOfObjectValues<IntelligenceProfile>("intelProfiles", threatIntelligence.intelProfiles, serializeIntelligenceProfile);
    writer.writeCollectionOfObjectValues<PassiveDnsRecord>("passiveDnsRecords", threatIntelligence.passiveDnsRecords, serializePassiveDnsRecord);
    writer.writeCollectionOfObjectValues<SslCertificate>("sslCertificates", threatIntelligence.sslCertificates, serializeSslCertificate);
    writer.writeCollectionOfObjectValues<Subdomain>("subdomains", threatIntelligence.subdomains, serializeSubdomain);
    writer.writeCollectionOfObjectValues<Vulnerability>("vulnerabilities", threatIntelligence.vulnerabilities, serializeVulnerability);
    writer.writeCollectionOfObjectValues<WhoisHistoryRecord>("whoisHistoryRecords", threatIntelligence.whoisHistoryRecords, serializeWhoisHistoryRecord);
    writer.writeCollectionOfObjectValues<WhoisRecord>("whoisRecords", threatIntelligence.whoisRecords, serializeWhoisRecord);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTopicModelingSettings(writer: SerializationWriter, topicModelingSettings: Partial<TopicModelingSettings> | undefined = {}) : void {
    writer.writeBooleanValue("dynamicallyAdjustTopicCount", topicModelingSettings.dynamicallyAdjustTopicCount);
    writer.writeBooleanValue("ignoreNumbers", topicModelingSettings.ignoreNumbers);
    writer.writeBooleanValue("isEnabled", topicModelingSettings.isEnabled);
    writer.writeStringValue("@odata.type", topicModelingSettings.odataType);
    writer.writeNumberValue("topicCount", topicModelingSettings.topicCount);
    writer.writeAdditionalData(topicModelingSettings.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTriggersRoot(writer: SerializationWriter, triggersRoot: Partial<TriggersRoot> | undefined = {}) : void {
    serializeEntity(writer, triggersRoot)
    writer.writeCollectionOfObjectValues<RetentionEvent>("retentionEvents", triggersRoot.retentionEvents, serializeRetentionEvent);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTriggerTypesRoot(writer: SerializationWriter, triggerTypesRoot: Partial<TriggerTypesRoot> | undefined = {}) : void {
    serializeEntity(writer, triggerTypesRoot)
    writer.writeCollectionOfObjectValues<RetentionEventType>("retentionEventTypes", triggerTypesRoot.retentionEventTypes, serializeRetentionEventType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUnclassifiedArtifact(writer: SerializationWriter, unclassifiedArtifact: Partial<UnclassifiedArtifact> | undefined = {}) : void {
    serializeArtifact(writer, unclassifiedArtifact)
    writer.writeStringValue("kind", unclassifiedArtifact.kind);
    writer.writeStringValue("value", unclassifiedArtifact.value);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUnifiedGroupSource(writer: SerializationWriter, unifiedGroupSource: Partial<UnifiedGroupSource> | undefined = {}) : void {
    serializeDataSource(writer, unifiedGroupSource)
    writer.writeObjectValue<Group>("group", unifiedGroupSource.group, serializeGroup);
    writer.writeEnumValue<SourceType[]>("includedSources", unifiedGroupSource.includedSources);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUnifiedGroupSourceCollectionResponse(writer: SerializationWriter, unifiedGroupSourceCollectionResponse: Partial<UnifiedGroupSourceCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, unifiedGroupSourceCollectionResponse)
    writer.writeCollectionOfObjectValues<UnifiedGroupSource>("value", unifiedGroupSourceCollectionResponse.value, serializeUnifiedGroupSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUrlEvidence(writer: SerializationWriter, urlEvidence: Partial<UrlEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, urlEvidence)
    writer.writeStringValue("url", urlEvidence.url);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUserAccount(writer: SerializationWriter, userAccount: Partial<UserAccount> | undefined = {}) : void {
    writer.writeStringValue("accountName", userAccount.accountName);
    writer.writeStringValue("azureAdUserId", userAccount.azureAdUserId);
    writer.writeStringValue("displayName", userAccount.displayName);
    writer.writeStringValue("domainName", userAccount.domainName);
    writer.writeStringValue("@odata.type", userAccount.odataType);
    writer.writeStringValue("userPrincipalName", userAccount.userPrincipalName);
    writer.writeStringValue("userSid", userAccount.userSid);
    writer.writeAdditionalData(userAccount.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUserEvidence(writer: SerializationWriter, userEvidence: Partial<UserEvidence> | undefined = {}) : void {
    serializeAlertEvidence(writer, userEvidence)
    writer.writeObjectValue<UserAccount>("userAccount", userEvidence.userAccount, serializeUserAccount);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUserSource(writer: SerializationWriter, userSource: Partial<UserSource> | undefined = {}) : void {
    serializeDataSource(writer, userSource)
    writer.writeStringValue("email", userSource.email);
    writer.writeEnumValue<SourceType[]>("includedSources", userSource.includedSources);
    writer.writeStringValue("siteWebUrl", userSource.siteWebUrl);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUserSourceCollectionResponse(writer: SerializationWriter, userSourceCollectionResponse: Partial<UserSourceCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, userSourceCollectionResponse)
    writer.writeCollectionOfObjectValues<UserSource>("value", userSourceCollectionResponse.value, serializeUserSource);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeVmMetadata(writer: SerializationWriter, vmMetadata: Partial<VmMetadata> | undefined = {}) : void {
    writer.writeEnumValue<VmCloudProvider>("cloudProvider", vmMetadata.cloudProvider);
    writer.writeStringValue("@odata.type", vmMetadata.odataType);
    writer.writeStringValue("resourceId", vmMetadata.resourceId);
    writer.writeStringValue("subscriptionId", vmMetadata.subscriptionId);
    writer.writeStringValue("vmId", vmMetadata.vmId);
    writer.writeAdditionalData(vmMetadata.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeVulnerability(writer: SerializationWriter, vulnerability: Partial<Vulnerability> | undefined = {}) : void {
    serializeEntity(writer, vulnerability)
    writer.writeBooleanValue("activeExploitsObserved", vulnerability.activeExploitsObserved);
    writer.writeCollectionOfObjectValues<Article>("articles", vulnerability.articles, serializeArticle);
    writer.writeCollectionOfPrimitiveValues<string>("commonWeaknessEnumerationIds", vulnerability.commonWeaknessEnumerationIds);
    writer.writeCollectionOfObjectValues<VulnerabilityComponent>("components", vulnerability.components, serializeVulnerabilityComponent);
    writer.writeDateValue("createdDateTime", vulnerability.createdDateTime);
    writer.writeObjectValue<CvssSummary>("cvss2Summary", vulnerability.cvss2Summary, serializeCvssSummary);
    writer.writeObjectValue<CvssSummary>("cvss3Summary", vulnerability.cvss3Summary, serializeCvssSummary);
    writer.writeObjectValue<FormattedContent>("description", vulnerability.description, serializeFormattedContent);
    writer.writeCollectionOfObjectValues<Hyperlink>("exploits", vulnerability.exploits, serializeHyperlink);
    writer.writeBooleanValue("exploitsAvailable", vulnerability.exploitsAvailable);
    writer.writeBooleanValue("hasChatter", vulnerability.hasChatter);
    writer.writeDateValue("lastModifiedDateTime", vulnerability.lastModifiedDateTime);
    writer.writeNumberValue("priorityScore", vulnerability.priorityScore);
    writer.writeDateValue("publishedDateTime", vulnerability.publishedDateTime);
    writer.writeCollectionOfObjectValues<Hyperlink>("references", vulnerability.references, serializeHyperlink);
    writer.writeObjectValue<FormattedContent>("remediation", vulnerability.remediation, serializeFormattedContent);
    writer.writeEnumValue<VulnerabilitySeverity>("severity", vulnerability.severity);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeVulnerabilityCollectionResponse(writer: SerializationWriter, vulnerabilityCollectionResponse: Partial<VulnerabilityCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, vulnerabilityCollectionResponse)
    writer.writeCollectionOfObjectValues<Vulnerability>("value", vulnerabilityCollectionResponse.value, serializeVulnerability);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeVulnerabilityComponent(writer: SerializationWriter, vulnerabilityComponent: Partial<VulnerabilityComponent> | undefined = {}) : void {
    serializeEntity(writer, vulnerabilityComponent)
    writer.writeStringValue("name", vulnerabilityComponent.name);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeVulnerabilityComponentCollectionResponse(writer: SerializationWriter, vulnerabilityComponentCollectionResponse: Partial<VulnerabilityComponentCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, vulnerabilityComponentCollectionResponse)
    writer.writeCollectionOfObjectValues<VulnerabilityComponent>("value", vulnerabilityComponentCollectionResponse.value, serializeVulnerabilityComponent);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeWhoisBaseRecord(writer: SerializationWriter, whoisBaseRecord: Partial<WhoisBaseRecord> | undefined = {}) : void {
    serializeEntity(writer, whoisBaseRecord)
    writer.writeObjectValue<WhoisContact>("abuse", whoisBaseRecord.abuse, serializeWhoisContact);
    writer.writeObjectValue<WhoisContact>("admin", whoisBaseRecord.admin, serializeWhoisContact);
    writer.writeObjectValue<WhoisContact>("billing", whoisBaseRecord.billing, serializeWhoisContact);
    writer.writeStringValue("domainStatus", whoisBaseRecord.domainStatus);
    writer.writeDateValue("expirationDateTime", whoisBaseRecord.expirationDateTime);
    writer.writeDateValue("firstSeenDateTime", whoisBaseRecord.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", whoisBaseRecord.host, serializeHost);
    writer.writeDateValue("lastSeenDateTime", whoisBaseRecord.lastSeenDateTime);
    writer.writeDateValue("lastUpdateDateTime", whoisBaseRecord.lastUpdateDateTime);
    writer.writeCollectionOfObjectValues<WhoisNameserver>("nameservers", whoisBaseRecord.nameservers, serializeWhoisNameserver);
    writer.writeObjectValue<WhoisContact>("noc", whoisBaseRecord.noc, serializeWhoisContact);
    writer.writeStringValue("rawWhoisText", whoisBaseRecord.rawWhoisText);
    writer.writeObjectValue<WhoisContact>("registrant", whoisBaseRecord.registrant, serializeWhoisContact);
    writer.writeObjectValue<WhoisContact>("registrar", whoisBaseRecord.registrar, serializeWhoisContact);
    writer.writeDateValue("registrationDateTime", whoisBaseRecord.registrationDateTime);
    writer.writeObjectValue<WhoisContact>("technical", whoisBaseRecord.technical, serializeWhoisContact);
    writer.writeStringValue("whoisServer", whoisBaseRecord.whoisServer);
    writer.writeObjectValue<WhoisContact>("zone", whoisBaseRecord.zone, serializeWhoisContact);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeWhoisContact(writer: SerializationWriter, whoisContact: Partial<WhoisContact> | undefined = {}) : void {
    writer.writeObjectValue<PhysicalAddress>("address", whoisContact.address, serializePhysicalAddress);
    writer.writeStringValue("email", whoisContact.email);
    writer.writeStringValue("fax", whoisContact.fax);
    writer.writeStringValue("name", whoisContact.name);
    writer.writeStringValue("@odata.type", whoisContact.odataType);
    writer.writeStringValue("organization", whoisContact.organization);
    writer.writeStringValue("telephone", whoisContact.telephone);
    writer.writeAdditionalData(whoisContact.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeWhoisHistoryRecord(writer: SerializationWriter, whoisHistoryRecord: Partial<WhoisHistoryRecord> | undefined = {}) : void {
    serializeWhoisBaseRecord(writer, whoisHistoryRecord)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeWhoisHistoryRecordCollectionResponse(writer: SerializationWriter, whoisHistoryRecordCollectionResponse: Partial<WhoisHistoryRecordCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, whoisHistoryRecordCollectionResponse)
    writer.writeCollectionOfObjectValues<WhoisHistoryRecord>("value", whoisHistoryRecordCollectionResponse.value, serializeWhoisHistoryRecord);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeWhoisNameserver(writer: SerializationWriter, whoisNameserver: Partial<WhoisNameserver> | undefined = {}) : void {
    writer.writeDateValue("firstSeenDateTime", whoisNameserver.firstSeenDateTime);
    writer.writeObjectValue<Host>("host", whoisNameserver.host, serializeHost);
    writer.writeDateValue("lastSeenDateTime", whoisNameserver.lastSeenDateTime);
    writer.writeStringValue("@odata.type", whoisNameserver.odataType);
    writer.writeAdditionalData(whoisNameserver.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeWhoisRecord(writer: SerializationWriter, whoisRecord: Partial<WhoisRecord> | undefined = {}) : void {
    serializeWhoisBaseRecord(writer, whoisRecord)
    writer.writeCollectionOfObjectValues<WhoisHistoryRecord>("history", whoisRecord.history, serializeWhoisHistoryRecord);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeWhoisRecordCollectionResponse(writer: SerializationWriter, whoisRecordCollectionResponse: Partial<WhoisRecordCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, whoisRecordCollectionResponse)
    writer.writeCollectionOfObjectValues<WhoisRecord>("value", whoisRecordCollectionResponse.value, serializeWhoisRecord);
}
export interface ServicePrincipalEvidence extends AlertEvidence, Parsable {
    /**
     * The appId property
     */
    appId?: string;
    /**
     * The appOwnerTenantId property
     */
    appOwnerTenantId?: string;
    /**
     * The servicePrincipalName property
     */
    servicePrincipalName?: string;
    /**
     * The servicePrincipalObjectId property
     */
    servicePrincipalObjectId?: string;
    /**
     * The servicePrincipalType property
     */
    servicePrincipalType?: ServicePrincipalType;
    /**
     * The tenantId property
     */
    tenantId?: string;
}
export type ServicePrincipalType = (typeof ServicePrincipalTypeObject)[keyof typeof ServicePrincipalTypeObject];
export type ServiceSource = (typeof ServiceSourceObject)[keyof typeof ServiceSourceObject];
export interface SinglePropertySchema extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The name of the property.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The type of the property.
     */
    type?: string;
}
export interface SiteSource extends DataSource, Parsable {
    /**
     * The site property
     */
    site?: Site;
}
export interface SiteSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: SiteSource[];
}
export type SourceType = (typeof SourceTypeObject)[keyof typeof SourceTypeObject];
export interface SslCertificate extends Artifact, Parsable {
    /**
     * The date and time when a certificate expires. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    expirationDateTime?: Date;
    /**
     * A hash of the certificate calculated on the data and signature.
     */
    fingerprint?: string;
    /**
     * The first date and time when this sslCertificate was observed. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The date and time when a certificate was issued. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    issueDateTime?: Date;
    /**
     * The entity that grants this certificate.
     */
    issuer?: SslCertificateEntity;
    /**
     * The most recent date and time when this sslCertificate was observed. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The hosts related with this sslCertificate.
     */
    relatedHosts?: Host[];
    /**
     * The serial number associated with an SSL certificate.
     */
    serialNumber?: string;
    /**
     * A SHA-1 hash of the certificate. Note: This is not the signature.
     */
    sha1?: string;
    /**
     * The person, site, machine, and so on, this certificate is for.
     */
    subject?: SslCertificateEntity;
}
export interface SslCertificateCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: SslCertificate[];
}
export interface SslCertificateEntity extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * A physical address of the entity.
     */
    address?: PhysicalAddress;
    /**
     * Alternate names for this entity that are part of the certificate.
     */
    alternateNames?: string[];
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * A common name for this entity.
     */
    commonName?: string;
    /**
     * An email for this entity.
     */
    email?: string;
    /**
     * If the entity is a person, this is the person's given name (first name).
     */
    givenName?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * If the entity is an organization, this is the name of the organization.
     */
    organizationName?: string;
    /**
     * If the entity is an organization, this communicates if a unit in the organization is named on the entity.
     */
    organizationUnitName?: string;
    /**
     * A serial number assigned to the entity; usually only available if the entity is the issuer.
     */
    serialNumber?: string;
    /**
     * If the entity is a person, this is the person's surname (last name).
     */
    surname?: string;
}
export interface Subdomain extends Entity, Parsable {
    /**
     * The date and time when Microsoft Defender Threat Intelligence first observed the subdomain. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host property
     */
    host?: Host;
}
export interface SubdomainCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Subdomain[];
}
export interface SubmissionMailEvidence extends AlertEvidence, Parsable {
    /**
     * The networkMessageId property
     */
    networkMessageId?: string;
    /**
     * The recipient property
     */
    recipient?: string;
    /**
     * The reportType property
     */
    reportType?: string;
    /**
     * The sender property
     */
    sender?: string;
    /**
     * The senderIp property
     */
    senderIp?: string;
    /**
     * The subject property
     */
    subject?: string;
    /**
     * The submissionDateTime property
     */
    submissionDateTime?: Date;
    /**
     * The submissionId property
     */
    submissionId?: string;
    /**
     * The submitter property
     */
    submitter?: string;
}
export interface Tag extends Entity, Parsable {
    /**
     * The createdBy property
     */
    createdBy?: IdentitySet;
    /**
     * The description property
     */
    description?: string;
    /**
     * The displayName property
     */
    displayName?: string;
    /**
     * The lastModifiedDateTime property
     */
    lastModifiedDateTime?: Date;
}
export interface ThreatIntelligence extends Entity, Parsable {
    /**
     * Refers to indicators of threat or compromise highlighted in an article.Note: List retrieval is not yet supported.
     */
    articleIndicators?: ArticleIndicator[];
    /**
     * A list of article objects.
     */
    articles?: Article[];
    /**
     * Retrieve details about hostComponent objects.Note: List retrieval is not yet supported.
     */
    hostComponents?: HostComponent[];
    /**
     * Retrieve details about hostCookie objects.Note: List retrieval is not yet supported.
     */
    hostCookies?: HostCookie[];
    /**
     * Retrieve details about hostTracker objects.Note: List retrieval is not yet supported.
     */
    hostPairs?: HostPair[];
    /**
     * Retrieve details about hostPort objects.Note: List retrieval is not yet supported.
     */
    hostPorts?: HostPort[];
    /**
     * Refers to host objects that Microsoft Threat Intelligence has observed.Note: List retrieval is not yet supported.
     */
    hosts?: Host[];
    /**
     * Retrieve details about hostSslCertificate objects.Note: List retrieval is not yet supported.
     */
    hostSslCertificates?: HostSslCertificate[];
    /**
     * Retrieve details about hostTracker objects.Note: List retrieval is not yet supported.
     */
    hostTrackers?: HostTracker[];
    /**
     * The intelligenceProfileIndicators property
     */
    intelligenceProfileIndicators?: IntelligenceProfileIndicator[];
    /**
     * A list of intelligenceProfile objects.
     */
    intelProfiles?: IntelligenceProfile[];
    /**
     * Retrieve details about passiveDnsRecord objects.Note: List retrieval is not yet supported.
     */
    passiveDnsRecords?: PassiveDnsRecord[];
    /**
     * Retrieve details about sslCertificate objects.Note: List retrieval is not yet supported.
     */
    sslCertificates?: SslCertificate[];
    /**
     * Retrieve details about the subdomain.Note: List retrieval is not yet supported.
     */
    subdomains?: Subdomain[];
    /**
     * Retrieve details about vulnerabilities.Note: List retrieval is not yet supported.
     */
    vulnerabilities?: Vulnerability[];
    /**
     * Retrieve details about whoisHistoryRecord objects.Note: List retrieval is not yet supported.
     */
    whoisHistoryRecords?: WhoisHistoryRecord[];
    /**
     * A list of whoisRecord objects.
     */
    whoisRecords?: WhoisRecord[];
}
export interface TopicModelingSettings extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Indicates whether the themes model should dynamically optimize the number of generated topics. To learn more, see Adjust maximum number of themes dynamically.
     */
    dynamicallyAdjustTopicCount?: boolean;
    /**
     * Indicates whether the themes model should exclude numbers while parsing document texts. To learn more, see Include numbers in themes.
     */
    ignoreNumbers?: boolean;
    /**
     * Indicates whether themes model is enabled for the case.
     */
    isEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The total number of topics that the themes model will generate for a review set. To learn more, see Maximum number of themes.
     */
    topicCount?: number;
}
export interface TriggersRoot extends Entity, Parsable {
    /**
     * The retentionEvents property
     */
    retentionEvents?: RetentionEvent[];
}
export interface TriggerTypesRoot extends Entity, Parsable {
    /**
     * The retentionEventTypes property
     */
    retentionEventTypes?: RetentionEventType[];
}
export interface UnclassifiedArtifact extends Artifact, Parsable {
    /**
     * The kind for this unclassifiedArtifact resource, describing what this value means.
     */
    kind?: string;
    /**
     * The value for this unclassifiedArtifact.
     */
    value?: string;
}
export interface UnifiedGroupSource extends DataSource, Parsable {
    /**
     * The group property
     */
    group?: Group;
    /**
     * Specifies which sources are included in this group. Possible values are: mailbox, site.
     */
    includedSources?: SourceType[];
}
export interface UnifiedGroupSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: UnifiedGroupSource[];
}
export interface UrlEvidence extends AlertEvidence, Parsable {
    /**
     * The Unique Resource Locator (URL).
     */
    url?: string;
}
export interface UserAccount extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * The displayed name of the user account.
     */
    accountName?: string;
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The user object identifier in Microsoft Entra ID.
     */
    azureAdUserId?: string;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The user display name in Microsoft Entra ID.
     */
    displayName?: string;
    /**
     * The name of the Active Directory domain of which the user is a member.
     */
    domainName?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The user principal name of the account in Microsoft Entra ID.
     */
    userPrincipalName?: string;
    /**
     * The local security identifier of the user account.
     */
    userSid?: string;
}
export interface UserEvidence extends AlertEvidence, Parsable {
    /**
     * The user account details.
     */
    userAccount?: UserAccount;
}
export interface UserSource extends DataSource, Parsable {
    /**
     * Email address of the user's mailbox.
     */
    email?: string;
    /**
     * Specifies which sources are included in this group. Possible values are: mailbox, site.
     */
    includedSources?: SourceType[];
    /**
     * The URL of the user's OneDrive for Business site. Read-only.
     */
    siteWebUrl?: string;
}
export interface UserSourceCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: UserSource[];
}
export type VmCloudProvider = (typeof VmCloudProviderObject)[keyof typeof VmCloudProviderObject];
export interface VmMetadata extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The cloudProvider property
     */
    cloudProvider?: VmCloudProvider;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Unique identifier of the Azure resource.
     */
    resourceId?: string;
    /**
     * Unique identifier of the Azure subscription the customer tenant belongs to.
     */
    subscriptionId?: string;
    /**
     * Unique identifier of the virtual machine instance.
     */
    vmId?: string;
}
export interface Vulnerability extends Entity, Parsable {
    /**
     * Indicates whether this vulnerability has any known exploits associated to known bad actors.
     */
    activeExploitsObserved?: boolean;
    /**
     * Articles related to this vulnerability.
     */
    articles?: Article[];
    /**
     * Community-defined common weakness enumerations (CWE).
     */
    commonWeaknessEnumerationIds?: string[];
    /**
     * Components related to this vulnerability article.
     */
    components?: VulnerabilityComponent[];
    /**
     * The date and time when this vulnerability article was first created.
     */
    createdDateTime?: Date;
    /**
     * The cvss2Summary property
     */
    cvss2Summary?: CvssSummary;
    /**
     * The cvss3Summary property
     */
    cvss3Summary?: CvssSummary;
    /**
     * The description property
     */
    description?: FormattedContent;
    /**
     * Known exploits for this vulnerability.
     */
    exploits?: Hyperlink[];
    /**
     * Indicates whether this vulnerability has exploits in public sources (such as Packetstorm or Exploit-DB) online.
     */
    exploitsAvailable?: boolean;
    /**
     * Indicates whether chatter about this vulnerability has been discovered online.
     */
    hasChatter?: boolean;
    /**
     * The date and time when this vulnerability article was most recently updated.
     */
    lastModifiedDateTime?: Date;
    /**
     * A unique algorithm that reflects the priority of a vulnerability based on the CVSS score, exploits, chatter, and linkage to malware. This property also evaluates the recency of these components so users can understand which vulnerability should be remediated first.
     */
    priorityScore?: number;
    /**
     * The date and time when this vulnerability article was published.
     */
    publishedDateTime?: Date;
    /**
     * Reference links where further information can be learned about this vulnerability.
     */
    references?: Hyperlink[];
    /**
     * Any known remediation steps.
     */
    remediation?: FormattedContent;
    /**
     * The severity property
     */
    severity?: VulnerabilitySeverity;
}
export interface VulnerabilityCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Vulnerability[];
}
export interface VulnerabilityComponent extends Entity, Parsable {
    /**
     * The name of this vulnerability component.
     */
    name?: string;
}
export interface VulnerabilityComponentCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: VulnerabilityComponent[];
}
export type VulnerabilitySeverity = (typeof VulnerabilitySeverityObject)[keyof typeof VulnerabilitySeverityObject];
export interface WhoisBaseRecord extends Entity, Parsable {
    /**
     * The contact information for the abuse contact.
     */
    abuse?: WhoisContact;
    /**
     * The contact information for the admin contact.
     */
    admin?: WhoisContact;
    /**
     * The contact information for the billing contact.
     */
    billing?: WhoisContact;
    /**
     * The domain status for this WHOIS object.
     */
    domainStatus?: string;
    /**
     * The date and time when this WHOIS record expires with the registrar. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    expirationDateTime?: Date;
    /**
     * The first seen date and time of this WHOIS record. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host property
     */
    host?: Host;
    /**
     * The last seen date and time of this WHOIS record. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The date and time when this WHOIS record was last modified. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastUpdateDateTime?: Date;
    /**
     * The nameservers for this WHOIS object.
     */
    nameservers?: WhoisNameserver[];
    /**
     * The contact information for the noc contact.
     */
    noc?: WhoisContact;
    /**
     * The raw WHOIS details for this WHOIS object.
     */
    rawWhoisText?: string;
    /**
     * The contact information for the registrant contact.
     */
    registrant?: WhoisContact;
    /**
     * The contact information for the registrar contact.
     */
    registrar?: WhoisContact;
    /**
     * The date and time when this WHOIS record was registered with a registrar. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    registrationDateTime?: Date;
    /**
     * The contact information for the technical contact.
     */
    technical?: WhoisContact;
    /**
     * The WHOIS server that provides the details.
     */
    whoisServer?: string;
    /**
     * The contact information for the zone contact.
     */
    zone?: WhoisContact;
}
export interface WhoisContact extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The physical address of the entity.
     */
    address?: PhysicalAddress;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The email of this WHOIS contact.
     */
    email?: string;
    /**
     * The fax of this WHOIS contact. No format is guaranteed.
     */
    fax?: string;
    /**
     * The name of this WHOIS contact.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The organization of this WHOIS contact.
     */
    organization?: string;
    /**
     * The telephone of this WHOIS contact. No format is guaranteed.
     */
    telephone?: string;
}
export interface WhoisHistoryRecord extends Parsable, WhoisBaseRecord {
}
export interface WhoisHistoryRecordCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: WhoisHistoryRecord[];
}
export interface WhoisNameserver extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The first seen date and time of this WHOIS contact. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    firstSeenDateTime?: Date;
    /**
     * The host property
     */
    host?: Host;
    /**
     * The last seen date and time of this WHOIS contact. The timestamp type represents date and time information using ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    lastSeenDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface WhoisRecord extends Parsable, WhoisBaseRecord {
    /**
     * The collection of historical records associated to this WHOIS object.
     */
    history?: WhoisHistoryRecord[];
}
export interface WhoisRecordCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: WhoisRecord[];
}
export const AdditionalDataOptionsObject = {
    AllVersions: "allVersions",
    LinkedFiles: "linkedFiles",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AlertClassificationObject = {
    Unknown: "unknown",
    FalsePositive: "falsePositive",
    TruePositive: "truePositive",
    InformationalExpectedActivity: "informationalExpectedActivity",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AlertDeterminationObject = {
    Unknown: "unknown",
    Apt: "apt",
    Malware: "malware",
    SecurityPersonnel: "securityPersonnel",
    SecurityTesting: "securityTesting",
    UnwantedSoftware: "unwantedSoftware",
    Other: "other",
    MultiStagedAttack: "multiStagedAttack",
    CompromisedAccount: "compromisedAccount",
    Phishing: "phishing",
    MaliciousUserActivity: "maliciousUserActivity",
    NotMalicious: "notMalicious",
    NotEnoughDataToValidate: "notEnoughDataToValidate",
    ConfirmedActivity: "confirmedActivity",
    LineOfBusinessApplication: "lineOfBusinessApplication",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AlertSeverityObject = {
    Unknown: "unknown",
    Informational: "informational",
    Low: "low",
    Medium: "medium",
    High: "high",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const AlertStatusObject = {
    Unknown: "unknown",
    NewEscaped: "new",
    InProgress: "inProgress",
    Resolved: "resolved",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const BehaviorDuringRetentionPeriodObject = {
    DoNotRetain: "doNotRetain",
    Retain: "retain",
    RetainAsRecord: "retainAsRecord",
    RetainAsRegulatoryRecord: "retainAsRegulatoryRecord",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const CaseActionObject = {
    ContentExport: "contentExport",
    ApplyTags: "applyTags",
    ConvertToPdf: "convertToPdf",
    Index: "index",
    EstimateStatistics: "estimateStatistics",
    AddToReviewSet: "addToReviewSet",
    HoldUpdate: "holdUpdate",
    UnknownFutureValue: "unknownFutureValue",
    PurgeData: "purgeData",
} as const;
export const CaseOperationStatusObject = {
    NotStarted: "notStarted",
    SubmissionFailed: "submissionFailed",
    Running: "running",
    Succeeded: "succeeded",
    PartiallySucceeded: "partiallySucceeded",
    Failed: "failed",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const CaseStatusObject = {
    Unknown: "unknown",
    Active: "active",
    PendingDelete: "pendingDelete",
    Closing: "closing",
    Closed: "closed",
    ClosedWithError: "closedWithError",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ChildSelectabilityObject = {
    One: "One",
    Many: "Many",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ContainerPortProtocolObject = {
    Udp: "udp",
    Tcp: "tcp",
    Sctp: "sctp",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ContentFormatObject = {
    Text: "text",
    Html: "html",
    Markdown: "markdown",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DataSourceContainerStatusObject = {
    Active: "active",
    Released: "released",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DataSourceHoldStatusObject = {
    NotApplied: "notApplied",
    Applied: "applied",
    Applying: "applying",
    Removing: "removing",
    Partial: "partial",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DataSourceScopesObject = {
    None: "none",
    AllTenantMailboxes: "allTenantMailboxes",
    AllTenantSites: "allTenantSites",
    AllCaseCustodians: "allCaseCustodians",
    AllCaseNoncustodialDataSources: "allCaseNoncustodialDataSources",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DefenderAvStatusObject = {
    NotReporting: "notReporting",
    Disabled: "disabled",
    NotUpdated: "notUpdated",
    Updated: "updated",
    Unknown: "unknown",
    NotSupported: "notSupported",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DetectionSourceObject = {
    Unknown: "unknown",
    MicrosoftDefenderForEndpoint: "microsoftDefenderForEndpoint",
    Antivirus: "antivirus",
    SmartScreen: "smartScreen",
    CustomTi: "customTi",
    MicrosoftDefenderForOffice365: "microsoftDefenderForOffice365",
    AutomatedInvestigation: "automatedInvestigation",
    MicrosoftThreatExperts: "microsoftThreatExperts",
    CustomDetection: "customDetection",
    MicrosoftDefenderForIdentity: "microsoftDefenderForIdentity",
    CloudAppSecurity: "cloudAppSecurity",
    Microsoft365Defender: "microsoft365Defender",
    AzureAdIdentityProtection: "azureAdIdentityProtection",
    Manual: "manual",
    MicrosoftDataLossPrevention: "microsoftDataLossPrevention",
    AppGovernancePolicy: "appGovernancePolicy",
    AppGovernanceDetection: "appGovernanceDetection",
    UnknownFutureValue: "unknownFutureValue",
    MicrosoftDefenderForCloud: "microsoftDefenderForCloud",
    MicrosoftDefenderForIoT: "microsoftDefenderForIoT",
    MicrosoftDefenderForServers: "microsoftDefenderForServers",
    MicrosoftDefenderForStorage: "microsoftDefenderForStorage",
    MicrosoftDefenderForDNS: "microsoftDefenderForDNS",
    MicrosoftDefenderForDatabases: "microsoftDefenderForDatabases",
    MicrosoftDefenderForContainers: "microsoftDefenderForContainers",
    MicrosoftDefenderForNetwork: "microsoftDefenderForNetwork",
    MicrosoftDefenderForAppService: "microsoftDefenderForAppService",
    MicrosoftDefenderForKeyVault: "microsoftDefenderForKeyVault",
    MicrosoftDefenderForResourceManager: "microsoftDefenderForResourceManager",
    MicrosoftDefenderForApiManagement: "microsoftDefenderForApiManagement",
    NrtAlerts: "nrtAlerts",
    ScheduledAlerts: "scheduledAlerts",
    MicrosoftDefenderThreatIntelligenceAnalytics: "microsoftDefenderThreatIntelligenceAnalytics",
    BuiltInMl: "builtInMl",
    MicrosoftSentinel: "microsoftSentinel",
} as const;
export const DetectionStatusObject = {
    Detected: "detected",
    Blocked: "blocked",
    Prevented: "prevented",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DeviceHealthStatusObject = {
    Active: "active",
    Inactive: "inactive",
    ImpairedCommunication: "impairedCommunication",
    NoSensorData: "noSensorData",
    NoSensorDataImpairedCommunication: "noSensorDataImpairedCommunication",
    Unknown: "unknown",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const DeviceRiskScoreObject = {
    None: "none",
    Informational: "informational",
    Low: "low",
    Medium: "medium",
    High: "high",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const EventPropagationStatusObject = {
    None: "none",
    InProcessing: "inProcessing",
    Failed: "failed",
    Success: "success",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const EventStatusTypeObject = {
    Pending: "pending",
    ErrorEscaped: "error",
    Success: "success",
    NotAvaliable: "notAvaliable",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const EvidenceRemediationStatusObject = {
    None: "none",
    Remediated: "remediated",
    Prevented: "prevented",
    Blocked: "blocked",
    NotFound: "notFound",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const EvidenceRoleObject = {
    Unknown: "unknown",
    Contextual: "contextual",
    Scanned: "scanned",
    Source: "source",
    Destination: "destination",
    Created: "created",
    Added: "added",
    Compromised: "compromised",
    Edited: "edited",
    Attacked: "attacked",
    Attacker: "attacker",
    CommandAndControl: "commandAndControl",
    Loaded: "loaded",
    Suspicious: "suspicious",
    PolicyViolator: "policyViolator",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const EvidenceVerdictObject = {
    Unknown: "unknown",
    Suspicious: "suspicious",
    Malicious: "malicious",
    NoThreatsFound: "noThreatsFound",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ExportFileStructureObject = {
    None: "none",
    Directory: "directory",
    Pst: "pst",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ExportOptionsObject = {
    OriginalFiles: "originalFiles",
    Text: "text",
    PdfReplacement: "pdfReplacement",
    Tags: "tags",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const FileHashAlgorithmObject = {
    Unknown: "unknown",
    Md5: "md5",
    Sha1: "sha1",
    Sha256: "sha256",
    Sha256ac: "sha256ac",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const GoogleCloudLocationTypeObject = {
    Unknown: "unknown",
    Regional: "regional",
    Zonal: "zonal",
    Global: "global",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const HostPortProtocolObject = {
    Tcp: "tcp",
    Udp: "udp",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const HostPortStatusObject = {
    Open: "open",
    Filtered: "filtered",
    Closed: "closed",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const HostReputationClassificationObject = {
    Unknown: "unknown",
    Neutral: "neutral",
    Suspicious: "suspicious",
    Malicious: "malicious",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const HostReputationRuleSeverityObject = {
    Unknown: "unknown",
    Low: "low",
    Medium: "medium",
    High: "high",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const IncidentStatusObject = {
    Active: "active",
    Resolved: "resolved",
    InProgress: "inProgress",
    Redirected: "redirected",
    UnknownFutureValue: "unknownFutureValue",
    AwaitingAction: "awaitingAction",
} as const;
export const IndicatorSourceObject = {
    Microsoft: "microsoft",
    Osint: "osint",
    Public: "public",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const IntelligenceProfileKindObject = {
    Actor: "actor",
    Tool: "tool",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const IoTDeviceImportanceTypeObject = {
    Unknown: "unknown",
    Low: "low",
    Normal: "normal",
    High: "high",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const KubernetesPlatformObject = {
    Unknown: "unknown",
    Aks: "aks",
    Eks: "eks",
    Gke: "gke",
    Arc: "arc",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const KubernetesServiceTypeObject = {
    Unknown: "unknown",
    ClusterIP: "clusterIP",
    ExternalName: "externalName",
    NodePort: "nodePort",
    LoadBalancer: "loadBalancer",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const OnboardingStatusObject = {
    InsufficientInfo: "insufficientInfo",
    Onboarded: "onboarded",
    CanBeOnboarded: "canBeOnboarded",
    Unsupported: "unsupported",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ProtocolTypeObject = {
    Tcp: "tcp",
    Udp: "udp",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const PurgeAreasObject = {
    Mailboxes: "mailboxes",
    TeamsMessages: "teamsMessages",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const PurgeTypeObject = {
    Recoverable: "recoverable",
    PermanentlyDeleted: "permanentlyDeleted",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const QueryTypeObject = {
    Files: "files",
    Messages: "messages",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ServicePrincipalTypeObject = {
    Unknown: "unknown",
    Application: "application",
    ManagedIdentity: "managedIdentity",
    Legacy: "legacy",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ServiceSourceObject = {
    Unknown: "unknown",
    MicrosoftDefenderForEndpoint: "microsoftDefenderForEndpoint",
    MicrosoftDefenderForIdentity: "microsoftDefenderForIdentity",
    MicrosoftDefenderForCloudApps: "microsoftDefenderForCloudApps",
    MicrosoftDefenderForOffice365: "microsoftDefenderForOffice365",
    Microsoft365Defender: "microsoft365Defender",
    AzureAdIdentityProtection: "azureAdIdentityProtection",
    MicrosoftAppGovernance: "microsoftAppGovernance",
    DataLossPrevention: "dataLossPrevention",
    UnknownFutureValue: "unknownFutureValue",
    MicrosoftDefenderForCloud: "microsoftDefenderForCloud",
    MicrosoftSentinel: "microsoftSentinel",
} as const;
export const SourceTypeObject = {
    Mailbox: "mailbox",
    Site: "site",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const VmCloudProviderObject = {
    Unknown: "unknown",
    Azure: "azure",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const VulnerabilitySeverityObject = {
    None: "none",
    Low: "low",
    Medium: "medium",
    High: "high",
    Critical: "critical",
    UnknownFutureValue: "unknownFutureValue",
} as const;
/* tslint:enable */
/* eslint-enable */
