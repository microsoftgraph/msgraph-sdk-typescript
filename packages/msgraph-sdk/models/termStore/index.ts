/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createKeyValueFromDiscriminatorValue, deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, serializeBaseCollectionPaginationCountResponse, serializeEntity, serializeKeyValue, type BaseCollectionPaginationCountResponse, type Entity, type KeyValue } from '../index.js';
// @ts-ignore
import { type AdditionalDataHolder, type BackedModel, type BackingStore, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GroupCollectionResponse}
 */
// @ts-ignore
export function createGroupCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGroupCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Group}
 */
// @ts-ignore
export function createGroupFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGroup;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {LocalizedDescription}
 */
// @ts-ignore
export function createLocalizedDescriptionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoLocalizedDescription;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {LocalizedLabel}
 */
// @ts-ignore
export function createLocalizedLabelFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoLocalizedLabel;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {LocalizedName}
 */
// @ts-ignore
export function createLocalizedNameFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoLocalizedName;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelationCollectionResponse}
 */
// @ts-ignore
export function createRelationCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelationCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Relation}
 */
// @ts-ignore
export function createRelationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SetCollectionResponse}
 */
// @ts-ignore
export function createSetCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSetCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Set}
 */
// @ts-ignore
export function createSetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StoreCollectionResponse}
 */
// @ts-ignore
export function createStoreCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStoreCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Store}
 */
// @ts-ignore
export function createStoreFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStore;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TermCollectionResponse}
 */
// @ts-ignore
export function createTermCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTermCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Term}
 */
// @ts-ignore
export function createTermFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTerm;
}
/**
 * The deserialization information for the current model
 * @param Group The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoGroup(group: Partial<Group> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(group),
        "createdDateTime": n => { group.createdDateTime = n.getDateValue(); },
        "description": n => { group.description = n.getStringValue(); },
        "displayName": n => { group.displayName = n.getStringValue(); },
        "parentSiteId": n => { group.parentSiteId = n.getStringValue(); },
        "scope": n => { group.scope = n.getEnumValue<TermGroupScope>(TermGroupScopeObject); },
        "sets": n => { group.sets = n.getCollectionOfObjectValues<Set>(createSetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param GroupCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoGroupCollectionResponse(groupCollectionResponse: Partial<GroupCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(groupCollectionResponse),
        "value": n => { groupCollectionResponse.value = n.getCollectionOfObjectValues<Group>(createGroupFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param LocalizedDescription The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoLocalizedDescription(localizedDescription: Partial<LocalizedDescription> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { localizedDescription.backingStoreEnabled = true; },
        "description": n => { localizedDescription.description = n.getStringValue(); },
        "languageTag": n => { localizedDescription.languageTag = n.getStringValue(); },
        "@odata.type": n => { localizedDescription.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param LocalizedLabel The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoLocalizedLabel(localizedLabel: Partial<LocalizedLabel> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { localizedLabel.backingStoreEnabled = true; },
        "isDefault": n => { localizedLabel.isDefault = n.getBooleanValue(); },
        "languageTag": n => { localizedLabel.languageTag = n.getStringValue(); },
        "name": n => { localizedLabel.name = n.getStringValue(); },
        "@odata.type": n => { localizedLabel.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param LocalizedName The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoLocalizedName(localizedName: Partial<LocalizedName> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { localizedName.backingStoreEnabled = true; },
        "languageTag": n => { localizedName.languageTag = n.getStringValue(); },
        "name": n => { localizedName.name = n.getStringValue(); },
        "@odata.type": n => { localizedName.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param Relation The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelation(relation: Partial<Relation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(relation),
        "fromTerm": n => { relation.fromTerm = n.getObjectValue<Term>(createTermFromDiscriminatorValue); },
        "relationship": n => { relation.relationship = n.getEnumValue<RelationType>(RelationTypeObject); },
        "set": n => { relation.set = n.getObjectValue<Set>(createSetFromDiscriminatorValue); },
        "toTerm": n => { relation.toTerm = n.getObjectValue<Term>(createTermFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelationCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelationCollectionResponse(relationCollectionResponse: Partial<RelationCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(relationCollectionResponse),
        "value": n => { relationCollectionResponse.value = n.getCollectionOfObjectValues<Relation>(createRelationFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Set The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSet(set: Partial<Set> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(set),
        "children": n => { set.children = n.getCollectionOfObjectValues<Term>(createTermFromDiscriminatorValue); },
        "createdDateTime": n => { set.createdDateTime = n.getDateValue(); },
        "description": n => { set.description = n.getStringValue(); },
        "localizedNames": n => { set.localizedNames = n.getCollectionOfObjectValues<LocalizedName>(createLocalizedNameFromDiscriminatorValue); },
        "parentGroup": n => { set.parentGroup = n.getObjectValue<Group>(createGroupFromDiscriminatorValue); },
        "properties": n => { set.properties = n.getCollectionOfObjectValues<KeyValue>(createKeyValueFromDiscriminatorValue); },
        "relations": n => { set.relations = n.getCollectionOfObjectValues<Relation>(createRelationFromDiscriminatorValue); },
        "terms": n => { set.terms = n.getCollectionOfObjectValues<Term>(createTermFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param SetCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSetCollectionResponse(setCollectionResponse: Partial<SetCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(setCollectionResponse),
        "value": n => { setCollectionResponse.value = n.getCollectionOfObjectValues<Set>(createSetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Store The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStore(store: Partial<Store> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(store),
        "defaultLanguageTag": n => { store.defaultLanguageTag = n.getStringValue(); },
        "groups": n => { store.groups = n.getCollectionOfObjectValues<Group>(createGroupFromDiscriminatorValue); },
        "languageTags": n => { store.languageTags = n.getCollectionOfPrimitiveValues<string>(); },
        "sets": n => { store.sets = n.getCollectionOfObjectValues<Set>(createSetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param StoreCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStoreCollectionResponse(storeCollectionResponse: Partial<StoreCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(storeCollectionResponse),
        "value": n => { storeCollectionResponse.value = n.getCollectionOfObjectValues<Store>(createStoreFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Term The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTerm(term: Partial<Term> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(term),
        "children": n => { term.children = n.getCollectionOfObjectValues<Term>(createTermFromDiscriminatorValue); },
        "createdDateTime": n => { term.createdDateTime = n.getDateValue(); },
        "descriptions": n => { term.descriptions = n.getCollectionOfObjectValues<LocalizedDescription>(createLocalizedDescriptionFromDiscriminatorValue); },
        "labels": n => { term.labels = n.getCollectionOfObjectValues<LocalizedLabel>(createLocalizedLabelFromDiscriminatorValue); },
        "lastModifiedDateTime": n => { term.lastModifiedDateTime = n.getDateValue(); },
        "properties": n => { term.properties = n.getCollectionOfObjectValues<KeyValue>(createKeyValueFromDiscriminatorValue); },
        "relations": n => { term.relations = n.getCollectionOfObjectValues<Relation>(createRelationFromDiscriminatorValue); },
        "set": n => { term.set = n.getObjectValue<Set>(createSetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param TermCollectionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTermCollectionResponse(termCollectionResponse: Partial<TermCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(termCollectionResponse),
        "value": n => { termCollectionResponse.value = n.getCollectionOfObjectValues<Term>(createTermFromDiscriminatorValue); },
    }
}
export interface Group extends Entity, Parsable {
    /**
     * Date and time of the group creation. Read-only.
     */
    createdDateTime?: Date | null;
    /**
     * Description that gives details on the term usage.
     */
    description?: string | null;
    /**
     * Name of the group.
     */
    displayName?: string | null;
    /**
     * ID of the parent site of this group.
     */
    parentSiteId?: string | null;
    /**
     * Returns the type of the group. The possible values are: global, system, and siteCollection.
     */
    scope?: TermGroupScope | null;
    /**
     * All sets under the group in a term [store].
     */
    sets?: Set[] | null;
}
export interface GroupCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Group[] | null;
}
export interface LocalizedDescription extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The description in the localized language.
     */
    description?: string | null;
    /**
     * The language tag for the label.
     */
    languageTag?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface LocalizedLabel extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * Indicates whether the label is the default label.
     */
    isDefault?: boolean | null;
    /**
     * The language tag for the label.
     */
    languageTag?: string | null;
    /**
     * The name of the label.
     */
    name?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface LocalizedName extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean | null;
    /**
     * The language tag for the label.
     */
    languageTag?: string | null;
    /**
     * The name in the localized language.
     */
    name?: string | null;
    /**
     * The OdataType property
     */
    odataType?: string | null;
}
export interface Relation extends Entity, Parsable {
    /**
     * The from [term] of the relation. The term from which the relationship is defined. A null value would indicate the relation is directly with the [set].
     */
    fromTerm?: Term | null;
    /**
     * The type of relation. The possible values are: pin, reuse.
     */
    relationship?: RelationType | null;
    /**
     * The [set] in which the relation is relevant.
     */
    set?: Set | null;
    /**
     * The to [term] of the relation. The term to which the relationship is defined.
     */
    toTerm?: Term | null;
}
export interface RelationCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Relation[] | null;
}
export type RelationType = (typeof RelationTypeObject)[keyof typeof RelationTypeObject];
/**
 * Serializes information the current object
 * @param Group The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeGroup(writer: SerializationWriter, group: Partial<Group> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!group || isSerializingDerivedType) { return; }
    serializeEntity(writer, group, isSerializingDerivedType)
    writer.writeDateValue("createdDateTime", group.createdDateTime);
    writer.writeStringValue("description", group.description);
    writer.writeStringValue("displayName", group.displayName);
    writer.writeStringValue("parentSiteId", group.parentSiteId);
    writer.writeEnumValue<TermGroupScope>("scope", group.scope);
    writer.writeCollectionOfObjectValues<Set>("sets", group.sets, serializeSet);
}
/**
 * Serializes information the current object
 * @param GroupCollectionResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeGroupCollectionResponse(writer: SerializationWriter, groupCollectionResponse: Partial<GroupCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!groupCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, groupCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Group>("value", groupCollectionResponse.value, serializeGroup);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param LocalizedDescription The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeLocalizedDescription(writer: SerializationWriter, localizedDescription: Partial<LocalizedDescription> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!localizedDescription || isSerializingDerivedType) { return; }
    writer.writeStringValue("description", localizedDescription.description);
    writer.writeStringValue("languageTag", localizedDescription.languageTag);
    writer.writeStringValue("@odata.type", localizedDescription.odataType);
    writer.writeAdditionalData(localizedDescription.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param LocalizedLabel The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeLocalizedLabel(writer: SerializationWriter, localizedLabel: Partial<LocalizedLabel> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!localizedLabel || isSerializingDerivedType) { return; }
    writer.writeBooleanValue("isDefault", localizedLabel.isDefault);
    writer.writeStringValue("languageTag", localizedLabel.languageTag);
    writer.writeStringValue("name", localizedLabel.name);
    writer.writeStringValue("@odata.type", localizedLabel.odataType);
    writer.writeAdditionalData(localizedLabel.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param LocalizedName The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeLocalizedName(writer: SerializationWriter, localizedName: Partial<LocalizedName> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!localizedName || isSerializingDerivedType) { return; }
    writer.writeStringValue("languageTag", localizedName.languageTag);
    writer.writeStringValue("name", localizedName.name);
    writer.writeStringValue("@odata.type", localizedName.odataType);
    writer.writeAdditionalData(localizedName.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Relation The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelation(writer: SerializationWriter, relation: Partial<Relation> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relation || isSerializingDerivedType) { return; }
    serializeEntity(writer, relation, isSerializingDerivedType)
    writer.writeObjectValue<Term>("fromTerm", relation.fromTerm, serializeTerm);
    writer.writeEnumValue<RelationType>("relationship", relation.relationship);
    writer.writeObjectValue<Set>("set", relation.set, serializeSet);
    writer.writeObjectValue<Term>("toTerm", relation.toTerm, serializeTerm);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelationCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelationCollectionResponse(writer: SerializationWriter, relationCollectionResponse: Partial<RelationCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relationCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, relationCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Relation>("value", relationCollectionResponse.value, serializeRelation);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Set The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSet(writer: SerializationWriter, set: Partial<Set> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!set || isSerializingDerivedType) { return; }
    serializeEntity(writer, set, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Term>("children", set.children, serializeTerm);
    writer.writeDateValue("createdDateTime", set.createdDateTime);
    writer.writeStringValue("description", set.description);
    writer.writeCollectionOfObjectValues<LocalizedName>("localizedNames", set.localizedNames, serializeLocalizedName);
    writer.writeObjectValue<Group>("parentGroup", set.parentGroup, serializeGroup);
    writer.writeCollectionOfObjectValues<KeyValue>("properties", set.properties, serializeKeyValue);
    writer.writeCollectionOfObjectValues<Relation>("relations", set.relations, serializeRelation);
    writer.writeCollectionOfObjectValues<Term>("terms", set.terms, serializeTerm);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SetCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSetCollectionResponse(writer: SerializationWriter, setCollectionResponse: Partial<SetCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!setCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, setCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Set>("value", setCollectionResponse.value, serializeSet);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Store The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStore(writer: SerializationWriter, store: Partial<Store> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!store || isSerializingDerivedType) { return; }
    serializeEntity(writer, store, isSerializingDerivedType)
    writer.writeStringValue("defaultLanguageTag", store.defaultLanguageTag);
    writer.writeCollectionOfObjectValues<Group>("groups", store.groups, serializeGroup);
    writer.writeCollectionOfPrimitiveValues<string>("languageTags", store.languageTags);
    writer.writeCollectionOfObjectValues<Set>("sets", store.sets, serializeSet);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param StoreCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStoreCollectionResponse(writer: SerializationWriter, storeCollectionResponse: Partial<StoreCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!storeCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, storeCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Store>("value", storeCollectionResponse.value, serializeStore);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Term The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTerm(writer: SerializationWriter, term: Partial<Term> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!term || isSerializingDerivedType) { return; }
    serializeEntity(writer, term, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Term>("children", term.children, serializeTerm);
    writer.writeDateValue("createdDateTime", term.createdDateTime);
    writer.writeCollectionOfObjectValues<LocalizedDescription>("descriptions", term.descriptions, serializeLocalizedDescription);
    writer.writeCollectionOfObjectValues<LocalizedLabel>("labels", term.labels, serializeLocalizedLabel);
    writer.writeDateValue("lastModifiedDateTime", term.lastModifiedDateTime);
    writer.writeCollectionOfObjectValues<KeyValue>("properties", term.properties, serializeKeyValue);
    writer.writeCollectionOfObjectValues<Relation>("relations", term.relations, serializeRelation);
    writer.writeObjectValue<Set>("set", term.set, serializeSet);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TermCollectionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTermCollectionResponse(writer: SerializationWriter, termCollectionResponse: Partial<TermCollectionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!termCollectionResponse || isSerializingDerivedType) { return; }
    serializeBaseCollectionPaginationCountResponse(writer, termCollectionResponse, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<Term>("value", termCollectionResponse.value, serializeTerm);
}
export interface Set extends Entity, Parsable {
    /**
     * Children terms of set in term [store].
     */
    children?: Term[] | null;
    /**
     * Date and time of set creation. Read-only.
     */
    createdDateTime?: Date | null;
    /**
     * Description that gives details on the term usage.
     */
    description?: string | null;
    /**
     * Name of the set for each languageTag.
     */
    localizedNames?: LocalizedName[] | null;
    /**
     * The parentGroup property
     */
    parentGroup?: Group | null;
    /**
     * Custom properties for the set.
     */
    properties?: KeyValue[] | null;
    /**
     * Indicates which terms have been pinned or reused directly under the set.
     */
    relations?: Relation[] | null;
    /**
     * All the terms under the set.
     */
    terms?: Term[] | null;
}
export interface SetCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Set[] | null;
}
export interface Store extends Entity, Parsable {
    /**
     * Default language of the term store.
     */
    defaultLanguageTag?: string | null;
    /**
     * Collection of all groups available in the term store.
     */
    groups?: Group[] | null;
    /**
     * List of languages for the term store.
     */
    languageTags?: string[] | null;
    /**
     * Collection of all sets available in the term store. This relationship can only be used to load a specific term set.
     */
    sets?: Set[] | null;
}
export interface StoreCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Store[] | null;
}
export interface Term extends Entity, Parsable {
    /**
     * Children of current term.
     */
    children?: Term[] | null;
    /**
     * Date and time of term creation. Read-only.
     */
    createdDateTime?: Date | null;
    /**
     * Description about term that is dependent on the languageTag.
     */
    descriptions?: LocalizedDescription[] | null;
    /**
     * Label metadata for a term.
     */
    labels?: LocalizedLabel[] | null;
    /**
     * Last date and time of term modification. Read-only.
     */
    lastModifiedDateTime?: Date | null;
    /**
     * Collection of properties on the term.
     */
    properties?: KeyValue[] | null;
    /**
     * To indicate which terms are related to the current term as either pinned or reused.
     */
    relations?: Relation[] | null;
    /**
     * The [set] in which the term is created.
     */
    set?: Set | null;
}
export interface TermCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Term[] | null;
}
export type TermGroupScope = (typeof TermGroupScopeObject)[keyof typeof TermGroupScopeObject];
export const RelationTypeObject = {
    Pin: "pin",
    Reuse: "reuse",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const TermGroupScopeObject = {
    Global: "global",
    System: "system",
    SiteCollection: "siteCollection",
    UnknownFutureValue: "unknownFutureValue",
} as const;
/* tslint:enable */
/* eslint-enable */
