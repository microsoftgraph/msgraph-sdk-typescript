/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createIdentitySetFromDiscriminatorValue, deserializeIntoBaseCollectionPaginationCountResponse, deserializeIntoEntity, serializeBaseCollectionPaginationCountResponse, serializeEntity, serializeIdentitySet, type BaseCollectionPaginationCountResponse, type Entity, type IdentitySet } from '../';
// @ts-ignore
import { type AdditionalDataHolder, type BackedModel, type BackingStore, type Duration, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export type AudioCodec = (typeof AudioCodecObject)[keyof typeof AudioCodecObject];
export interface CallRecord extends Entity, Parsable {
    /**
     * UTC time when the last user left the call. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    endDateTime?: Date;
    /**
     * Meeting URL associated to the call. May not be available for a peerToPeer call record type.
     */
    joinWebUrl?: string;
    /**
     * UTC time when the call record was created. The DatetimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    lastModifiedDateTime?: Date;
    /**
     * List of all the modalities used in the call. Possible values are: unknown, audio, video, videoBasedScreenSharing, data, screenSharing, unknownFutureValue.
     */
    modalities?: Modality[];
    /**
     * The organizing party's identity.
     */
    organizer?: IdentitySet;
    /**
     * List of distinct identities involved in the call.
     */
    participants?: IdentitySet[];
    /**
     * List of sessions involved in the call. Peer-to-peer calls typically only have one session, whereas group calls typically have at least one session per participant. Read-only. Nullable.
     */
    sessions?: Session[];
    /**
     * UTC time when the first user joined the call. The DatetimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    startDateTime?: Date;
    /**
     * The type property
     */
    type?: CallType;
    /**
     * Monotonically increasing version of the call record. Higher version call records with the same id includes additional data compared to the lower version.
     */
    version?: number;
}
export interface CallRecordCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: CallRecord[];
}
export type CallType = (typeof CallTypeObject)[keyof typeof CallTypeObject];
export type ClientPlatform = (typeof ClientPlatformObject)[keyof typeof ClientPlatformObject];
export interface ClientUserAgent extends Parsable, UserAgent {
    /**
     * The unique identifier of the Microsoft Entra application used by this endpoint.
     */
    azureADAppId?: string;
    /**
     * Immutable resource identifier of the Azure Communication Service associated with this endpoint based on Communication Services APIs.
     */
    communicationServiceId?: string;
    /**
     * The platform property
     */
    platform?: ClientPlatform;
    /**
     * The productFamily property
     */
    productFamily?: ProductFamily;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CallRecordCollectionResponse}
 */
export function createCallRecordCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCallRecordCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CallRecord}
 */
export function createCallRecordFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCallRecord;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ClientUserAgent}
 */
export function createClientUserAgentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoClientUserAgent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeviceInfo}
 */
export function createDeviceInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeviceInfo;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DirectRoutingLogRow}
 */
export function createDirectRoutingLogRowFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDirectRoutingLogRow;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Endpoint}
 */
export function createEndpointFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.callRecords.participantEndpoint":
                    return deserializeIntoParticipantEndpoint;
                case "#microsoft.graph.callRecords.serviceEndpoint":
                    return deserializeIntoServiceEndpoint;
            }
        }
    }
    return deserializeIntoEndpoint;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FailureInfo}
 */
export function createFailureInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFailureInfo;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FeedbackTokenSet}
 */
export function createFeedbackTokenSetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFeedbackTokenSet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Media}
 */
export function createMediaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMedia;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MediaStream}
 */
export function createMediaStreamFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMediaStream;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NetworkInfo}
 */
export function createNetworkInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNetworkInfo;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ParticipantEndpoint}
 */
export function createParticipantEndpointFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoParticipantEndpoint;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PstnCallLogRow}
 */
export function createPstnCallLogRowFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPstnCallLogRow;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SegmentCollectionResponse}
 */
export function createSegmentCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSegmentCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Segment}
 */
export function createSegmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSegment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ServiceEndpoint}
 */
export function createServiceEndpointFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoServiceEndpoint;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ServiceUserAgent}
 */
export function createServiceUserAgentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoServiceUserAgent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SessionCollectionResponse}
 */
export function createSessionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSessionCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Session}
 */
export function createSessionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSession;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TraceRouteHop}
 */
export function createTraceRouteHopFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTraceRouteHop;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserAgent}
 */
export function createUserAgentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.callRecords.clientUserAgent":
                    return deserializeIntoClientUserAgent;
                case "#microsoft.graph.callRecords.serviceUserAgent":
                    return deserializeIntoServiceUserAgent;
            }
        }
    }
    return deserializeIntoUserAgent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserFeedback}
 */
export function createUserFeedbackFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserFeedback;
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCallRecord(callRecord: Partial<CallRecord> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(callRecord),
        "endDateTime": n => { callRecord.endDateTime = n.getDateValue(); },
        "joinWebUrl": n => { callRecord.joinWebUrl = n.getStringValue(); },
        "lastModifiedDateTime": n => { callRecord.lastModifiedDateTime = n.getDateValue(); },
        "modalities": n => { callRecord.modalities = n.getCollectionOfEnumValues<Modality>(ModalityObject); },
        "organizer": n => { callRecord.organizer = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "participants": n => { callRecord.participants = n.getCollectionOfObjectValues<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "sessions": n => { callRecord.sessions = n.getCollectionOfObjectValues<Session>(createSessionFromDiscriminatorValue); },
        "startDateTime": n => { callRecord.startDateTime = n.getDateValue(); },
        "type": n => { callRecord.type = n.getEnumValue<CallType>(CallTypeObject); },
        "version": n => { callRecord.version = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCallRecordCollectionResponse(callRecordCollectionResponse: Partial<CallRecordCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(callRecordCollectionResponse),
        "value": n => { callRecordCollectionResponse.value = n.getCollectionOfObjectValues<CallRecord>(createCallRecordFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoClientUserAgent(clientUserAgent: Partial<ClientUserAgent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoUserAgent(clientUserAgent),
        "azureADAppId": n => { clientUserAgent.azureADAppId = n.getStringValue(); },
        "communicationServiceId": n => { clientUserAgent.communicationServiceId = n.getStringValue(); },
        "platform": n => { clientUserAgent.platform = n.getEnumValue<ClientPlatform>(ClientPlatformObject); },
        "productFamily": n => { clientUserAgent.productFamily = n.getEnumValue<ProductFamily>(ProductFamilyObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDeviceInfo(deviceInfo: Partial<DeviceInfo> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { deviceInfo.backingStoreEnabled = true; },
        "captureDeviceDriver": n => { deviceInfo.captureDeviceDriver = n.getStringValue(); },
        "captureDeviceName": n => { deviceInfo.captureDeviceName = n.getStringValue(); },
        "captureNotFunctioningEventRatio": n => { deviceInfo.captureNotFunctioningEventRatio = n.getNumberValue(); },
        "cpuInsufficentEventRatio": n => { deviceInfo.cpuInsufficentEventRatio = n.getNumberValue(); },
        "deviceClippingEventRatio": n => { deviceInfo.deviceClippingEventRatio = n.getNumberValue(); },
        "deviceGlitchEventRatio": n => { deviceInfo.deviceGlitchEventRatio = n.getNumberValue(); },
        "howlingEventCount": n => { deviceInfo.howlingEventCount = n.getNumberValue(); },
        "initialSignalLevelRootMeanSquare": n => { deviceInfo.initialSignalLevelRootMeanSquare = n.getNumberValue(); },
        "lowSpeechLevelEventRatio": n => { deviceInfo.lowSpeechLevelEventRatio = n.getNumberValue(); },
        "lowSpeechToNoiseEventRatio": n => { deviceInfo.lowSpeechToNoiseEventRatio = n.getNumberValue(); },
        "micGlitchRate": n => { deviceInfo.micGlitchRate = n.getNumberValue(); },
        "@odata.type": n => { deviceInfo.odataType = n.getStringValue(); },
        "receivedNoiseLevel": n => { deviceInfo.receivedNoiseLevel = n.getNumberValue(); },
        "receivedSignalLevel": n => { deviceInfo.receivedSignalLevel = n.getNumberValue(); },
        "renderDeviceDriver": n => { deviceInfo.renderDeviceDriver = n.getStringValue(); },
        "renderDeviceName": n => { deviceInfo.renderDeviceName = n.getStringValue(); },
        "renderMuteEventRatio": n => { deviceInfo.renderMuteEventRatio = n.getNumberValue(); },
        "renderNotFunctioningEventRatio": n => { deviceInfo.renderNotFunctioningEventRatio = n.getNumberValue(); },
        "renderZeroVolumeEventRatio": n => { deviceInfo.renderZeroVolumeEventRatio = n.getNumberValue(); },
        "sentNoiseLevel": n => { deviceInfo.sentNoiseLevel = n.getNumberValue(); },
        "sentSignalLevel": n => { deviceInfo.sentSignalLevel = n.getNumberValue(); },
        "speakerGlitchRate": n => { deviceInfo.speakerGlitchRate = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDirectRoutingLogRow(directRoutingLogRow: Partial<DirectRoutingLogRow> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { directRoutingLogRow.backingStoreEnabled = true; },
        "calleeNumber": n => { directRoutingLogRow.calleeNumber = n.getStringValue(); },
        "callEndSubReason": n => { directRoutingLogRow.callEndSubReason = n.getNumberValue(); },
        "callerNumber": n => { directRoutingLogRow.callerNumber = n.getStringValue(); },
        "callType": n => { directRoutingLogRow.callType = n.getStringValue(); },
        "correlationId": n => { directRoutingLogRow.correlationId = n.getStringValue(); },
        "duration": n => { directRoutingLogRow.duration = n.getNumberValue(); },
        "endDateTime": n => { directRoutingLogRow.endDateTime = n.getDateValue(); },
        "failureDateTime": n => { directRoutingLogRow.failureDateTime = n.getDateValue(); },
        "finalSipCode": n => { directRoutingLogRow.finalSipCode = n.getNumberValue(); },
        "finalSipCodePhrase": n => { directRoutingLogRow.finalSipCodePhrase = n.getStringValue(); },
        "id": n => { directRoutingLogRow.id = n.getStringValue(); },
        "inviteDateTime": n => { directRoutingLogRow.inviteDateTime = n.getDateValue(); },
        "mediaBypassEnabled": n => { directRoutingLogRow.mediaBypassEnabled = n.getBooleanValue(); },
        "mediaPathLocation": n => { directRoutingLogRow.mediaPathLocation = n.getStringValue(); },
        "@odata.type": n => { directRoutingLogRow.odataType = n.getStringValue(); },
        "signalingLocation": n => { directRoutingLogRow.signalingLocation = n.getStringValue(); },
        "startDateTime": n => { directRoutingLogRow.startDateTime = n.getDateValue(); },
        "successfulCall": n => { directRoutingLogRow.successfulCall = n.getBooleanValue(); },
        "trunkFullyQualifiedDomainName": n => { directRoutingLogRow.trunkFullyQualifiedDomainName = n.getStringValue(); },
        "userDisplayName": n => { directRoutingLogRow.userDisplayName = n.getStringValue(); },
        "userId": n => { directRoutingLogRow.userId = n.getStringValue(); },
        "userPrincipalName": n => { directRoutingLogRow.userPrincipalName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEndpoint(endpoint: Partial<Endpoint> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { endpoint.backingStoreEnabled = true; },
        "@odata.type": n => { endpoint.odataType = n.getStringValue(); },
        "userAgent": n => { endpoint.userAgent = n.getObjectValue<UserAgent>(createUserAgentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFailureInfo(failureInfo: Partial<FailureInfo> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { failureInfo.backingStoreEnabled = true; },
        "@odata.type": n => { failureInfo.odataType = n.getStringValue(); },
        "reason": n => { failureInfo.reason = n.getStringValue(); },
        "stage": n => { failureInfo.stage = n.getEnumValue<FailureStage>(FailureStageObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFeedbackTokenSet(feedbackTokenSet: Partial<FeedbackTokenSet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { feedbackTokenSet.backingStoreEnabled = true; },
        "@odata.type": n => { feedbackTokenSet.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMedia(media: Partial<Media> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { media.backingStoreEnabled = true; },
        "calleeDevice": n => { media.calleeDevice = n.getObjectValue<DeviceInfo>(createDeviceInfoFromDiscriminatorValue); },
        "calleeNetwork": n => { media.calleeNetwork = n.getObjectValue<NetworkInfo>(createNetworkInfoFromDiscriminatorValue); },
        "callerDevice": n => { media.callerDevice = n.getObjectValue<DeviceInfo>(createDeviceInfoFromDiscriminatorValue); },
        "callerNetwork": n => { media.callerNetwork = n.getObjectValue<NetworkInfo>(createNetworkInfoFromDiscriminatorValue); },
        "label": n => { media.label = n.getStringValue(); },
        "@odata.type": n => { media.odataType = n.getStringValue(); },
        "streams": n => { media.streams = n.getCollectionOfObjectValues<MediaStream>(createMediaStreamFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMediaStream(mediaStream: Partial<MediaStream> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "audioCodec": n => { mediaStream.audioCodec = n.getEnumValue<AudioCodec>(AudioCodecObject); },
        "averageAudioDegradation": n => { mediaStream.averageAudioDegradation = n.getNumberValue(); },
        "averageAudioNetworkJitter": n => { mediaStream.averageAudioNetworkJitter = n.getDurationValue(); },
        "averageBandwidthEstimate": n => { mediaStream.averageBandwidthEstimate = n.getNumberValue(); },
        "averageFreezeDuration": n => { mediaStream.averageFreezeDuration = n.getDurationValue(); },
        "averageJitter": n => { mediaStream.averageJitter = n.getDurationValue(); },
        "averagePacketLossRate": n => { mediaStream.averagePacketLossRate = n.getNumberValue(); },
        "averageRatioOfConcealedSamples": n => { mediaStream.averageRatioOfConcealedSamples = n.getNumberValue(); },
        "averageReceivedFrameRate": n => { mediaStream.averageReceivedFrameRate = n.getNumberValue(); },
        "averageRoundTripTime": n => { mediaStream.averageRoundTripTime = n.getDurationValue(); },
        "averageVideoFrameLossPercentage": n => { mediaStream.averageVideoFrameLossPercentage = n.getNumberValue(); },
        "averageVideoFrameRate": n => { mediaStream.averageVideoFrameRate = n.getNumberValue(); },
        "averageVideoPacketLossRate": n => { mediaStream.averageVideoPacketLossRate = n.getNumberValue(); },
        "backingStoreEnabled": n => { mediaStream.backingStoreEnabled = true; },
        "endDateTime": n => { mediaStream.endDateTime = n.getDateValue(); },
        "isAudioForwardErrorCorrectionUsed": n => { mediaStream.isAudioForwardErrorCorrectionUsed = n.getBooleanValue(); },
        "lowFrameRateRatio": n => { mediaStream.lowFrameRateRatio = n.getNumberValue(); },
        "lowVideoProcessingCapabilityRatio": n => { mediaStream.lowVideoProcessingCapabilityRatio = n.getNumberValue(); },
        "maxAudioNetworkJitter": n => { mediaStream.maxAudioNetworkJitter = n.getDurationValue(); },
        "maxJitter": n => { mediaStream.maxJitter = n.getDurationValue(); },
        "maxPacketLossRate": n => { mediaStream.maxPacketLossRate = n.getNumberValue(); },
        "maxRatioOfConcealedSamples": n => { mediaStream.maxRatioOfConcealedSamples = n.getNumberValue(); },
        "maxRoundTripTime": n => { mediaStream.maxRoundTripTime = n.getDurationValue(); },
        "@odata.type": n => { mediaStream.odataType = n.getStringValue(); },
        "packetUtilization": n => { mediaStream.packetUtilization = n.getNumberValue(); },
        "postForwardErrorCorrectionPacketLossRate": n => { mediaStream.postForwardErrorCorrectionPacketLossRate = n.getNumberValue(); },
        "rmsFreezeDuration": n => { mediaStream.rmsFreezeDuration = n.getDurationValue(); },
        "startDateTime": n => { mediaStream.startDateTime = n.getDateValue(); },
        "streamDirection": n => { mediaStream.streamDirection = n.getEnumValue<MediaStreamDirection>(MediaStreamDirectionObject); },
        "streamId": n => { mediaStream.streamId = n.getStringValue(); },
        "videoCodec": n => { mediaStream.videoCodec = n.getEnumValue<VideoCodec>(VideoCodecObject); },
        "wasMediaBypassed": n => { mediaStream.wasMediaBypassed = n.getBooleanValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoNetworkInfo(networkInfo: Partial<NetworkInfo> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { networkInfo.backingStoreEnabled = true; },
        "bandwidthLowEventRatio": n => { networkInfo.bandwidthLowEventRatio = n.getNumberValue(); },
        "basicServiceSetIdentifier": n => { networkInfo.basicServiceSetIdentifier = n.getStringValue(); },
        "connectionType": n => { networkInfo.connectionType = n.getEnumValue<NetworkConnectionType>(NetworkConnectionTypeObject); },
        "delayEventRatio": n => { networkInfo.delayEventRatio = n.getNumberValue(); },
        "dnsSuffix": n => { networkInfo.dnsSuffix = n.getStringValue(); },
        "ipAddress": n => { networkInfo.ipAddress = n.getStringValue(); },
        "linkSpeed": n => { networkInfo.linkSpeed = n.getNumberValue(); },
        "macAddress": n => { networkInfo.macAddress = n.getStringValue(); },
        "networkTransportProtocol": n => { networkInfo.networkTransportProtocol = n.getEnumValue<NetworkTransportProtocol>(NetworkTransportProtocolObject); },
        "@odata.type": n => { networkInfo.odataType = n.getStringValue(); },
        "port": n => { networkInfo.port = n.getNumberValue(); },
        "receivedQualityEventRatio": n => { networkInfo.receivedQualityEventRatio = n.getNumberValue(); },
        "reflexiveIPAddress": n => { networkInfo.reflexiveIPAddress = n.getStringValue(); },
        "relayIPAddress": n => { networkInfo.relayIPAddress = n.getStringValue(); },
        "relayPort": n => { networkInfo.relayPort = n.getNumberValue(); },
        "sentQualityEventRatio": n => { networkInfo.sentQualityEventRatio = n.getNumberValue(); },
        "subnet": n => { networkInfo.subnet = n.getStringValue(); },
        "traceRouteHops": n => { networkInfo.traceRouteHops = n.getCollectionOfObjectValues<TraceRouteHop>(createTraceRouteHopFromDiscriminatorValue); },
        "wifiBand": n => { networkInfo.wifiBand = n.getEnumValue<WifiBand>(WifiBandObject); },
        "wifiBatteryCharge": n => { networkInfo.wifiBatteryCharge = n.getNumberValue(); },
        "wifiChannel": n => { networkInfo.wifiChannel = n.getNumberValue(); },
        "wifiMicrosoftDriver": n => { networkInfo.wifiMicrosoftDriver = n.getStringValue(); },
        "wifiMicrosoftDriverVersion": n => { networkInfo.wifiMicrosoftDriverVersion = n.getStringValue(); },
        "wifiRadioType": n => { networkInfo.wifiRadioType = n.getEnumValue<WifiRadioType>(WifiRadioTypeObject); },
        "wifiSignalStrength": n => { networkInfo.wifiSignalStrength = n.getNumberValue(); },
        "wifiVendorDriver": n => { networkInfo.wifiVendorDriver = n.getStringValue(); },
        "wifiVendorDriverVersion": n => { networkInfo.wifiVendorDriverVersion = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoParticipantEndpoint(participantEndpoint: Partial<ParticipantEndpoint> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEndpoint(participantEndpoint),
        "cpuCoresCount": n => { participantEndpoint.cpuCoresCount = n.getNumberValue(); },
        "cpuName": n => { participantEndpoint.cpuName = n.getStringValue(); },
        "cpuProcessorSpeedInMhz": n => { participantEndpoint.cpuProcessorSpeedInMhz = n.getNumberValue(); },
        "feedback": n => { participantEndpoint.feedback = n.getObjectValue<UserFeedback>(createUserFeedbackFromDiscriminatorValue); },
        "identity": n => { participantEndpoint.identity = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "name": n => { participantEndpoint.name = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoPstnCallLogRow(pstnCallLogRow: Partial<PstnCallLogRow> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { pstnCallLogRow.backingStoreEnabled = true; },
        "callDurationSource": n => { pstnCallLogRow.callDurationSource = n.getEnumValue<PstnCallDurationSource>(PstnCallDurationSourceObject); },
        "calleeNumber": n => { pstnCallLogRow.calleeNumber = n.getStringValue(); },
        "callerNumber": n => { pstnCallLogRow.callerNumber = n.getStringValue(); },
        "callId": n => { pstnCallLogRow.callId = n.getStringValue(); },
        "callType": n => { pstnCallLogRow.callType = n.getStringValue(); },
        "charge": n => { pstnCallLogRow.charge = n.getNumberValue(); },
        "conferenceId": n => { pstnCallLogRow.conferenceId = n.getStringValue(); },
        "connectionCharge": n => { pstnCallLogRow.connectionCharge = n.getNumberValue(); },
        "currency": n => { pstnCallLogRow.currency = n.getStringValue(); },
        "destinationContext": n => { pstnCallLogRow.destinationContext = n.getStringValue(); },
        "destinationName": n => { pstnCallLogRow.destinationName = n.getStringValue(); },
        "duration": n => { pstnCallLogRow.duration = n.getNumberValue(); },
        "endDateTime": n => { pstnCallLogRow.endDateTime = n.getDateValue(); },
        "id": n => { pstnCallLogRow.id = n.getStringValue(); },
        "inventoryType": n => { pstnCallLogRow.inventoryType = n.getStringValue(); },
        "licenseCapability": n => { pstnCallLogRow.licenseCapability = n.getStringValue(); },
        "@odata.type": n => { pstnCallLogRow.odataType = n.getStringValue(); },
        "operator": n => { pstnCallLogRow.operator = n.getStringValue(); },
        "startDateTime": n => { pstnCallLogRow.startDateTime = n.getDateValue(); },
        "tenantCountryCode": n => { pstnCallLogRow.tenantCountryCode = n.getStringValue(); },
        "usageCountryCode": n => { pstnCallLogRow.usageCountryCode = n.getStringValue(); },
        "userDisplayName": n => { pstnCallLogRow.userDisplayName = n.getStringValue(); },
        "userId": n => { pstnCallLogRow.userId = n.getStringValue(); },
        "userPrincipalName": n => { pstnCallLogRow.userPrincipalName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSegment(segment: Partial<Segment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(segment),
        "callee": n => { segment.callee = n.getObjectValue<Endpoint>(createEndpointFromDiscriminatorValue); },
        "caller": n => { segment.caller = n.getObjectValue<Endpoint>(createEndpointFromDiscriminatorValue); },
        "endDateTime": n => { segment.endDateTime = n.getDateValue(); },
        "failureInfo": n => { segment.failureInfo = n.getObjectValue<FailureInfo>(createFailureInfoFromDiscriminatorValue); },
        "media": n => { segment.media = n.getCollectionOfObjectValues<Media>(createMediaFromDiscriminatorValue); },
        "startDateTime": n => { segment.startDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSegmentCollectionResponse(segmentCollectionResponse: Partial<SegmentCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(segmentCollectionResponse),
        "value": n => { segmentCollectionResponse.value = n.getCollectionOfObjectValues<Segment>(createSegmentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoServiceEndpoint(serviceEndpoint: Partial<ServiceEndpoint> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEndpoint(serviceEndpoint),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoServiceUserAgent(serviceUserAgent: Partial<ServiceUserAgent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoUserAgent(serviceUserAgent),
        "role": n => { serviceUserAgent.role = n.getEnumValue<ServiceRole>(ServiceRoleObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSession(session: Partial<Session> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(session),
        "callee": n => { session.callee = n.getObjectValue<Endpoint>(createEndpointFromDiscriminatorValue); },
        "caller": n => { session.caller = n.getObjectValue<Endpoint>(createEndpointFromDiscriminatorValue); },
        "endDateTime": n => { session.endDateTime = n.getDateValue(); },
        "failureInfo": n => { session.failureInfo = n.getObjectValue<FailureInfo>(createFailureInfoFromDiscriminatorValue); },
        "isTest": n => { session.isTest = n.getBooleanValue(); },
        "modalities": n => { session.modalities = n.getCollectionOfEnumValues<Modality>(ModalityObject); },
        "segments": n => { session.segments = n.getCollectionOfObjectValues<Segment>(createSegmentFromDiscriminatorValue); },
        "startDateTime": n => { session.startDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSessionCollectionResponse(sessionCollectionResponse: Partial<SessionCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(sessionCollectionResponse),
        "value": n => { sessionCollectionResponse.value = n.getCollectionOfObjectValues<Session>(createSessionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTraceRouteHop(traceRouteHop: Partial<TraceRouteHop> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { traceRouteHop.backingStoreEnabled = true; },
        "hopCount": n => { traceRouteHop.hopCount = n.getNumberValue(); },
        "ipAddress": n => { traceRouteHop.ipAddress = n.getStringValue(); },
        "@odata.type": n => { traceRouteHop.odataType = n.getStringValue(); },
        "roundTripTime": n => { traceRouteHop.roundTripTime = n.getDurationValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUserAgent(userAgent: Partial<UserAgent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "applicationVersion": n => { userAgent.applicationVersion = n.getStringValue(); },
        "backingStoreEnabled": n => { userAgent.backingStoreEnabled = true; },
        "headerValue": n => { userAgent.headerValue = n.getStringValue(); },
        "@odata.type": n => { userAgent.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUserFeedback(userFeedback: Partial<UserFeedback> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "backingStoreEnabled": n => { userFeedback.backingStoreEnabled = true; },
        "@odata.type": n => { userFeedback.odataType = n.getStringValue(); },
        "rating": n => { userFeedback.rating = n.getEnumValue<UserFeedbackRating>(UserFeedbackRatingObject); },
        "text": n => { userFeedback.text = n.getStringValue(); },
        "tokens": n => { userFeedback.tokens = n.getObjectValue<FeedbackTokenSet>(createFeedbackTokenSetFromDiscriminatorValue); },
    }
}
export interface DeviceInfo extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Name of the capture device driver used by the media endpoint.
     */
    captureDeviceDriver?: string;
    /**
     * Name of the capture device used by the media endpoint.
     */
    captureDeviceName?: string;
    /**
     * Fraction of the call that the media endpoint detected the capture device was not working properly.
     */
    captureNotFunctioningEventRatio?: number;
    /**
     * Fraction of the call that the media endpoint detected the CPU resources available were insufficient and caused poor quality of the audio sent and received.
     */
    cpuInsufficentEventRatio?: number;
    /**
     * Fraction of the call that the media endpoint detected clipping in the captured audio that caused poor quality of the audio being sent.
     */
    deviceClippingEventRatio?: number;
    /**
     * Fraction of the call that the media endpoint detected glitches or gaps in the audio played or captured that caused poor quality of the audio being sent or received.
     */
    deviceGlitchEventRatio?: number;
    /**
     * Number of times during the call that the media endpoint detected howling or screeching audio.
     */
    howlingEventCount?: number;
    /**
     * The root mean square (RMS) of the incoming signal of up to the first 30 seconds of the call.
     */
    initialSignalLevelRootMeanSquare?: number;
    /**
     * Fraction of the call that the media endpoint detected low speech level that caused poor quality of the audio being sent.
     */
    lowSpeechLevelEventRatio?: number;
    /**
     * Fraction of the call that the media endpoint detected low speech to noise level that caused poor quality of the audio being sent.
     */
    lowSpeechToNoiseEventRatio?: number;
    /**
     * Glitches per 5 minute interval for the media endpoint's microphone.
     */
    micGlitchRate?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Average energy level of received audio for audio classified as mono noise or left channel of stereo noise by the media endpoint.
     */
    receivedNoiseLevel?: number;
    /**
     * Average energy level of received audio for audio classified as mono speech, or left channel of stereo speech by the media endpoint.
     */
    receivedSignalLevel?: number;
    /**
     * Name of the render device driver used by the media endpoint.
     */
    renderDeviceDriver?: string;
    /**
     * Name of the render device used by the media endpoint.
     */
    renderDeviceName?: string;
    /**
     * Fraction of the call that media endpoint detected device render is muted.
     */
    renderMuteEventRatio?: number;
    /**
     * Fraction of the call that the media endpoint detected the render device was not working properly.
     */
    renderNotFunctioningEventRatio?: number;
    /**
     * Fraction of the call that media endpoint detected device render volume is set to 0.
     */
    renderZeroVolumeEventRatio?: number;
    /**
     * Average energy level of sent audio for audio classified as mono noise or left channel of stereo noise by the media endpoint.
     */
    sentNoiseLevel?: number;
    /**
     * Average energy level of sent audio for audio classified as mono speech, or left channel of stereo speech by the media endpoint.
     */
    sentSignalLevel?: number;
    /**
     * Glitches per 5 minute internal for the media endpoint's loudspeaker.
     */
    speakerGlitchRate?: number;
}
export interface DirectRoutingLogRow extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Number of the user or bot who received the call. E.164 format, but might include other data.
     */
    calleeNumber?: string;
    /**
     * In addition to the SIP codes, Microsoft has subcodes that indicate the specific issue.
     */
    callEndSubReason?: number;
    /**
     * Number of the user or bot who made the call. E.164 format, but might include other data.
     */
    callerNumber?: string;
    /**
     * Call type and direction.
     */
    callType?: string;
    /**
     * Identifier for the call that you can use when calling Microsoft Support. GUID.
     */
    correlationId?: string;
    /**
     * Duration of the call in seconds.
     */
    duration?: number;
    /**
     * Only exists for successful (fully established) calls. Time when call ended.
     */
    endDateTime?: Date;
    /**
     * Only exists for failed (not fully established) calls.
     */
    failureDateTime?: Date;
    /**
     * The final response code with which the call ended. For more information, see RFC 3261.
     */
    finalSipCode?: number;
    /**
     * Description of the SIP code and Microsoft subcode.
     */
    finalSipCodePhrase?: string;
    /**
     * Unique call identifier. GUID.
     */
    id?: string;
    /**
     * The date and time when the initial invite was sent.
     */
    inviteDateTime?: Date;
    /**
     * Indicates whether the trunk was enabled for media bypass.
     */
    mediaBypassEnabled?: boolean;
    /**
     * The datacenter used for media path in a nonbypass call.
     */
    mediaPathLocation?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The datacenter used for signaling for both bypass and nonbypass calls.
     */
    signalingLocation?: string;
    /**
     * Call start time.For failed and unanswered calls, this value can be equal to the invite or failure time.
     */
    startDateTime?: Date;
    /**
     * Success or attempt.
     */
    successfulCall?: boolean;
    /**
     * Fully qualified domain name of the session border controller.
     */
    trunkFullyQualifiedDomainName?: string;
    /**
     * Display name of the user.
     */
    userDisplayName?: string;
    /**
     * Calling user's ID in Microsoft Graph. This and other user information is null/empty for bot call types. GUID.
     */
    userId?: string;
    /**
     * UserPrincipalName (sign-in name) in Microsoft Entra ID. This value is usually the same as the user's SIP Address, and can be the same as the user's email address.
     */
    userPrincipalName?: string;
}
export interface Endpoint extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * User-agent reported by this endpoint.
     */
    userAgent?: UserAgent;
}
export interface FailureInfo extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Classification of why a call or portion of a call failed.
     */
    reason?: string;
    /**
     * The stage property
     */
    stage?: FailureStage;
}
export type FailureStage = (typeof FailureStageObject)[keyof typeof FailureStageObject];
export interface FeedbackTokenSet extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface Media extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Device information associated with the callee endpoint of this media.
     */
    calleeDevice?: DeviceInfo;
    /**
     * Network information associated with the callee endpoint of this media.
     */
    calleeNetwork?: NetworkInfo;
    /**
     * Device information associated with the caller endpoint of this media.
     */
    callerDevice?: DeviceInfo;
    /**
     * Network information associated with the caller endpoint of this media.
     */
    callerNetwork?: NetworkInfo;
    /**
     * How the media was identified during media negotiation stage.
     */
    label?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Network streams associated with this media.
     */
    streams?: MediaStream[];
}
export interface MediaStream extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Codec name used to encode audio for transmission on the network. Possible values are: unknown, invalid, cn, pcma, pcmu, amrWide, g722, g7221, g7221c, g729, multiChannelAudio, muchv2, opus, satin, satinFullband, rtAudio8, rtAudio16, silk, silkNarrow, silkWide, siren, xmsRta, unknownFutureValue.
     */
    audioCodec?: AudioCodec;
    /**
     * Average Network Mean Opinion Score degradation for stream. Represents how much the network loss and jitter has impacted the quality of received audio.
     */
    averageAudioDegradation?: number;
    /**
     * Average jitter for the stream computed as specified in [RFC 3550][], denoted in [ISO 8601][] format. For example, 1 second is denoted as 'PT1S', where 'P' is the duration designator, 'T' is the time designator, and 'S' is the second designator.
     */
    averageAudioNetworkJitter?: Duration;
    /**
     * Average estimated bandwidth available between two endpoints in bits per second.
     */
    averageBandwidthEstimate?: number;
    /**
     * Average duration of the received freezing time in the video stream.
     */
    averageFreezeDuration?: Duration;
    /**
     * Average jitter for the stream computed as specified in [RFC 3550][], denoted in [ISO 8601][] format. For example, 1 second is denoted as 'PT1S', where 'P' is the duration designator, 'T' is the time designator, and 'S' is the second designator.
     */
    averageJitter?: Duration;
    /**
     * Average packet loss rate for stream.
     */
    averagePacketLossRate?: number;
    /**
     * Ratio of the number of audio frames with samples generated by packet loss concealment to the total number of audio frames.
     */
    averageRatioOfConcealedSamples?: number;
    /**
     * Average frames per second received for all video streams computed over the duration of the session.
     */
    averageReceivedFrameRate?: number;
    /**
     * Average network propagation round-trip time computed as specified in [RFC 3550][], denoted in [ISO 8601][] format. For example, 1 second is denoted as 'PT1S', where 'P' is the duration designator, 'T' is the time designator, and 'S' is the second designator.
     */
    averageRoundTripTime?: Duration;
    /**
     * Average percentage of video frames lost as displayed to the user.
     */
    averageVideoFrameLossPercentage?: number;
    /**
     * Average frames per second received for a video stream, computed over the duration of the session.
     */
    averageVideoFrameRate?: number;
    /**
     * Average fraction of packets lost, as specified in [RFC 3550][], computed over the duration of the session.
     */
    averageVideoPacketLossRate?: number;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * UTC time when the stream ended. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. This field is only available for streams that use the SIP protocol.
     */
    endDateTime?: Date;
    /**
     * Indicates whether the forward error correction (FEC) was used at some point during the session. The default value is null.
     */
    isAudioForwardErrorCorrectionUsed?: boolean;
    /**
     * Fraction of the call where frame rate is less than 7.5 frames per second.
     */
    lowFrameRateRatio?: number;
    /**
     * Fraction of the call that the client is running less than 70% expected video processing capability.
     */
    lowVideoProcessingCapabilityRatio?: number;
    /**
     * Maximum of audio network jitter computed over each of the 20 second windows during the session, denoted in [ISO 8601][] format. For example, 1 second is denoted as 'PT1S', where 'P' is the duration designator, 'T' is the time designator, and 'S' is the second designator.
     */
    maxAudioNetworkJitter?: Duration;
    /**
     * Maximum jitter for the stream computed as specified in RFC 3550, denoted in [ISO 8601][] format. For example, 1 second is denoted as 'PT1S', where 'P' is the duration designator, 'T' is the time designator, and 'S' is the second designator.
     */
    maxJitter?: Duration;
    /**
     * Maximum packet loss rate for the stream.
     */
    maxPacketLossRate?: number;
    /**
     * Maximum ratio of packets concealed by the healer.
     */
    maxRatioOfConcealedSamples?: number;
    /**
     * Maximum network propagation round-trip time computed as specified in [RFC 3550][], denoted in [ISO 8601][] format. For example, 1 second is denoted as 'PT1S', where 'P' is the duration designator, 'T' is the time designator, and 'S' is the second designator.
     */
    maxRoundTripTime?: Duration;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Packet count for the stream.
     */
    packetUtilization?: number;
    /**
     * Packet loss rate after FEC has been applied aggregated across all video streams and codecs.
     */
    postForwardErrorCorrectionPacketLossRate?: number;
    /**
     * Average duration of the received freezing time in the video stream represented in root mean square.
     */
    rmsFreezeDuration?: Duration;
    /**
     * UTC time when the stream started. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z. This field is only available for streams that use the SIP protocol.
     */
    startDateTime?: Date;
    /**
     * The streamDirection property
     */
    streamDirection?: MediaStreamDirection;
    /**
     * Unique identifier for the stream.
     */
    streamId?: string;
    /**
     * Codec name used to encode video for transmission on the network. Possible values are: unknown, invalid, av1, h263, h264, h264s, h264uc, h265, rtvc1, rtVideo, xrtvc1, unknownFutureValue.
     */
    videoCodec?: VideoCodec;
    /**
     * True if the media stream bypassed the Mediation Server and went straight between client and PSTN Gateway/PBX, false otherwise.
     */
    wasMediaBypassed?: boolean;
}
export type MediaStreamDirection = (typeof MediaStreamDirectionObject)[keyof typeof MediaStreamDirectionObject];
export type Modality = (typeof ModalityObject)[keyof typeof ModalityObject];
export type NetworkConnectionType = (typeof NetworkConnectionTypeObject)[keyof typeof NetworkConnectionTypeObject];
export interface NetworkInfo extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * Fraction of the call that the media endpoint detected the available bandwidth or bandwidth policy was low enough to cause poor quality of the audio sent.
     */
    bandwidthLowEventRatio?: number;
    /**
     * The wireless LAN basic service set identifier of the media endpoint used to connect to the network.
     */
    basicServiceSetIdentifier?: string;
    /**
     * The connectionType property
     */
    connectionType?: NetworkConnectionType;
    /**
     * Fraction of the call that the media endpoint detected the network delay was significant enough to impact the ability to have real-time two-way communication.
     */
    delayEventRatio?: number;
    /**
     * DNS suffix associated with the network adapter of the media endpoint.
     */
    dnsSuffix?: string;
    /**
     * IP address of the media endpoint.
     */
    ipAddress?: string;
    /**
     * Link speed in bits per second reported by the network adapter used by the media endpoint.
     */
    linkSpeed?: number;
    /**
     * The media access control (MAC) address of the media endpoint's network device. This value may be missing or shown as 02:00:00:00:00:00 due to operating system privacy policies.
     */
    macAddress?: string;
    /**
     * The networkTransportProtocol property
     */
    networkTransportProtocol?: NetworkTransportProtocol;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Network port number used by media endpoint.
     */
    port?: number;
    /**
     * Fraction of the call that the media endpoint detected the network was causing poor quality of the audio received.
     */
    receivedQualityEventRatio?: number;
    /**
     * IP address of the media endpoint as seen by the media relay server. This is typically the public internet IP address associated to the endpoint.
     */
    reflexiveIPAddress?: string;
    /**
     * IP address of the media relay server allocated by the media endpoint.
     */
    relayIPAddress?: string;
    /**
     * Network port number allocated on the media relay server by the media endpoint.
     */
    relayPort?: number;
    /**
     * Fraction of the call that the media endpoint detected the network was causing poor quality of the audio sent.
     */
    sentQualityEventRatio?: number;
    /**
     * Subnet used for media stream by the media endpoint.
     */
    subnet?: string;
    /**
     * List of network trace route hops collected for this media stream.*
     */
    traceRouteHops?: TraceRouteHop[];
    /**
     * The wifiBand property
     */
    wifiBand?: WifiBand;
    /**
     * Estimated remaining battery charge in percentage reported by the media endpoint.
     */
    wifiBatteryCharge?: number;
    /**
     * WiFi channel used by the media endpoint.
     */
    wifiChannel?: number;
    /**
     * Name of the Microsoft WiFi driver used by the media endpoint. Value may be localized based on the language used by endpoint.
     */
    wifiMicrosoftDriver?: string;
    /**
     * Version of the Microsoft WiFi driver used by the media endpoint.
     */
    wifiMicrosoftDriverVersion?: string;
    /**
     * The wifiRadioType property
     */
    wifiRadioType?: WifiRadioType;
    /**
     * WiFi signal strength in percentage reported by the media endpoint.
     */
    wifiSignalStrength?: number;
    /**
     * Name of the WiFi driver used by the media endpoint. Value may be localized based on the language used by endpoint.
     */
    wifiVendorDriver?: string;
    /**
     * Version of the WiFi driver used by the media endpoint.
     */
    wifiVendorDriverVersion?: string;
}
export type NetworkTransportProtocol = (typeof NetworkTransportProtocolObject)[keyof typeof NetworkTransportProtocolObject];
export interface ParticipantEndpoint extends Endpoint, Parsable {
    /**
     * CPU number of cores used by the media endpoint.
     */
    cpuCoresCount?: number;
    /**
     * CPU name used by the media endpoint.
     */
    cpuName?: string;
    /**
     * CPU processor speed used by the media endpoint.
     */
    cpuProcessorSpeedInMhz?: number;
    /**
     * The feedback provided by the user of this endpoint about the quality of the session.
     */
    feedback?: UserFeedback;
    /**
     * Identity associated with the endpoint.
     */
    identity?: IdentitySet;
    /**
     * Name of the device used by the media endpoint.
     */
    name?: string;
}
export type ProductFamily = (typeof ProductFamilyObject)[keyof typeof ProductFamilyObject];
export type PstnCallDurationSource = (typeof PstnCallDurationSourceObject)[keyof typeof PstnCallDurationSourceObject];
export interface PstnCallLogRow extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The source of the call duration data. If the call uses a third-party telecommunications operator via the Operator Connect Program, the operator can provide their own call duration data. In this case, the property value is operator. Otherwise, the value is microsoft.
     */
    callDurationSource?: PstnCallDurationSource;
    /**
     * Number dialed in E.164 format.
     */
    calleeNumber?: string;
    /**
     * Number that received the call for inbound calls or the number dialed for outbound calls. E.164 format.
     */
    callerNumber?: string;
    /**
     * Call identifier. Not guaranteed to be unique.
     */
    callId?: string;
    /**
     * Indicates whether the call was a PSTN outbound or inbound call and the type of call, such as a call placed by a user or an audio conference.
     */
    callType?: string;
    /**
     * Amount of money or cost of the call that is charged to your account.
     */
    charge?: number;
    /**
     * ID of the audio conference.
     */
    conferenceId?: string;
    /**
     * Connection fee price.
     */
    connectionCharge?: number;
    /**
     * Type of currency used to calculate the cost of the call. For details, see (ISO 4217.
     */
    currency?: string;
    /**
     * Whether the call was domestic (within a country or region) or international (outside a country or region), based on the user's location.
     */
    destinationContext?: string;
    /**
     * Country or region dialed.
     */
    destinationName?: string;
    /**
     * How long the call was connected, in seconds.
     */
    duration?: number;
    /**
     * Call end time.
     */
    endDateTime?: Date;
    /**
     * Unique call identifier. GUID.
     */
    id?: string;
    /**
     * User's phone number type, such as a service of toll-free number.
     */
    inventoryType?: string;
    /**
     * The license used for the call.
     */
    licenseCapability?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The telecommunications operator which provided PSTN services for this call. This might be Microsoft, or it might be a third-party operator via the Operator Connect Program.
     */
    operator?: string;
    /**
     * Call start time.
     */
    startDateTime?: Date;
    /**
     * Country code of the tenant. For details, see ISO 3166-1 alpha-2.
     */
    tenantCountryCode?: string;
    /**
     * Country code of the user. For details, see ISO 3166-1 alpha-2.
     */
    usageCountryCode?: string;
    /**
     * Display name of the user.
     */
    userDisplayName?: string;
    /**
     * Calling user's ID in Microsoft Graph. GUID. This and other user info will be null/empty for bot call types (ucapin, ucapout).
     */
    userId?: string;
    /**
     * The user principal name (sign-in name) in Microsoft Entra ID. This is usually the same as the user's SIP address, and can be the same as the user's email address.
     */
    userPrincipalName?: string;
}
export interface Segment extends Entity, Parsable {
    /**
     * Endpoint that answered this segment.
     */
    callee?: Endpoint;
    /**
     * Endpoint that initiated this segment.
     */
    caller?: Endpoint;
    /**
     * UTC time when the segment ended. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    endDateTime?: Date;
    /**
     * Failure information associated with the segment if it failed.
     */
    failureInfo?: FailureInfo;
    /**
     * Media associated with this segment.
     */
    media?: Media[];
    /**
     * UTC time when the segment started. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    startDateTime?: Date;
}
export interface SegmentCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Segment[];
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCallRecord(writer: SerializationWriter, callRecord: Partial<CallRecord> | undefined = {}) : void {
    serializeEntity(writer, callRecord)
    writer.writeDateValue("endDateTime", callRecord.endDateTime);
    writer.writeStringValue("joinWebUrl", callRecord.joinWebUrl);
    writer.writeDateValue("lastModifiedDateTime", callRecord.lastModifiedDateTime);
    if(callRecord.modalities)
    writer.writeEnumValue<Modality>("modalities", ...callRecord.modalities);
    writer.writeObjectValue<IdentitySet>("organizer", callRecord.organizer, serializeIdentitySet);
    writer.writeCollectionOfObjectValues<IdentitySet>("participants", callRecord.participants, serializeIdentitySet);
    writer.writeCollectionOfObjectValues<Session>("sessions", callRecord.sessions, serializeSession);
    writer.writeDateValue("startDateTime", callRecord.startDateTime);
    writer.writeEnumValue<CallType>("type", callRecord.type);
    writer.writeNumberValue("version", callRecord.version);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCallRecordCollectionResponse(writer: SerializationWriter, callRecordCollectionResponse: Partial<CallRecordCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, callRecordCollectionResponse)
    writer.writeCollectionOfObjectValues<CallRecord>("value", callRecordCollectionResponse.value, serializeCallRecord);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeClientUserAgent(writer: SerializationWriter, clientUserAgent: Partial<ClientUserAgent> | undefined = {}) : void {
    serializeUserAgent(writer, clientUserAgent)
    writer.writeStringValue("azureADAppId", clientUserAgent.azureADAppId);
    writer.writeStringValue("communicationServiceId", clientUserAgent.communicationServiceId);
    writer.writeEnumValue<ClientPlatform>("platform", clientUserAgent.platform);
    writer.writeEnumValue<ProductFamily>("productFamily", clientUserAgent.productFamily);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDeviceInfo(writer: SerializationWriter, deviceInfo: Partial<DeviceInfo> | undefined = {}) : void {
    writer.writeStringValue("captureDeviceDriver", deviceInfo.captureDeviceDriver);
    writer.writeStringValue("captureDeviceName", deviceInfo.captureDeviceName);
    writer.writeNumberValue("captureNotFunctioningEventRatio", deviceInfo.captureNotFunctioningEventRatio);
    writer.writeNumberValue("cpuInsufficentEventRatio", deviceInfo.cpuInsufficentEventRatio);
    writer.writeNumberValue("deviceClippingEventRatio", deviceInfo.deviceClippingEventRatio);
    writer.writeNumberValue("deviceGlitchEventRatio", deviceInfo.deviceGlitchEventRatio);
    writer.writeNumberValue("howlingEventCount", deviceInfo.howlingEventCount);
    writer.writeNumberValue("initialSignalLevelRootMeanSquare", deviceInfo.initialSignalLevelRootMeanSquare);
    writer.writeNumberValue("lowSpeechLevelEventRatio", deviceInfo.lowSpeechLevelEventRatio);
    writer.writeNumberValue("lowSpeechToNoiseEventRatio", deviceInfo.lowSpeechToNoiseEventRatio);
    writer.writeNumberValue("micGlitchRate", deviceInfo.micGlitchRate);
    writer.writeStringValue("@odata.type", deviceInfo.odataType);
    writer.writeNumberValue("receivedNoiseLevel", deviceInfo.receivedNoiseLevel);
    writer.writeNumberValue("receivedSignalLevel", deviceInfo.receivedSignalLevel);
    writer.writeStringValue("renderDeviceDriver", deviceInfo.renderDeviceDriver);
    writer.writeStringValue("renderDeviceName", deviceInfo.renderDeviceName);
    writer.writeNumberValue("renderMuteEventRatio", deviceInfo.renderMuteEventRatio);
    writer.writeNumberValue("renderNotFunctioningEventRatio", deviceInfo.renderNotFunctioningEventRatio);
    writer.writeNumberValue("renderZeroVolumeEventRatio", deviceInfo.renderZeroVolumeEventRatio);
    writer.writeNumberValue("sentNoiseLevel", deviceInfo.sentNoiseLevel);
    writer.writeNumberValue("sentSignalLevel", deviceInfo.sentSignalLevel);
    writer.writeNumberValue("speakerGlitchRate", deviceInfo.speakerGlitchRate);
    writer.writeAdditionalData(deviceInfo.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDirectRoutingLogRow(writer: SerializationWriter, directRoutingLogRow: Partial<DirectRoutingLogRow> | undefined = {}) : void {
    writer.writeStringValue("calleeNumber", directRoutingLogRow.calleeNumber);
    writer.writeNumberValue("callEndSubReason", directRoutingLogRow.callEndSubReason);
    writer.writeStringValue("callerNumber", directRoutingLogRow.callerNumber);
    writer.writeStringValue("callType", directRoutingLogRow.callType);
    writer.writeStringValue("correlationId", directRoutingLogRow.correlationId);
    writer.writeNumberValue("duration", directRoutingLogRow.duration);
    writer.writeDateValue("endDateTime", directRoutingLogRow.endDateTime);
    writer.writeDateValue("failureDateTime", directRoutingLogRow.failureDateTime);
    writer.writeNumberValue("finalSipCode", directRoutingLogRow.finalSipCode);
    writer.writeStringValue("finalSipCodePhrase", directRoutingLogRow.finalSipCodePhrase);
    writer.writeStringValue("id", directRoutingLogRow.id);
    writer.writeDateValue("inviteDateTime", directRoutingLogRow.inviteDateTime);
    writer.writeBooleanValue("mediaBypassEnabled", directRoutingLogRow.mediaBypassEnabled);
    writer.writeStringValue("mediaPathLocation", directRoutingLogRow.mediaPathLocation);
    writer.writeStringValue("@odata.type", directRoutingLogRow.odataType);
    writer.writeStringValue("signalingLocation", directRoutingLogRow.signalingLocation);
    writer.writeDateValue("startDateTime", directRoutingLogRow.startDateTime);
    writer.writeBooleanValue("successfulCall", directRoutingLogRow.successfulCall);
    writer.writeStringValue("trunkFullyQualifiedDomainName", directRoutingLogRow.trunkFullyQualifiedDomainName);
    writer.writeStringValue("userDisplayName", directRoutingLogRow.userDisplayName);
    writer.writeStringValue("userId", directRoutingLogRow.userId);
    writer.writeStringValue("userPrincipalName", directRoutingLogRow.userPrincipalName);
    writer.writeAdditionalData(directRoutingLogRow.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEndpoint(writer: SerializationWriter, endpoint: Partial<Endpoint> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", endpoint.odataType);
    writer.writeObjectValue<UserAgent>("userAgent", endpoint.userAgent, serializeUserAgent);
    writer.writeAdditionalData(endpoint.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFailureInfo(writer: SerializationWriter, failureInfo: Partial<FailureInfo> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", failureInfo.odataType);
    writer.writeStringValue("reason", failureInfo.reason);
    writer.writeEnumValue<FailureStage>("stage", failureInfo.stage);
    writer.writeAdditionalData(failureInfo.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFeedbackTokenSet(writer: SerializationWriter, feedbackTokenSet: Partial<FeedbackTokenSet> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", feedbackTokenSet.odataType);
    writer.writeAdditionalData(feedbackTokenSet.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMedia(writer: SerializationWriter, media: Partial<Media> | undefined = {}) : void {
    writer.writeObjectValue<DeviceInfo>("calleeDevice", media.calleeDevice, serializeDeviceInfo);
    writer.writeObjectValue<NetworkInfo>("calleeNetwork", media.calleeNetwork, serializeNetworkInfo);
    writer.writeObjectValue<DeviceInfo>("callerDevice", media.callerDevice, serializeDeviceInfo);
    writer.writeObjectValue<NetworkInfo>("callerNetwork", media.callerNetwork, serializeNetworkInfo);
    writer.writeStringValue("label", media.label);
    writer.writeStringValue("@odata.type", media.odataType);
    writer.writeCollectionOfObjectValues<MediaStream>("streams", media.streams, serializeMediaStream);
    writer.writeAdditionalData(media.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMediaStream(writer: SerializationWriter, mediaStream: Partial<MediaStream> | undefined = {}) : void {
    writer.writeEnumValue<AudioCodec>("audioCodec", mediaStream.audioCodec);
    writer.writeNumberValue("averageAudioDegradation", mediaStream.averageAudioDegradation);
    writer.writeDurationValue("averageAudioNetworkJitter", mediaStream.averageAudioNetworkJitter);
    writer.writeNumberValue("averageBandwidthEstimate", mediaStream.averageBandwidthEstimate);
    writer.writeDurationValue("averageFreezeDuration", mediaStream.averageFreezeDuration);
    writer.writeDurationValue("averageJitter", mediaStream.averageJitter);
    writer.writeNumberValue("averagePacketLossRate", mediaStream.averagePacketLossRate);
    writer.writeNumberValue("averageRatioOfConcealedSamples", mediaStream.averageRatioOfConcealedSamples);
    writer.writeNumberValue("averageReceivedFrameRate", mediaStream.averageReceivedFrameRate);
    writer.writeDurationValue("averageRoundTripTime", mediaStream.averageRoundTripTime);
    writer.writeNumberValue("averageVideoFrameLossPercentage", mediaStream.averageVideoFrameLossPercentage);
    writer.writeNumberValue("averageVideoFrameRate", mediaStream.averageVideoFrameRate);
    writer.writeNumberValue("averageVideoPacketLossRate", mediaStream.averageVideoPacketLossRate);
    writer.writeDateValue("endDateTime", mediaStream.endDateTime);
    writer.writeBooleanValue("isAudioForwardErrorCorrectionUsed", mediaStream.isAudioForwardErrorCorrectionUsed);
    writer.writeNumberValue("lowFrameRateRatio", mediaStream.lowFrameRateRatio);
    writer.writeNumberValue("lowVideoProcessingCapabilityRatio", mediaStream.lowVideoProcessingCapabilityRatio);
    writer.writeDurationValue("maxAudioNetworkJitter", mediaStream.maxAudioNetworkJitter);
    writer.writeDurationValue("maxJitter", mediaStream.maxJitter);
    writer.writeNumberValue("maxPacketLossRate", mediaStream.maxPacketLossRate);
    writer.writeNumberValue("maxRatioOfConcealedSamples", mediaStream.maxRatioOfConcealedSamples);
    writer.writeDurationValue("maxRoundTripTime", mediaStream.maxRoundTripTime);
    writer.writeStringValue("@odata.type", mediaStream.odataType);
    writer.writeNumberValue("packetUtilization", mediaStream.packetUtilization);
    writer.writeNumberValue("postForwardErrorCorrectionPacketLossRate", mediaStream.postForwardErrorCorrectionPacketLossRate);
    writer.writeDurationValue("rmsFreezeDuration", mediaStream.rmsFreezeDuration);
    writer.writeDateValue("startDateTime", mediaStream.startDateTime);
    writer.writeEnumValue<MediaStreamDirection>("streamDirection", mediaStream.streamDirection);
    writer.writeStringValue("streamId", mediaStream.streamId);
    writer.writeEnumValue<VideoCodec>("videoCodec", mediaStream.videoCodec);
    writer.writeBooleanValue("wasMediaBypassed", mediaStream.wasMediaBypassed);
    writer.writeAdditionalData(mediaStream.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeNetworkInfo(writer: SerializationWriter, networkInfo: Partial<NetworkInfo> | undefined = {}) : void {
    writer.writeNumberValue("bandwidthLowEventRatio", networkInfo.bandwidthLowEventRatio);
    writer.writeStringValue("basicServiceSetIdentifier", networkInfo.basicServiceSetIdentifier);
    writer.writeEnumValue<NetworkConnectionType>("connectionType", networkInfo.connectionType);
    writer.writeNumberValue("delayEventRatio", networkInfo.delayEventRatio);
    writer.writeStringValue("dnsSuffix", networkInfo.dnsSuffix);
    writer.writeStringValue("ipAddress", networkInfo.ipAddress);
    writer.writeNumberValue("linkSpeed", networkInfo.linkSpeed);
    writer.writeStringValue("macAddress", networkInfo.macAddress);
    writer.writeEnumValue<NetworkTransportProtocol>("networkTransportProtocol", networkInfo.networkTransportProtocol);
    writer.writeStringValue("@odata.type", networkInfo.odataType);
    writer.writeNumberValue("port", networkInfo.port);
    writer.writeNumberValue("receivedQualityEventRatio", networkInfo.receivedQualityEventRatio);
    writer.writeStringValue("reflexiveIPAddress", networkInfo.reflexiveIPAddress);
    writer.writeStringValue("relayIPAddress", networkInfo.relayIPAddress);
    writer.writeNumberValue("relayPort", networkInfo.relayPort);
    writer.writeNumberValue("sentQualityEventRatio", networkInfo.sentQualityEventRatio);
    writer.writeStringValue("subnet", networkInfo.subnet);
    writer.writeCollectionOfObjectValues<TraceRouteHop>("traceRouteHops", networkInfo.traceRouteHops, serializeTraceRouteHop);
    writer.writeEnumValue<WifiBand>("wifiBand", networkInfo.wifiBand);
    writer.writeNumberValue("wifiBatteryCharge", networkInfo.wifiBatteryCharge);
    writer.writeNumberValue("wifiChannel", networkInfo.wifiChannel);
    writer.writeStringValue("wifiMicrosoftDriver", networkInfo.wifiMicrosoftDriver);
    writer.writeStringValue("wifiMicrosoftDriverVersion", networkInfo.wifiMicrosoftDriverVersion);
    writer.writeEnumValue<WifiRadioType>("wifiRadioType", networkInfo.wifiRadioType);
    writer.writeNumberValue("wifiSignalStrength", networkInfo.wifiSignalStrength);
    writer.writeStringValue("wifiVendorDriver", networkInfo.wifiVendorDriver);
    writer.writeStringValue("wifiVendorDriverVersion", networkInfo.wifiVendorDriverVersion);
    writer.writeAdditionalData(networkInfo.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeParticipantEndpoint(writer: SerializationWriter, participantEndpoint: Partial<ParticipantEndpoint> | undefined = {}) : void {
    serializeEndpoint(writer, participantEndpoint)
    writer.writeNumberValue("cpuCoresCount", participantEndpoint.cpuCoresCount);
    writer.writeStringValue("cpuName", participantEndpoint.cpuName);
    writer.writeNumberValue("cpuProcessorSpeedInMhz", participantEndpoint.cpuProcessorSpeedInMhz);
    writer.writeObjectValue<UserFeedback>("feedback", participantEndpoint.feedback, serializeUserFeedback);
    writer.writeObjectValue<IdentitySet>("identity", participantEndpoint.identity, serializeIdentitySet);
    writer.writeStringValue("name", participantEndpoint.name);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializePstnCallLogRow(writer: SerializationWriter, pstnCallLogRow: Partial<PstnCallLogRow> | undefined = {}) : void {
    writer.writeEnumValue<PstnCallDurationSource>("callDurationSource", pstnCallLogRow.callDurationSource);
    writer.writeStringValue("calleeNumber", pstnCallLogRow.calleeNumber);
    writer.writeStringValue("callerNumber", pstnCallLogRow.callerNumber);
    writer.writeStringValue("callId", pstnCallLogRow.callId);
    writer.writeStringValue("callType", pstnCallLogRow.callType);
    writer.writeNumberValue("charge", pstnCallLogRow.charge);
    writer.writeStringValue("conferenceId", pstnCallLogRow.conferenceId);
    writer.writeNumberValue("connectionCharge", pstnCallLogRow.connectionCharge);
    writer.writeStringValue("currency", pstnCallLogRow.currency);
    writer.writeStringValue("destinationContext", pstnCallLogRow.destinationContext);
    writer.writeStringValue("destinationName", pstnCallLogRow.destinationName);
    writer.writeNumberValue("duration", pstnCallLogRow.duration);
    writer.writeDateValue("endDateTime", pstnCallLogRow.endDateTime);
    writer.writeStringValue("id", pstnCallLogRow.id);
    writer.writeStringValue("inventoryType", pstnCallLogRow.inventoryType);
    writer.writeStringValue("licenseCapability", pstnCallLogRow.licenseCapability);
    writer.writeStringValue("@odata.type", pstnCallLogRow.odataType);
    writer.writeStringValue("operator", pstnCallLogRow.operator);
    writer.writeDateValue("startDateTime", pstnCallLogRow.startDateTime);
    writer.writeStringValue("tenantCountryCode", pstnCallLogRow.tenantCountryCode);
    writer.writeStringValue("usageCountryCode", pstnCallLogRow.usageCountryCode);
    writer.writeStringValue("userDisplayName", pstnCallLogRow.userDisplayName);
    writer.writeStringValue("userId", pstnCallLogRow.userId);
    writer.writeStringValue("userPrincipalName", pstnCallLogRow.userPrincipalName);
    writer.writeAdditionalData(pstnCallLogRow.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSegment(writer: SerializationWriter, segment: Partial<Segment> | undefined = {}) : void {
    serializeEntity(writer, segment)
    writer.writeObjectValue<Endpoint>("callee", segment.callee, serializeEndpoint);
    writer.writeObjectValue<Endpoint>("caller", segment.caller, serializeEndpoint);
    writer.writeDateValue("endDateTime", segment.endDateTime);
    writer.writeObjectValue<FailureInfo>("failureInfo", segment.failureInfo, serializeFailureInfo);
    writer.writeCollectionOfObjectValues<Media>("media", segment.media, serializeMedia);
    writer.writeDateValue("startDateTime", segment.startDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSegmentCollectionResponse(writer: SerializationWriter, segmentCollectionResponse: Partial<SegmentCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, segmentCollectionResponse)
    writer.writeCollectionOfObjectValues<Segment>("value", segmentCollectionResponse.value, serializeSegment);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeServiceEndpoint(writer: SerializationWriter, serviceEndpoint: Partial<ServiceEndpoint> | undefined = {}) : void {
    serializeEndpoint(writer, serviceEndpoint)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeServiceUserAgent(writer: SerializationWriter, serviceUserAgent: Partial<ServiceUserAgent> | undefined = {}) : void {
    serializeUserAgent(writer, serviceUserAgent)
    writer.writeEnumValue<ServiceRole>("role", serviceUserAgent.role);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSession(writer: SerializationWriter, session: Partial<Session> | undefined = {}) : void {
    serializeEntity(writer, session)
    writer.writeObjectValue<Endpoint>("callee", session.callee, serializeEndpoint);
    writer.writeObjectValue<Endpoint>("caller", session.caller, serializeEndpoint);
    writer.writeDateValue("endDateTime", session.endDateTime);
    writer.writeObjectValue<FailureInfo>("failureInfo", session.failureInfo, serializeFailureInfo);
    writer.writeBooleanValue("isTest", session.isTest);
    if(session.modalities)
    writer.writeEnumValue<Modality>("modalities", ...session.modalities);
    writer.writeCollectionOfObjectValues<Segment>("segments", session.segments, serializeSegment);
    writer.writeDateValue("startDateTime", session.startDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSessionCollectionResponse(writer: SerializationWriter, sessionCollectionResponse: Partial<SessionCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, sessionCollectionResponse)
    writer.writeCollectionOfObjectValues<Session>("value", sessionCollectionResponse.value, serializeSession);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTraceRouteHop(writer: SerializationWriter, traceRouteHop: Partial<TraceRouteHop> | undefined = {}) : void {
    writer.writeNumberValue("hopCount", traceRouteHop.hopCount);
    writer.writeStringValue("ipAddress", traceRouteHop.ipAddress);
    writer.writeStringValue("@odata.type", traceRouteHop.odataType);
    writer.writeDurationValue("roundTripTime", traceRouteHop.roundTripTime);
    writer.writeAdditionalData(traceRouteHop.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUserAgent(writer: SerializationWriter, userAgent: Partial<UserAgent> | undefined = {}) : void {
    writer.writeStringValue("applicationVersion", userAgent.applicationVersion);
    writer.writeStringValue("headerValue", userAgent.headerValue);
    writer.writeStringValue("@odata.type", userAgent.odataType);
    writer.writeAdditionalData(userAgent.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUserFeedback(writer: SerializationWriter, userFeedback: Partial<UserFeedback> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", userFeedback.odataType);
    writer.writeEnumValue<UserFeedbackRating>("rating", userFeedback.rating);
    writer.writeStringValue("text", userFeedback.text);
    writer.writeObjectValue<FeedbackTokenSet>("tokens", userFeedback.tokens, serializeFeedbackTokenSet);
    writer.writeAdditionalData(userFeedback.additionalData);
}
export interface ServiceEndpoint extends Endpoint, Parsable {
}
export type ServiceRole = (typeof ServiceRoleObject)[keyof typeof ServiceRoleObject];
export interface ServiceUserAgent extends Parsable, UserAgent {
    /**
     * The role property
     */
    role?: ServiceRole;
}
export interface Session extends Entity, Parsable {
    /**
     * Endpoint that answered the session.
     */
    callee?: Endpoint;
    /**
     * Endpoint that initiated the session.
     */
    caller?: Endpoint;
    /**
     * UTC time when the last user left the session. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    endDateTime?: Date;
    /**
     * Failure information associated with the session if the session failed.
     */
    failureInfo?: FailureInfo;
    /**
     * Specifies whether the session is a test.
     */
    isTest?: boolean;
    /**
     * List of modalities present in the session. Possible values are: unknown, audio, video, videoBasedScreenSharing, data, screenSharing, unknownFutureValue.
     */
    modalities?: Modality[];
    /**
     * The list of segments involved in the session. Read-only. Nullable.
     */
    segments?: Segment[];
    /**
     * UTC time when the first user joined the session. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    startDateTime?: Date;
}
export interface SessionCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: Session[];
}
export interface TraceRouteHop extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The network path count of this hop that was used to compute the RTT.
     */
    hopCount?: number;
    /**
     * IP address used for this hop in the network trace.
     */
    ipAddress?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The time from when the trace route packet was sent from the client to this hop and back to the client, denoted in [ISO 8601][] format. For example, 1 second is denoted as PT1S, where P is the duration designator, T is the time designator, and S is the second designator.
     */
    roundTripTime?: Duration;
}
export interface UserAgent extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Identifies the version of application software used by this endpoint.
     */
    applicationVersion?: string;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * User-agent header value reported by this endpoint.
     */
    headerValue?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface UserFeedback extends AdditionalDataHolder, BackedModel, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Stores model information.
     */
    backingStoreEnabled?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The rating property
     */
    rating?: UserFeedbackRating;
    /**
     * The feedback text provided by the user of this endpoint for the session.
     */
    text?: string;
    /**
     * The set of feedback tokens provided by the user of this endpoint for the session. This is a set of Boolean properties. The property names should not be relied upon since they may change depending on what tokens are offered to the user.
     */
    tokens?: FeedbackTokenSet;
}
export type UserFeedbackRating = (typeof UserFeedbackRatingObject)[keyof typeof UserFeedbackRatingObject];
export type VideoCodec = (typeof VideoCodecObject)[keyof typeof VideoCodecObject];
export type WifiBand = (typeof WifiBandObject)[keyof typeof WifiBandObject];
export type WifiRadioType = (typeof WifiRadioTypeObject)[keyof typeof WifiRadioTypeObject];
export const AudioCodecObject = {
    Unknown: "unknown",
    Invalid: "invalid",
    Cn: "cn",
    Pcma: "pcma",
    Pcmu: "pcmu",
    AmrWide: "amrWide",
    G722: "g722",
    G7221: "g7221",
    G7221c: "g7221c",
    G729: "g729",
    MultiChannelAudio: "multiChannelAudio",
    Muchv2: "muchv2",
    Opus: "opus",
    Satin: "satin",
    SatinFullband: "satinFullband",
    RtAudio8: "rtAudio8",
    RtAudio16: "rtAudio16",
    Silk: "silk",
    SilkNarrow: "silkNarrow",
    SilkWide: "silkWide",
    Siren: "siren",
    XmsRta: "xmsRta",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const CallTypeObject = {
    Unknown: "unknown",
    GroupCall: "groupCall",
    PeerToPeer: "peerToPeer",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ClientPlatformObject = {
    Unknown: "unknown",
    Windows: "windows",
    MacOS: "macOS",
    IOS: "iOS",
    Android: "android",
    Web: "web",
    IpPhone: "ipPhone",
    RoomSystem: "roomSystem",
    SurfaceHub: "surfaceHub",
    HoloLens: "holoLens",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const FailureStageObject = {
    Unknown: "unknown",
    CallSetup: "callSetup",
    Midcall: "midcall",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const MediaStreamDirectionObject = {
    CallerToCallee: "callerToCallee",
    CalleeToCaller: "calleeToCaller",
} as const;
export const ModalityObject = {
    Audio: "audio",
    Video: "video",
    VideoBasedScreenSharing: "videoBasedScreenSharing",
    Data: "data",
    ScreenSharing: "screenSharing",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const NetworkConnectionTypeObject = {
    Unknown: "unknown",
    Wired: "wired",
    Wifi: "wifi",
    Mobile: "mobile",
    Tunnel: "tunnel",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const NetworkTransportProtocolObject = {
    Unknown: "unknown",
    Udp: "udp",
    Tcp: "tcp",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ProductFamilyObject = {
    Unknown: "unknown",
    Teams: "teams",
    SkypeForBusiness: "skypeForBusiness",
    Lync: "lync",
    UnknownFutureValue: "unknownFutureValue",
    AzureCommunicationServices: "azureCommunicationServices",
} as const;
export const PstnCallDurationSourceObject = {
    Microsoft: "microsoft",
    Operator: "operator",
} as const;
export const ServiceRoleObject = {
    Unknown: "unknown",
    CustomBot: "customBot",
    SkypeForBusinessMicrosoftTeamsGateway: "skypeForBusinessMicrosoftTeamsGateway",
    SkypeForBusinessAudioVideoMcu: "skypeForBusinessAudioVideoMcu",
    SkypeForBusinessApplicationSharingMcu: "skypeForBusinessApplicationSharingMcu",
    SkypeForBusinessCallQueues: "skypeForBusinessCallQueues",
    SkypeForBusinessAutoAttendant: "skypeForBusinessAutoAttendant",
    MediationServer: "mediationServer",
    MediationServerCloudConnectorEdition: "mediationServerCloudConnectorEdition",
    ExchangeUnifiedMessagingService: "exchangeUnifiedMessagingService",
    MediaController: "mediaController",
    ConferencingAnnouncementService: "conferencingAnnouncementService",
    ConferencingAttendant: "conferencingAttendant",
    AudioTeleconferencerController: "audioTeleconferencerController",
    SkypeForBusinessUnifiedCommunicationApplicationPlatform: "skypeForBusinessUnifiedCommunicationApplicationPlatform",
    ResponseGroupServiceAnnouncementService: "responseGroupServiceAnnouncementService",
    Gateway: "gateway",
    SkypeTranslator: "skypeTranslator",
    SkypeForBusinessAttendant: "skypeForBusinessAttendant",
    ResponseGroupService: "responseGroupService",
    Voicemail: "voicemail",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const UserFeedbackRatingObject = {
    NotRated: "notRated",
    Bad: "bad",
    Poor: "poor",
    Fair: "fair",
    Good: "good",
    Excellent: "excellent",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const VideoCodecObject = {
    Unknown: "unknown",
    Invalid: "invalid",
    Av1: "av1",
    H263: "h263",
    H264: "h264",
    H264s: "h264s",
    H264uc: "h264uc",
    H265: "h265",
    Rtvc1: "rtvc1",
    RtVideo: "rtVideo",
    Xrtvc1: "xrtvc1",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const WifiBandObject = {
    Unknown: "unknown",
    Frequency24GHz: "frequency24GHz",
    Frequency50GHz: "frequency50GHz",
    Frequency60GHz: "frequency60GHz",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const WifiRadioTypeObject = {
    Unknown: "unknown",
    Wifi80211a: "wifi80211a",
    Wifi80211b: "wifi80211b",
    Wifi80211g: "wifi80211g",
    Wifi80211n: "wifi80211n",
    Wifi80211ac: "wifi80211ac",
    Wifi80211ax: "wifi80211ax",
    UnknownFutureValue: "unknownFutureValue",
} as const;
/* tslint:enable */
/* eslint-enable */
